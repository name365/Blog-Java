<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>Data Access</title>
<style>
@import 'css/spring.css';

.listingblock .switch {
    border-style: none;
    display: inline-block;
    position: relative;
    bottom: -3px;
}

.listingblock .switch--item {
    padding: 10px;
    background-color: #e6e1dc;
    color: #282c34;
    display: inline-block;
    cursor: pointer;
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
}

.listingblock .switch--item:not(:first-child) {
    border-style: none;
}

.listingblock .switch--item.selected {
    background-color: #282c34;
    color: #e6e1dc;
}

.listingblock pre.highlightjs {
    padding: 0;
}

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
.hidden {
	display: none;
}

.switch {
	border-width: 1px 1px 0 1px;
	border-style: solid;
	border-color: #7a2518;
	display: inline-block;
}

.switch--item {
	padding: 10px;
	background-color: #ffffff;
	color: #7a2518;
	display: inline-block;
	cursor: pointer;
}

.switch--item:not(:first-child) {
	border-width: 0 0 0 1px;
	border-style: solid;
	border-color: #7a2518;
}

.switch--item.selected {
	background-color: #7a2519;
	color: #ffffff;
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
<script type="text/javascript">
function addBlockSwitches() {
	$('.primary').each(function() {
		primary = $(this);
		createSwitchItem(primary, createBlockSwitch(primary)).item.addClass("selected");
		primary.children('.title').remove();
	});
	$('.secondary').each(function(idx, node) {
		secondary = $(node);
		primary = findPrimary(secondary);
		switchItem = createSwitchItem(secondary, primary.children('.switch'));
		switchItem.content.addClass('hidden');
		findPrimary(secondary).append(switchItem.content);
		secondary.remove();
	});
}

function createBlockSwitch(primary) {
	blockSwitch = $('<div class="switch"></div>');
	primary.prepend(blockSwitch);
	return blockSwitch;
}

function findPrimary(secondary) {
	candidate = secondary.prev();
	while (!candidate.is('.primary')) {
		candidate = candidate.prev();
	}
	return candidate;
}

function createSwitchItem(block, blockSwitch) {
	blockName = block.children('.title').text();
	content = block.children('.content').first().append(block.next('.colist'));
	item = $('<div class="switch--item">' + blockName + '</div>');
	blockSwitch.append(item);
	return {'item': item, 'content': content};
}

function globalSwitch() {
	$('.switch--item').each(function() {
		var blockId = blockIdForSwitchItem($(this));
		$(this).off('click');
		$(this).on('click', function() {
			selectedText = $(this).text()
			window.localStorage.setItem(blockId, selectedText);
			$(".switch--item").filter(function() {
				return blockIdForSwitchItem($(this)) === blockId;
			}).filter(function() {
				return $(this).text() === selectedText;
			}).each(function() {
				select($(this))
			});
		});
		if ($(this).text() === window.localStorage.getItem(blockId)) {
			select($(this))
		}
	});
}

function blockIdForSwitchItem(item) {
	idComponents = []
	idComponents.push(item.text().toLowerCase());
	item.siblings(".switch--item").each(function(index, sibling) {
		idComponents.push($(sibling).text().toLowerCase());
	});
	return idComponents.sort().join("-")
}

function select(selected) {
	selected.addClass('selected');
	selected.siblings().removeClass('selected');
	selectedContent = selected.parent().siblings(".content").eq(selected.index())
	selectedContent.removeClass('hidden');
	selectedContent.siblings().addClass('hidden');
}

$(addBlockSwitches);
$(globalSwitch);

</script>

</head>
<body id="spring-data-tier" class="book toc2 toc-left">
<div id="header">
<h1>Spring Framework Documentation</h1>
<span><strong>5.3.9</strong></span>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This part of the reference documentation is concerned with data access and the
interaction between the data access layer and the business or service layer.</p>
</div>
<div class="paragraph">
<p>Spring&#8217;s comprehensive transaction management support is covered in some detail,
followed by thorough coverage of the various data access frameworks and technologies
with which the Spring Framework integrates.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="transaction"><a class="anchor" href="#transaction"></a>1. Transaction Management</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Comprehensive transaction support is among the most compelling reasons to use the Spring
Framework. The Spring Framework provides a consistent abstraction for transaction
management that delivers the following benefits:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A consistent programming model across different transaction APIs, such as Java
Transaction API (JTA), JDBC, Hibernate, and the Java Persistence API (JPA).</p>
</li>
<li>
<p>Support for <a href="#transaction-declarative">declarative transaction management</a>.</p>
</li>
<li>
<p>A simpler API for <a href="#transaction-programmatic">programmatic</a> transaction management
than complex transaction APIs, such as JTA.</p>
</li>
<li>
<p>Excellent integration with Spring&#8217;s data access abstractions.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following sections describe the Spring Framework&#8217;s transaction features and
technologies:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#transaction-motivation">Advantages of the Spring Framework&#8217;s transaction support
model</a> describes why you would use the Spring Framework&#8217;s transaction abstraction
instead of EJB Container-Managed Transactions (CMT) or choosing to drive local
transactions through a proprietary API, such as Hibernate.</p>
</li>
<li>
<p><a href="#transaction-strategies">Understanding the Spring Framework transaction abstraction</a>
outlines the core classes and describes how to configure and obtain <code>DataSource</code>
instances from a variety of sources.</p>
</li>
<li>
<p><a href="#tx-resource-synchronization">Synchronizing resources with transactions</a> describes
how the application code ensures that resources are created, reused, and cleaned up
properly.</p>
</li>
<li>
<p><a href="#transaction-declarative">Declarative transaction management</a> describes support for
declarative transaction management.</p>
</li>
<li>
<p><a href="#transaction-programmatic">Programmatic transaction management</a> covers support for
programmatic (that is, explicitly coded) transaction management.</p>
</li>
<li>
<p><a href="#transaction-event">Transaction bound event</a> describes how you could use application
events within a transaction.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The chapter also includes discussions of best practices,
<a href="#transaction-application-server-integration">application server integration</a>,
and <a href="#transaction-solutions-to-common-problems">solutions to common problems</a>.</p>
</div>
<div class="sect2">
<h3 id="transaction-motivation"><a class="anchor" href="#transaction-motivation"></a>1.1. Advantages of the Spring Framework&#8217;s Transaction Support Model</h3>
<div class="paragraph">
<p>Traditionally, Java EE developers have had two choices for transaction management:
global or local transactions, both of which have profound limitations. Global
and local transaction management is reviewed in the next two sections, followed by a
discussion of how the Spring Framework&#8217;s transaction management support addresses the
limitations of the global and local transaction models.</p>
</div>
<div class="sect3">
<h4 id="transaction-global"><a class="anchor" href="#transaction-global"></a>1.1.1. Global Transactions</h4>
<div class="paragraph">
<p>Global transactions let you work with multiple transactional resources, typically
relational databases and message queues. The application server manages global
transactions through the JTA, which is a cumbersome API (partly due to its
exception model). Furthermore, a JTA <code>UserTransaction</code> normally needs to be sourced from
JNDI, meaning that you also need to use JNDI in order to use JTA. The use
of global transactions limits any potential reuse of application code, as JTA is
normally only available in an application server environment.</p>
</div>
<div class="paragraph">
<p>Previously, the preferred way to use global transactions was through EJB CMT
(Container Managed Transaction). CMT is a form of declarative transaction
management (as distinguished from programmatic transaction management). EJB CMT
removes the need for transaction-related JNDI lookups, although the use of EJB
itself necessitates the use of JNDI. It removes most but not all of the need to write
Java code to control transactions. The significant downside is that CMT is tied to JTA
and an application server environment. Also, it is only available if one chooses to
implement business logic in EJBs (or at least behind a transactional EJB facade). The
negatives of EJB in general are so great that this is not an attractive proposition,
especially in the face of compelling alternatives for declarative transaction management.</p>
</div>
</div>
<div class="sect3">
<h4 id="transaction-local"><a class="anchor" href="#transaction-local"></a>1.1.2. Local Transactions</h4>
<div class="paragraph">
<p>Local transactions are resource-specific, such as a transaction associated with a JDBC
connection. Local transactions may be easier to use but have a significant disadvantage:
They cannot work across multiple transactional resources. For example, code that manages
transactions by using a JDBC connection cannot run within a global JTA transaction. Because
the application server is not involved in transaction management, it cannot help ensure
correctness across multiple resources. (It is worth noting that most applications use a
single transaction resource.) Another downside is that local transactions are invasive
to the programming model.</p>
</div>
</div>
<div class="sect3">
<h4 id="transaction-programming-model"><a class="anchor" href="#transaction-programming-model"></a>1.1.3. Spring Framework&#8217;s Consistent Programming Model</h4>
<div class="paragraph">
<p>Spring resolves the disadvantages of global and local transactions. It lets
application developers use a consistent programming model in any environment.
You write your code once, and it can benefit from different transaction management
strategies in different environments. The Spring Framework provides both declarative and
programmatic transaction management. Most users prefer declarative transaction
management, which we recommend in most cases.</p>
</div>
<div class="paragraph">
<p>With programmatic transaction management, developers work with the Spring Framework
transaction abstraction, which can run over any underlying transaction infrastructure.
With the preferred declarative model, developers typically write little or no code
related to transaction management and, hence, do not depend on the Spring Framework
transaction API or any other transaction API.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Do you need an application server for transaction management?</div>
<div class="paragraph">
<p>The Spring Framework&#8217;s transaction management support changes traditional rules as to
when an enterprise Java application requires an application server.</p>
</div>
<div class="paragraph">
<p>In particular, you do not need an application server purely for declarative transactions
through EJBs. In fact, even if your application server has powerful JTA capabilities,
you may decide that the Spring Framework&#8217;s declarative transactions offer more power and
a more productive programming model than EJB CMT.</p>
</div>
<div class="paragraph">
<p>Typically, you need an application server&#8217;s JTA capability only if your application needs
to handle transactions across multiple resources, which is not a requirement for many
applications. Many high-end applications use a single, highly scalable database (such as
Oracle RAC) instead. Stand-alone transaction managers (such as
<a href="https://www.atomikos.com/">Atomikos Transactions</a> and <a href="http://jotm.objectweb.org/">JOTM</a>)
are other options. Of course, you may need other application server capabilities, such as
Java Message Service (JMS) and Java EE Connector Architecture (JCA).</p>
</div>
<div class="paragraph">
<p>The Spring Framework gives you the choice of when to scale your application to a fully
loaded application server. Gone are the days when the only alternative to using EJB
CMT or JTA was to write code with local transactions (such as those on JDBC connections)
and face a hefty rework if you need that code to run within global, container-managed
transactions. With the Spring Framework, only some of the bean definitions in your
configuration file need to change (rather than your code).</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="transaction-strategies"><a class="anchor" href="#transaction-strategies"></a>1.2. Understanding the Spring Framework Transaction Abstraction</h3>
<div class="paragraph">
<p>The key to the Spring transaction abstraction is the notion of a transaction strategy. A
transaction strategy is defined by a <code>TransactionManager</code>, specifically the
<code>org.springframework.transaction.PlatformTransactionManager</code> interface for imperative
transaction management and the
<code>org.springframework.transaction.ReactiveTransactionManager</code> interface for reactive
transaction management. The following listing shows the definition of the
<code>PlatformTransactionManager</code> API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface PlatformTransactionManager extends TransactionManager {

    TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;

    void commit(TransactionStatus status) throws TransactionException;

    void rollback(TransactionStatus status) throws TransactionException;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is primarily a service provider interface (SPI), although you can use it
<a href="#transaction-programmatic-ptm">programmatically</a> from your application code. Because
<code>PlatformTransactionManager</code> is an interface, it can be easily mocked or stubbed as
necessary. It is not tied to a lookup strategy, such as JNDI.
<code>PlatformTransactionManager</code> implementations are defined like any other object (or bean)
in the Spring Framework IoC container. This benefit alone makes Spring Framework
transactions a worthwhile abstraction, even when you work with JTA. You can test
transactional code much more easily than if it used JTA directly.</p>
</div>
<div class="paragraph">
<p>Again, in keeping with Spring&#8217;s philosophy, the <code>TransactionException</code> that can be thrown
by any of the <code>PlatformTransactionManager</code> interface&#8217;s methods is unchecked (that
is, it extends the <code>java.lang.RuntimeException</code> class). Transaction infrastructure
failures are almost invariably fatal. In rare cases where application code can actually
recover from a transaction failure, the application developer can still choose to catch
and handle <code>TransactionException</code>. The salient point is that developers are not
<em>forced</em> to do so.</p>
</div>
<div class="paragraph">
<p>The <code>getTransaction(..)</code> method returns a <code>TransactionStatus</code> object, depending on a
<code>TransactionDefinition</code> parameter. The returned <code>TransactionStatus</code> might represent a
new transaction or can represent an existing transaction, if a matching transaction
exists in the current call stack. The implication in this latter case is that, as with
Java EE transaction contexts, a <code>TransactionStatus</code> is associated with a thread of
execution.</p>
</div>
<div class="paragraph">
<p>As of Spring Framework 5.2, Spring also provides a transaction management abstraction for
reactive applications that make use of reactive types or Kotlin Coroutines. The following
listing shows the transaction strategy defined by
<code>org.springframework.transaction.ReactiveTransactionManager</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface ReactiveTransactionManager extends TransactionManager {

    Mono&lt;ReactiveTransaction&gt; getReactiveTransaction(TransactionDefinition definition) throws TransactionException;

    Mono&lt;Void&gt; commit(ReactiveTransaction status) throws TransactionException;

    Mono&lt;Void&gt; rollback(ReactiveTransaction status) throws TransactionException;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The reactive transaction manager is primarily a service provider interface (SPI),
although you can use it <a href="#transaction-programmatic-rtm">programmatically</a> from your
application code. Because <code>ReactiveTransactionManager</code> is an interface, it can be easily
mocked or stubbed as necessary.</p>
</div>
<div class="paragraph">
<p>The <code>TransactionDefinition</code> interface specifies:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Propagation: Typically, all code within a transaction scope runs in
that transaction. However, you can specify the behavior if
a transactional method is run when a transaction context already exists. For
example, code can continue running in the existing transaction (the common case), or
the existing transaction can be suspended and a new transaction created. Spring
offers all of the transaction propagation options familiar from EJB CMT. To read
about the semantics of transaction propagation in Spring, see <a href="#tx-propagation">Transaction Propagation</a>.</p>
</li>
<li>
<p>Isolation: The degree to which this transaction is isolated from the work of other
transactions. For example, can this transaction see uncommitted writes from other
transactions?</p>
</li>
<li>
<p>Timeout: How long this transaction runs before timing out and being automatically rolled back
by the underlying transaction infrastructure.</p>
</li>
<li>
<p>Read-only status: You can use a read-only transaction when your code reads but
does not modify data. Read-only transactions can be a useful optimization in some
cases, such as when you use Hibernate.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These settings reflect standard transactional concepts. If necessary, refer to resources
that discuss transaction isolation levels and other core transaction concepts.
Understanding these concepts is essential to using the Spring Framework or any
transaction management solution.</p>
</div>
<div class="paragraph">
<p>The <code>TransactionStatus</code> interface provides a simple way for transactional code to
control transaction execution and query transaction status. The concepts should be
familiar, as they are common to all transaction APIs. The following listing shows the
<code>TransactionStatus</code> interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface TransactionStatus extends TransactionExecution, SavepointManager, Flushable {

    @Override
    boolean isNewTransaction();

    boolean hasSavepoint();

    @Override
    void setRollbackOnly();

    @Override
    boolean isRollbackOnly();

    void flush();

    @Override
    boolean isCompleted();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Regardless of whether you opt for declarative or programmatic transaction management in
Spring, defining the correct <code>TransactionManager</code> implementation is absolutely essential.
You typically define this implementation through dependency injection.</p>
</div>
<div class="paragraph">
<p><code>TransactionManager</code> implementations normally require knowledge of the environment in
which they work: JDBC, JTA, Hibernate, and so on. The following examples show how you can
define a local <code>PlatformTransactionManager</code> implementation (in this case, with plain
JDBC.)</p>
</div>
<div class="paragraph">
<p>You can define a JDBC <code>DataSource</code> by creating a bean similar to the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="${jdbc.driverClassName}" /&gt;
    &lt;property name="url" value="${jdbc.url}" /&gt;
    &lt;property name="username" value="${jdbc.username}" /&gt;
    &lt;property name="password" value="${jdbc.password}" /&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The related <code>PlatformTransactionManager</code> bean definition then has a reference to the
<code>DataSource</code> definition. It should resemble the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you use JTA in a Java EE container, then you use a container <code>DataSource</code>, obtained
through JNDI, in conjunction with Spring&#8217;s <code>JtaTransactionManager</code>. The following example
shows what the JTA and JNDI lookup version would look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:jee="http://www.springframework.org/schema/jee"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/jee
        https://www.springframework.org/schema/jee/spring-jee.xsd"&gt;

    &lt;jee:jndi-lookup id="dataSource" jndi-name="jdbc/jpetstore"/&gt;

    &lt;bean id="txManager" class="org.springframework.transaction.jta.JtaTransactionManager" /&gt;

    &lt;!-- other &lt;bean/&gt; definitions here --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>JtaTransactionManager</code> does not need to know about the <code>DataSource</code> (or any other
specific resources) because it uses the container&#8217;s global transaction management
infrastructure.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The preceding definition of the <code>dataSource</code> bean uses the <code>&lt;jndi-lookup/&gt;</code> tag
from the <code>jee</code> namespace. For more information see
<a href="integration.html#xsd-schemas-jee">The JEE Schema</a>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you use JTA, your transaction manager definition should look the same, regardless
of what data access technology you use, be it JDBC, Hibernate JPA, or any other supported
technology. This is due to the fact that JTA transactions are global transactions, which
can enlist any transactional resource.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In all Spring transaction setups, application code does not need to change. You can change
how transactions are managed merely by changing configuration, even if that change means
moving from local to global transactions or vice versa.</p>
</div>
<div class="sect3">
<h4 id="transaction-strategies-hibernate"><a class="anchor" href="#transaction-strategies-hibernate"></a>1.2.1. Hibernate Transaction Setup</h4>
<div class="paragraph">
<p>You can also easily use Hibernate local transactions, as shown in the following examples.
In this case, you need to define a Hibernate <code>LocalSessionFactoryBean</code>, which your
application code can use to obtain Hibernate <code>Session</code> instances.</p>
</div>
<div class="paragraph">
<p>The <code>DataSource</code> bean definition is similar to the local JDBC example shown previously
and, thus, is not shown in the following example.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If the <code>DataSource</code> (used by any non-JTA transaction manager) is looked up through
JNDI and managed by a Java EE container, it should be non-transactional, because the
Spring Framework (rather than the Java EE container) manages the transactions.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>txManager</code> bean in this case is of the <code>HibernateTransactionManager</code> type. In the
same way as the <code>DataSourceTransactionManager</code> needs a reference to the <code>DataSource</code>, the
<code>HibernateTransactionManager</code> needs a reference to the <code>SessionFactory</code>. The following
example declares <code>sessionFactory</code> and <code>txManager</code> beans:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean"&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
    &lt;property name="mappingResources"&gt;
        &lt;list&gt;
            &lt;value&gt;org/springframework/samples/petclinic/hibernate/petclinic.hbm.xml&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="hibernateProperties"&gt;
        &lt;value&gt;
            hibernate.dialect=${hibernate.dialect}
        &lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="txManager" class="org.springframework.orm.hibernate5.HibernateTransactionManager"&gt;
    &lt;property name="sessionFactory" ref="sessionFactory"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you use Hibernate and Java EE container-managed JTA transactions, you should use the
same <code>JtaTransactionManager</code> as in the previous JTA example for JDBC, as the following
example shows. Also, it is recommended to make Hibernate aware of JTA through its
transaction coordinator and possibly also its connection release mode configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean"&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
    &lt;property name="mappingResources"&gt;
        &lt;list&gt;
            &lt;value&gt;org/springframework/samples/petclinic/hibernate/petclinic.hbm.xml&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="hibernateProperties"&gt;
        &lt;value&gt;
            hibernate.dialect=${hibernate.dialect}
            hibernate.transaction.coordinator_class=jta
            hibernate.connection.handling_mode=DELAYED_ACQUISITION_AND_RELEASE_AFTER_STATEMENT
        &lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="txManager" class="org.springframework.transaction.jta.JtaTransactionManager"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or alternatively, you may pass the <code>JtaTransactionManager</code> into your <code>LocalSessionFactoryBean</code>
for enforcing the same defaults:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean"&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
    &lt;property name="mappingResources"&gt;
        &lt;list&gt;
            &lt;value&gt;org/springframework/samples/petclinic/hibernate/petclinic.hbm.xml&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="hibernateProperties"&gt;
        &lt;value&gt;
            hibernate.dialect=${hibernate.dialect}
        &lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="jtaTransactionManager" ref="txManager"/&gt;
&lt;/bean&gt;

&lt;bean id="txManager" class="org.springframework.transaction.jta.JtaTransactionManager"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="tx-resource-synchronization"><a class="anchor" href="#tx-resource-synchronization"></a>1.3. Synchronizing Resources with Transactions</h3>
<div class="paragraph">
<p>How to create different transaction managers and how they are linked to related resources
that need to be synchronized to transactions (for example <code>DataSourceTransactionManager</code>
to a JDBC <code>DataSource</code>, <code>HibernateTransactionManager</code> to a Hibernate <code>SessionFactory</code>,
and so forth) should now be clear. This section describes how the application code
(directly or indirectly, by using a persistence API such as JDBC, Hibernate, or JPA)
ensures that these resources are created, reused, and cleaned up properly. The section
also discusses how transaction synchronization is (optionally) triggered through the
relevant <code>TransactionManager</code>.</p>
</div>
<div class="sect3">
<h4 id="tx-resource-synchronization-high"><a class="anchor" href="#tx-resource-synchronization-high"></a>1.3.1. High-level Synchronization Approach</h4>
<div class="paragraph">
<p>The preferred approach is to use Spring&#8217;s highest-level template based persistence
integration APIs or to use native ORM APIs with transaction-aware factory beans or
proxies for managing the native resource factories. These transaction-aware solutions
internally handle resource creation and reuse, cleanup, optional transaction
synchronization of the resources, and exception mapping. Thus, user data access code does
not have to address these tasks but can focus purely on non-boilerplate
persistence logic. Generally, you use the native ORM API or take a template approach
for JDBC access by using the <code>JdbcTemplate</code>. These solutions are detailed in subsequent
sections of this reference documentation.</p>
</div>
</div>
<div class="sect3">
<h4 id="tx-resource-synchronization-low"><a class="anchor" href="#tx-resource-synchronization-low"></a>1.3.2. Low-level Synchronization Approach</h4>
<div class="paragraph">
<p>Classes such as <code>DataSourceUtils</code> (for JDBC), <code>EntityManagerFactoryUtils</code> (for JPA),
<code>SessionFactoryUtils</code> (for Hibernate), and so on exist at a lower level. When you want the
application code to deal directly with the resource types of the native persistence APIs,
you use these classes to ensure that proper Spring Framework-managed instances are obtained,
transactions are (optionally) synchronized, and exceptions that occur in the process are
properly mapped to a consistent API.</p>
</div>
<div class="paragraph">
<p>For example, in the case of JDBC, instead of the traditional JDBC approach of calling
the <code>getConnection()</code> method on the <code>DataSource</code>, you can instead use Spring&#8217;s
<code>org.springframework.jdbc.datasource.DataSourceUtils</code> class, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Connection conn = DataSourceUtils.getConnection(dataSource);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If an existing transaction already has a connection synchronized (linked) to it, that
instance is returned. Otherwise, the method call triggers the creation of a new
connection, which is (optionally) synchronized to any existing transaction and made
available for subsequent reuse in that same transaction. As mentioned earlier, any
<code>SQLException</code> is wrapped in a Spring Framework <code>CannotGetJdbcConnectionException</code>, one
of the Spring Framework&#8217;s hierarchy of unchecked <code>DataAccessException</code> types. This approach
gives you more information than can be obtained easily from the <code>SQLException</code> and
ensures portability across databases and even across different persistence technologies.</p>
</div>
<div class="paragraph">
<p>This approach also works without Spring transaction management (transaction
synchronization is optional), so you can use it whether or not you use Spring for
transaction management.</p>
</div>
<div class="paragraph">
<p>Of course, once you have used Spring&#8217;s JDBC support, JPA support, or Hibernate support,
you generally prefer not to use <code>DataSourceUtils</code> or the other helper classes,
because you are much happier working through the Spring abstraction than directly
with the relevant APIs. For example, if you use the Spring <code>JdbcTemplate</code> or
<code>jdbc.object</code> package to simplify your use of JDBC, correct connection retrieval occurs
behind the scenes and you need not write any special code.</p>
</div>
</div>
<div class="sect3">
<h4 id="tx-resource-synchronization-tadsp"><a class="anchor" href="#tx-resource-synchronization-tadsp"></a>1.3.3. <code>TransactionAwareDataSourceProxy</code></h4>
<div class="paragraph">
<p>At the very lowest level exists the <code>TransactionAwareDataSourceProxy</code> class. This is a
proxy for a target <code>DataSource</code>, which wraps the target <code>DataSource</code> to add awareness of
Spring-managed transactions. In this respect, it is similar to a transactional JNDI
<code>DataSource</code>, as provided by a Java EE server.</p>
</div>
<div class="paragraph">
<p>You should almost never need or want to use this class, except when existing
code must be called and passed a standard JDBC <code>DataSource</code> interface implementation. In
that case, it is possible that this code is usable but is participating in Spring-managed
transactions. You can write your new code by using the higher-level
abstractions mentioned earlier.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="transaction-declarative"><a class="anchor" href="#transaction-declarative"></a>1.4. Declarative Transaction Management</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Most Spring Framework users choose declarative transaction management. This option has
the least impact on application code and, hence, is most consistent with the ideals of a
non-invasive lightweight container.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The Spring Framework&#8217;s declarative transaction management is made possible with Spring
aspect-oriented programming (AOP). However, as the transactional aspects code comes
with the Spring Framework distribution and may be used in a boilerplate fashion, AOP
concepts do not generally have to be understood to make effective use of this code.</p>
</div>
<div class="paragraph">
<p>The Spring Framework&#8217;s declarative transaction management is similar to EJB CMT, in that
you can specify transaction behavior (or lack of it) down to the individual method level.
You can make a <code>setRollbackOnly()</code> call within a transaction context, if
necessary. The differences between the two types of transaction management are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Unlike EJB CMT, which is tied to JTA, the Spring Framework&#8217;s declarative transaction
management works in any environment. It can work with JTA transactions or local
transactions by using JDBC, JPA, or Hibernate by adjusting the configuration
files.</p>
</li>
<li>
<p>You can apply the Spring Framework declarative transaction management to any class,
not merely special classes such as EJBs.</p>
</li>
<li>
<p>The Spring Framework offers declarative
<a href="#transaction-declarative-rolling-back">rollback rules</a>, a feature with no EJB
equivalent. Both programmatic and declarative support for rollback rules is provided.</p>
</li>
<li>
<p>The Spring Framework lets you customize transactional behavior by using AOP.
For example, you can insert custom behavior in the case of transaction rollback. You
can also add arbitrary advice, along with transactional advice. With EJB CMT, you
cannot influence the container&#8217;s transaction management, except with
<code>setRollbackOnly()</code>.</p>
</li>
<li>
<p>The Spring Framework does not support propagation of transaction contexts across
remote calls, as high-end application servers do. If you need this feature, we
recommend that you use EJB. However, consider carefully before using such a feature,
because, normally, one does not want transactions to span remote calls.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The concept of rollback rules is important. They let you specify which exceptions
(and throwables) should cause automatic rollback. You can specify this declaratively, in
configuration, not in Java code. So, although you can still call <code>setRollbackOnly()</code> on
the <code>TransactionStatus</code> object to roll back the current transaction back, most often you
can specify a rule that <code>MyApplicationException</code> must always result in rollback. The
significant advantage to this option is that business objects do not depend on the
transaction infrastructure. For example, they typically do not need to import Spring
transaction APIs or other Spring APIs.</p>
</div>
<div class="paragraph">
<p>Although EJB container default behavior automatically rolls back the transaction on a
system exception (usually a runtime exception), EJB CMT does not roll back the
transaction automatically on an application exception (that is, a checked exception
other than <code>java.rmi.RemoteException</code>). While the Spring default behavior for
declarative transaction management follows EJB convention (roll back is automatic only
on unchecked exceptions), it is often useful to customize this behavior.</p>
</div>
<div class="sect3">
<h4 id="tx-decl-explained"><a class="anchor" href="#tx-decl-explained"></a>1.4.1. Understanding the Spring Framework&#8217;s Declarative Transaction Implementation</h4>
<div class="paragraph">
<p>It is not sufficient merely to tell you to annotate your classes with the
<code>@Transactional</code> annotation, add <code>@EnableTransactionManagement</code> to your configuration,
and expect you to understand how it all works. To provide a deeper understanding, this
section explains the inner workings of the Spring Framework&#8217;s declarative transaction
infrastructure in the context of transaction-related issues.</p>
</div>
<div class="paragraph">
<p>The most important concepts to grasp with regard to the Spring Framework&#8217;s declarative
transaction support are that this support is enabled
<a href="core.html#aop-understanding-aop-proxies">via AOP proxies</a> and that the transactional
advice is driven by metadata (currently XML- or annotation-based). The combination of AOP
with transactional metadata yields an AOP proxy that uses a <code>TransactionInterceptor</code> in
conjunction with an appropriate <code>TransactionManager</code> implementation to drive transactions
around method invocations.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring AOP is covered in <a href="core.html#aop">the AOP section</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Framework&#8217;s <code>TransactionInterceptor</code> provides transaction management for
imperative and reactive programming models. The interceptor detects the desired flavor of
transaction management by inspecting the method return type. Methods returning a reactive
type such as <code>Publisher</code> or Kotlin <code>Flow</code> (or a subtype of those) qualify for reactive
transaction management. All other return types including <code>void</code> use the code path for
imperative transaction management.</p>
</div>
<div class="paragraph">
<p>Transaction management flavors impact which transaction manager is required. Imperative
transactions require a <code>PlatformTransactionManager</code>, while reactive transactions use
<code>ReactiveTransactionManager</code> implementations.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>@Transactional</code> commonly works with thread-bound transactions managed by
<code>PlatformTransactionManager</code>, exposing a transaction to all data access operations within
the current execution thread. Note: This does <em>not</em> propagate to newly started threads
within the method.</p>
</div>
<div class="paragraph">
<p>A reactive transaction managed by <code>ReactiveTransactionManager</code> uses the Reactor context
instead of thread-local attributes. As a consequence, all participating data access
operations need to execute within the same Reactor context in the same reactive pipeline.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following image shows a conceptual view of calling a method on a transactional proxy:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/tx.png" alt="tx">
</div>
</div>
</div>
<div class="sect3">
<h4 id="transaction-declarative-first-example"><a class="anchor" href="#transaction-declarative-first-example"></a>1.4.2. Example of Declarative Transaction Implementation</h4>
<div class="paragraph">
<p>Consider the following interface and its attendant implementation. This example uses
<code>Foo</code> and <code>Bar</code> classes as placeholders so that you can concentrate on the transaction
usage without focusing on a particular domain model. For the purposes of this example,
the fact that the <code>DefaultFooService</code> class throws <code>UnsupportedOperationException</code>
instances in the body of each implemented method is good. That behavior lets you see
transactions being created and then rolled back in response to the
<code>UnsupportedOperationException</code> instance. The following listing shows the <code>FooService</code>
interface:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// the service interface that we want to make transactional

package x.y.service;

public interface FooService {

    Foo getFoo(String fooName);

    Foo getFoo(String fooName, String barName);

    void insertFoo(Foo foo);

    void updateFoo(Foo foo);

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// the service interface that we want to make transactional

package x.y.service

interface FooService {

    fun getFoo(fooName: String): Foo

    fun getFoo(fooName: String, barName: String): Foo

    fun insertFoo(foo: Foo)

    fun updateFoo(foo: Foo)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows an implementation of the preceding interface:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package x.y.service;

public class DefaultFooService implements FooService {

    @Override
    public Foo getFoo(String fooName) {
        // ...
    }

    @Override
    public Foo getFoo(String fooName, String barName) {
        // ...
    }

    @Override
    public void insertFoo(Foo foo) {
        // ...
    }

    @Override
    public void updateFoo(Foo foo) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">package x.y.service

class DefaultFooService : FooService {

    override fun getFoo(fooName: String): Foo {
        // ...
    }

    override fun getFoo(fooName: String, barName: String): Foo {
        // ...
    }

    override fun insertFoo(foo: Foo) {
        // ...
    }

    override fun updateFoo(foo: Foo) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Assume that the first two methods of the <code>FooService</code> interface, <code>getFoo(String)</code> and
<code>getFoo(String, String)</code>, must run in the context of a transaction with read-only
semantics and that the other methods, <code>insertFoo(Foo)</code> and <code>updateFoo(Foo)</code>, must
run in the context of a transaction with read-write semantics. The following
configuration is explained in detail in the next few paragraphs:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;!-- from the file 'context.xml' --&gt;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        https://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd"&gt;

    &lt;!-- this is the service object that we want to make transactional --&gt;
    &lt;bean id="fooService" class="x.y.service.DefaultFooService"/&gt;

    &lt;!-- the transactional advice (what 'happens'; see the &lt;aop:advisor/&gt; bean below) --&gt;
    &lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt;
        &lt;!-- the transactional semantics... --&gt;
        &lt;tx:attributes&gt;
            &lt;!-- all methods starting with 'get' are read-only --&gt;
            &lt;tx:method name="get*" read-only="true"/&gt;
            &lt;!-- other methods use the default transaction settings (see below) --&gt;
            &lt;tx:method name="*"/&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;

    &lt;!-- ensure that the above transactional advice runs for any execution
        of an operation defined by the FooService interface --&gt;
    &lt;aop:config&gt;
        &lt;aop:pointcut id="fooServiceOperation" expression="execution(* x.y.service.FooService.*(..))"/&gt;
        &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="fooServiceOperation"/&gt;
    &lt;/aop:config&gt;

    &lt;!-- don't forget the DataSource --&gt;
    &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
        &lt;property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/&gt;
        &lt;property name="url" value="jdbc:oracle:thin:@rj-t42:1521:elvis"/&gt;
        &lt;property name="username" value="scott"/&gt;
        &lt;property name="password" value="tiger"/&gt;
    &lt;/bean&gt;

    &lt;!-- similarly, don't forget the TransactionManager --&gt;
    &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
        &lt;property name="dataSource" ref="dataSource"/&gt;
    &lt;/bean&gt;

    &lt;!-- other &lt;bean/&gt; definitions here --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Examine the preceding configuration. It assumes that you want to make a service object,
the <code>fooService</code> bean, transactional. The transaction semantics to apply are encapsulated
in the <code>&lt;tx:advice/&gt;</code> definition. The <code>&lt;tx:advice/&gt;</code> definition reads as "all methods
starting with <code>get</code> are to run in the context of a read-only transaction, and all
other methods are to run with the default transaction semantics". The
<code>transaction-manager</code> attribute of the <code>&lt;tx:advice/&gt;</code> tag is set to the name of the
<code>TransactionManager</code> bean that is going to drive the transactions (in this case, the
<code>txManager</code> bean).</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can omit the <code>transaction-manager</code> attribute in the transactional advice
(<code>&lt;tx:advice/&gt;</code>) if the bean name of the <code>TransactionManager</code> that you want to
wire in has the name <code>transactionManager</code>. If the <code>TransactionManager</code> bean that
you want to wire in has any other name, you must use the <code>transaction-manager</code>
attribute explicitly, as in the preceding example.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>&lt;aop:config/&gt;</code> definition ensures that the transactional advice defined by the
<code>txAdvice</code> bean runs at the appropriate points in the program. First, you define a
pointcut that matches the execution of any operation defined in the <code>FooService</code> interface
(<code>fooServiceOperation</code>). Then you associate the pointcut with the <code>txAdvice</code> by using an
advisor. The result indicates that, at the execution of a <code>fooServiceOperation</code>,
the advice defined by <code>txAdvice</code> is run.</p>
</div>
<div class="paragraph">
<p>The expression defined within the <code>&lt;aop:pointcut/&gt;</code> element is an AspectJ pointcut
expression. See <a href="core.html#aop">the AOP section</a> for more details on pointcut
expressions in Spring.</p>
</div>
<div class="paragraph">
<p>A common requirement is to make an entire service layer transactional. The best way to
do this is to change the pointcut expression to match any operation in your
service layer. The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;aop:config&gt;
    &lt;aop:pointcut id="fooServiceMethods" expression="execution(* x.y.service.*.*(..))"/&gt;
    &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="fooServiceMethods"/&gt;
&lt;/aop:config&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In the preceding example, it is assumed that all your service interfaces are defined
in the <code>x.y.service</code> package. See <a href="core.html#aop">the AOP section</a> for more details.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now that we have analyzed the configuration, you may be asking yourself,
"What does all this configuration actually do?"</p>
</div>
<div class="paragraph">
<p>The configuration shown earlier is used to create a transactional proxy around the object
that is created from the <code>fooService</code> bean definition. The proxy is configured with
the transactional advice so that, when an appropriate method is invoked on the proxy,
a transaction is started, suspended, marked as read-only, and so on, depending on the
transaction configuration associated with that method. Consider the following program
that test drives the configuration shown earlier:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public final class Boot {

    public static void main(final String[] args) throws Exception {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("context.xml");
        FooService fooService = ctx.getBean(FooService.class);
        fooService.insertFoo(new Foo());
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.springframework.beans.factory.getBean

fun main() {
    val ctx = ClassPathXmlApplicationContext("context.xml")
    val fooService = ctx.getBean&lt;FooService&gt;("fooService")
    fooService.insertFoo(Foo())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output from running the preceding program should resemble the following (the Log4J
output and the stack trace from the <code>UnsupportedOperationException</code> thrown by the
<code>insertFoo(..)</code> method of the <code>DefaultFooService</code> class have been truncated for clarity):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;!-- the Spring container is starting up... --&gt;
[AspectJInvocationContextExposingAdvisorAutoProxyCreator] - Creating implicit proxy for bean 'fooService' with 0 common interceptors and 1 specific interceptors

&lt;!-- the DefaultFooService is actually proxied --&gt;
[JdkDynamicAopProxy] - Creating JDK dynamic proxy for [x.y.service.DefaultFooService]

&lt;!-- ... the insertFoo(..) method is now being invoked on the proxy --&gt;
[TransactionInterceptor] - Getting transaction for x.y.service.FooService.insertFoo

&lt;!-- the transactional advice kicks in here... --&gt;
[DataSourceTransactionManager] - Creating new transaction with name [x.y.service.FooService.insertFoo]
[DataSourceTransactionManager] - Acquired Connection [org.apache.commons.dbcp.PoolableConnection@a53de4] for JDBC transaction

&lt;!-- the insertFoo(..) method from DefaultFooService throws an exception... --&gt;
[RuleBasedTransactionAttribute] - Applying rules to determine whether transaction should rollback on java.lang.UnsupportedOperationException
[TransactionInterceptor] - Invoking rollback for transaction on x.y.service.FooService.insertFoo due to throwable [java.lang.UnsupportedOperationException]

&lt;!-- and the transaction is rolled back (by default, RuntimeException instances cause rollback) --&gt;
[DataSourceTransactionManager] - Rolling back JDBC transaction on Connection [org.apache.commons.dbcp.PoolableConnection@a53de4]
[DataSourceTransactionManager] - Releasing JDBC Connection after transaction
[DataSourceUtils] - Returning JDBC Connection to DataSource

Exception in thread "main" java.lang.UnsupportedOperationException at x.y.service.DefaultFooService.insertFoo(DefaultFooService.java:14)
&lt;!-- AOP infrastructure stack trace elements removed for clarity --&gt;
at $Proxy0.insertFoo(Unknown Source)
at Boot.main(Boot.java:11)</code></pre>
</div>
</div>
<div class="paragraph">
<p>To use reactive transaction management the code has to use reactive types.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Framework uses the <code>ReactiveAdapterRegistry</code> to determine whether a method
return type is reactive.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following listing shows a modified version of the previously used <code>FooService</code>, but
this time the code uses reactive types:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// the reactive service interface that we want to make transactional

package x.y.service;

public interface FooService {

    Flux&lt;Foo&gt; getFoo(String fooName);

    Publisher&lt;Foo&gt; getFoo(String fooName, String barName);

    Mono&lt;Void&gt; insertFoo(Foo foo);

    Mono&lt;Void&gt; updateFoo(Foo foo);

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// the reactive service interface that we want to make transactional

package x.y.service

interface FooService {

    fun getFoo(fooName: String): Flow&lt;Foo&gt;

    fun getFoo(fooName: String, barName: String): Publisher&lt;Foo&gt;

    fun insertFoo(foo: Foo) : Mono&lt;Void&gt;

    fun updateFoo(foo: Foo) : Mono&lt;Void&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows an implementation of the preceding interface:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package x.y.service;

public class DefaultFooService implements FooService {

    @Override
    public Flux&lt;Foo&gt; getFoo(String fooName) {
        // ...
    }

    @Override
    public Publisher&lt;Foo&gt; getFoo(String fooName, String barName) {
        // ...
    }

    @Override
    public Mono&lt;Void&gt; insertFoo(Foo foo) {
        // ...
    }

    @Override
    public Mono&lt;Void&gt; updateFoo(Foo foo) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">package x.y.service

class DefaultFooService : FooService {

    override fun getFoo(fooName: String): Flow&lt;Foo&gt; {
        // ...
    }

    override fun getFoo(fooName: String, barName: String): Publisher&lt;Foo&gt; {
        // ...
    }

    override fun insertFoo(foo: Foo): Mono&lt;Void&gt; {
        // ...
    }

    override fun updateFoo(foo: Foo): Mono&lt;Void&gt; {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Imperative and reactive transaction management share the same semantics for transaction
boundary and transaction attribute definitions. The main difference between imperative
and reactive transactions is the deferred nature of the latter. <code>TransactionInterceptor</code>
decorates the returned reactive type with a transactional operator to begin and clean up
the transaction. Therefore, calling a transactional reactive method defers the actual
transaction management to a subscription type that activates processing of the reactive
type.</p>
</div>
<div class="paragraph">
<p>Another aspect of reactive transaction management relates to data escaping which is a
natural consequence of the programming model.</p>
</div>
<div class="paragraph">
<p>Method return values of imperative transactions are returned from transactional methods
upon successful termination of a method so that partially computed results do not escape
the method closure.</p>
</div>
<div class="paragraph">
<p>Reactive transaction methods return a reactive wrapper type which represents a
computation sequence along with a promise to begin and complete the computation.</p>
</div>
<div class="paragraph">
<p>A <code>Publisher</code> can emit data while a transaction is ongoing but not necessarily completed.
Therefore, methods that depend upon successful completion of an entire transaction need
to ensure completion and buffer results in the calling code.</p>
</div>
</div>
<div class="sect3">
<h4 id="transaction-declarative-rolling-back"><a class="anchor" href="#transaction-declarative-rolling-back"></a>1.4.3. Rolling Back a Declarative Transaction</h4>
<div class="paragraph">
<p>The previous section outlined the basics of how to specify transactional settings for
classes, typically service layer classes, declaratively in your application. This
section describes how you can control the rollback of transactions in a simple,
declarative fashion.</p>
</div>
<div class="paragraph">
<p>The recommended way to indicate to the Spring Framework&#8217;s transaction infrastructure
that a transaction&#8217;s work is to be rolled back is to throw an <code>Exception</code> from code that
is currently executing in the context of a transaction. The Spring Framework&#8217;s
transaction infrastructure code catches any unhandled <code>Exception</code> as it bubbles up
the call stack and makes a determination whether to mark the transaction for rollback.</p>
</div>
<div class="paragraph">
<p>In its default configuration, the Spring Framework&#8217;s transaction infrastructure code
marks a transaction for rollback only in the case of runtime, unchecked exceptions.
That is, when the thrown exception is an instance or subclass of <code>RuntimeException</code>. (
<code>Error</code> instances also, by default, result in a rollback). Checked exceptions that are
thrown from a transactional method do not result in rollback in the default
configuration.</p>
</div>
<div class="paragraph">
<p>You can configure exactly which <code>Exception</code> types mark a transaction for rollback,
including checked exceptions. The following XML snippet demonstrates how you configure
rollback for a checked, application-specific <code>Exception</code> type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt;
    &lt;tx:attributes&gt;
    &lt;tx:method name="get*" read-only="true" rollback-for="NoProductInStockException"/&gt;
    &lt;tx:method name="*"/&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you do not want a transaction rolled
back when an exception is thrown, you can also specify 'no rollback rules'. The following example tells the Spring Framework&#8217;s
transaction infrastructure to commit the attendant transaction even in the face of an
unhandled <code>InstrumentNotFoundException</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;tx:advice id="txAdvice"&gt;
    &lt;tx:attributes&gt;
    &lt;tx:method name="updateStock" no-rollback-for="InstrumentNotFoundException"/&gt;
    &lt;tx:method name="*"/&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the Spring Framework&#8217;s transaction infrastructure catches an exception and it
consults the configured rollback rules to determine whether to mark the transaction for
rollback, the strongest matching rule wins. So, in the case of the following
configuration, any exception other than an <code>InstrumentNotFoundException</code> results in a
rollback of the attendant transaction:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;tx:advice id="txAdvice"&gt;
    &lt;tx:attributes&gt;
    &lt;tx:method name="*" rollback-for="Throwable" no-rollback-for="InstrumentNotFoundException"/&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also indicate a required rollback programmatically. Although simple,
this process is quite invasive and tightly couples your code to the Spring Framework&#8217;s
transaction infrastructure. The following example shows how to programmatically indicate
a required rollback:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public void resolvePosition() {
    try {
        // some business logic...
    } catch (NoProductInStockException ex) {
        // trigger rollback programmatically
        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">fun resolvePosition() {
    try {
        // some business logic...
    } catch (ex: NoProductInStockException) {
        // trigger rollback programmatically
        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You are strongly encouraged to use the declarative approach to rollback, if at all
possible. Programmatic rollback is available should you absolutely need it, but its
usage flies in the face of achieving a clean POJO-based architecture.</p>
</div>
</div>
<div class="sect3">
<h4 id="transaction-declarative-diff-tx"><a class="anchor" href="#transaction-declarative-diff-tx"></a>1.4.4. Configuring Different Transactional Semantics for Different Beans</h4>
<div class="paragraph">
<p>Consider the scenario where you have a number of service layer objects, and you want to
apply a totally different transactional configuration to each of them. You can do so
by defining distinct <code>&lt;aop:advisor/&gt;</code> elements with differing <code>pointcut</code> and
<code>advice-ref</code> attribute values.</p>
</div>
<div class="paragraph">
<p>As a point of comparison, first assume that all of your service layer classes are
defined in a root <code>x.y.service</code> package. To make all beans that are instances of classes
defined in that package (or in subpackages) and that have names ending in <code>Service</code> have
the default transactional configuration, you could write the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        https://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd"&gt;

    &lt;aop:config&gt;

        &lt;aop:pointcut id="serviceOperation"
                expression="execution(* x.y.service..*Service.*(..))"/&gt;

        &lt;aop:advisor pointcut-ref="serviceOperation" advice-ref="txAdvice"/&gt;

    &lt;/aop:config&gt;

    &lt;!-- these two beans will be transactional... --&gt;
    &lt;bean id="fooService" class="x.y.service.DefaultFooService"/&gt;
    &lt;bean id="barService" class="x.y.service.extras.SimpleBarService"/&gt;

    &lt;!-- ... and these two beans won't --&gt;
    &lt;bean id="anotherService" class="org.xyz.SomeService"/&gt; &lt;!-- (not in the right package) --&gt;
    &lt;bean id="barManager" class="x.y.service.SimpleBarManager"/&gt; &lt;!-- (doesn't end in 'Service') --&gt;

    &lt;tx:advice id="txAdvice"&gt;
        &lt;tx:attributes&gt;
            &lt;tx:method name="get*" read-only="true"/&gt;
            &lt;tx:method name="*"/&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;

    &lt;!-- other transaction infrastructure beans such as a TransactionManager omitted... --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to configure two distinct beans with totally different
transactional settings:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        https://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd"&gt;

    &lt;aop:config&gt;

        &lt;aop:pointcut id="defaultServiceOperation"
                expression="execution(* x.y.service.*Service.*(..))"/&gt;

        &lt;aop:pointcut id="noTxServiceOperation"
                expression="execution(* x.y.service.ddl.DefaultDdlManager.*(..))"/&gt;

        &lt;aop:advisor pointcut-ref="defaultServiceOperation" advice-ref="defaultTxAdvice"/&gt;

        &lt;aop:advisor pointcut-ref="noTxServiceOperation" advice-ref="noTxAdvice"/&gt;

    &lt;/aop:config&gt;

    &lt;!-- this bean will be transactional (see the 'defaultServiceOperation' pointcut) --&gt;
    &lt;bean id="fooService" class="x.y.service.DefaultFooService"/&gt;

    &lt;!-- this bean will also be transactional, but with totally different transactional settings --&gt;
    &lt;bean id="anotherFooService" class="x.y.service.ddl.DefaultDdlManager"/&gt;

    &lt;tx:advice id="defaultTxAdvice"&gt;
        &lt;tx:attributes&gt;
            &lt;tx:method name="get*" read-only="true"/&gt;
            &lt;tx:method name="*"/&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;

    &lt;tx:advice id="noTxAdvice"&gt;
        &lt;tx:attributes&gt;
            &lt;tx:method name="*" propagation="NEVER"/&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;

    &lt;!-- other transaction infrastructure beans such as a TransactionManager omitted... --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="transaction-declarative-txadvice-settings"><a class="anchor" href="#transaction-declarative-txadvice-settings"></a>1.4.5. &lt;tx:advice/&gt; Settings</h4>
<div class="paragraph">
<p>This section summarizes the various transactional settings that you can specify by using
the <code>&lt;tx:advice/&gt;</code> tag. The default <code>&lt;tx:advice/&gt;</code> settings are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <a href="#tx-propagation">propagation setting</a> is <code>REQUIRED.</code></p>
</li>
<li>
<p>The isolation level is <code>DEFAULT.</code></p>
</li>
<li>
<p>The transaction is read-write.</p>
</li>
<li>
<p>The transaction timeout defaults to the default timeout of the underlying transaction
system or none if timeouts are not supported.</p>
</li>
<li>
<p>Any <code>RuntimeException</code> triggers rollback, and any checked <code>Exception</code> does not.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can change these default settings. The following table summarizes the various attributes of the <code>&lt;tx:method/&gt;</code> tags
that are nested within <code>&lt;tx:advice/&gt;</code> and <code>&lt;tx:attributes/&gt;</code> tags:</p>
</div>
<table id="tx-method-settings" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. &lt;tx:method/&gt; settings</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute</th>
<th class="tableblock halign-left valign-top">Required?</th>
<th class="tableblock halign-left valign-top">Default</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Method names with which the transaction attributes are to be associated. The
  wildcard (*) character can be used to associate the same transaction attribute
  settings with a number of methods (for example, <code>get*</code>, <code>handle*</code>, <code>on*Event</code>, and so
  forth).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>propagation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>REQUIRED</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Transaction propagation behavior.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>isolation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DEFAULT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Transaction isolation level. Only applicable to propagation settings of <code>REQUIRED</code> or <code>REQUIRES_NEW</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>timeout</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Transaction timeout (seconds). Only applicable to propagation <code>REQUIRED</code> or <code>REQUIRES_NEW</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>read-only</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Read-write versus read-only transaction. Applies only to <code>REQUIRED</code> or <code>REQUIRES_NEW</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>rollback-for</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Comma-delimited list of <code>Exception</code> instances that trigger rollback. For example,
  <code>com.foo.MyBusinessException,ServletException</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>no-rollback-for</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Comma-delimited list of <code>Exception</code> instances that do not trigger rollback. For example,
  <code>com.foo.MyBusinessException,ServletException</code>.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="transaction-declarative-annotations"><a class="anchor" href="#transaction-declarative-annotations"></a>1.4.6. Using <code>@Transactional</code></h4>
<div class="paragraph">
<p>In addition to the XML-based declarative approach to transaction configuration, you can
use an annotation-based approach. Declaring transaction semantics directly in the Java
source code puts the declarations much closer to the affected code. There is not much
danger of undue coupling, because code that is meant to be used transactionally is
almost always deployed that way anyway.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The standard <code>javax.transaction.Transactional</code> annotation is also supported as a
drop-in replacement to Spring&#8217;s own annotation. Please refer to JTA 1.2 documentation
for more details.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The ease-of-use afforded by the use of the <code>@Transactional</code> annotation is best
illustrated with an example, which is explained in the text that follows.
Consider the following class definition:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// the service class that we want to make transactional
@Transactional
public class DefaultFooService implements FooService {

    @Override
    public Foo getFoo(String fooName) {
        // ...
    }

    @Override
    public Foo getFoo(String fooName, String barName) {
        // ...
    }

    @Override
    public void insertFoo(Foo foo) {
        // ...
    }

    @Override
    public void updateFoo(Foo foo) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// the service class that we want to make transactional
@Transactional
class DefaultFooService : FooService {

    override fun getFoo(fooName: String): Foo {
        // ...
    }

    override fun getFoo(fooName: String, barName: String): Foo {
        // ...
    }

    override fun insertFoo(foo: Foo) {
        // ...
    }

    override fun updateFoo(foo: Foo) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Used at the class level as above, the annotation indicates a default for all methods of
the declaring class (as well as its subclasses). Alternatively, each method can be
annotated individually. See <a href="#transaction-declarative-annotations-method-visibility">Method visibility and <code>@Transactional</code></a> for
further details on which methods Spring considers transactional. Note that a class-level
annotation does not apply to ancestor classes up the class hierarchy; in such a scenario,
inherited methods need to be locally redeclared in order to participate in a
subclass-level annotation.</p>
</div>
<div class="paragraph">
<p>When a POJO class such as the one above is defined as a bean in a Spring context,
you can make the bean instance transactional through an <code>@EnableTransactionManagement</code>
annotation in a <code>@Configuration</code> class. See the
<a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/transaction/annotation/EnableTransactionManagement.html">javadoc</a>
for full details.</p>
</div>
<div class="paragraph">
<p>In XML configuration, the <code>&lt;tx:annotation-driven/&gt;</code> tag provides similar convenience:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;!-- from the file 'context.xml' --&gt;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        https://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd"&gt;

    &lt;!-- this is the service object that we want to make transactional --&gt;
    &lt;bean id="fooService" class="x.y.service.DefaultFooService"/&gt;

    &lt;!-- enable the configuration of transactional behavior based on annotations --&gt;
    &lt;!-- a TransactionManager is still required --&gt;
    &lt;tx:annotation-driven transaction-manager="txManager"/&gt; <i class="conum" data-value="1"></i><b>(1)</b>

    &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
        &lt;!-- (this dependency is defined somewhere else) --&gt;
        &lt;property name="dataSource" ref="dataSource"/&gt;
    &lt;/bean&gt;

    &lt;!-- other &lt;bean/&gt; definitions here --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The line that makes the bean instance transactional.</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can omit the <code>transaction-manager</code> attribute in the <code>&lt;tx:annotation-driven/&gt;</code>
tag if the bean name of the <code>TransactionManager</code> that you want to wire in has the name
<code>transactionManager</code>. If the <code>TransactionManager</code> bean that you want to dependency-inject
has any other name, you have to use the <code>transaction-manager</code> attribute, as in the
preceding example.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Reactive transactional methods use reactive return types in contrast to imperative
programming arrangements as the following listing shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// the reactive service class that we want to make transactional
@Transactional
public class DefaultFooService implements FooService {

    @Override
    public Publisher&lt;Foo&gt; getFoo(String fooName) {
        // ...
    }

    @Override
    public Mono&lt;Foo&gt; getFoo(String fooName, String barName) {
        // ...
    }

    @Override
    public Mono&lt;Void&gt; insertFoo(Foo foo) {
        // ...
    }

    @Override
    public Mono&lt;Void&gt; updateFoo(Foo foo) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// the reactive service class that we want to make transactional
@Transactional
class DefaultFooService : FooService {

    override fun getFoo(fooName: String): Flow&lt;Foo&gt; {
        // ...
    }

    override fun getFoo(fooName: String, barName: String): Mono&lt;Foo&gt; {
        // ...
    }

    override fun insertFoo(foo: Foo): Mono&lt;Void&gt; {
        // ...
    }

    override fun updateFoo(foo: Foo): Mono&lt;Void&gt; {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that there are special considerations for the returned <code>Publisher</code> with regards to
Reactive Streams cancellation signals. See the <a href="#tx-prog-operator-cancel">Cancel Signals</a> section under
"Using the TransactionOperator" for more details.</p>
</div>
<div id="transaction-declarative-annotations-method-visibility" class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Method visibility and <code>@Transactional</code></div>
<div class="paragraph">
<p>When you use transactional proxies with Spring&#8217;s standard configuration, you should apply
the <code>@Transactional</code> annotation only to methods with <code>public</code> visibility. If you do
annotate <code>protected</code>, <code>private</code>, or package-visible methods with the <code>@Transactional</code>
annotation, no error is raised, but the annotated method does not exhibit the configured
transactional settings. If you need to annotate non-public methods, consider the tip in
the following paragraph for class-based proxies or consider using AspectJ compile-time or
load-time weaving (described later).</p>
</div>
<div class="paragraph">
<p>When using <code>@EnableTransactionManagement</code> in a <code>@Configuration</code> class, <code>protected</code> or
package-visible methods can also be made transactional for class-based proxies by
registering a custom <code>transactionAttributeSource</code> bean like in the following example.
Note, however, that transactional methods in interface-based proxies must always be
<code>public</code> and defined in the proxied interface.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">/**
 * Register a custom AnnotationTransactionAttributeSource with the
 * publicMethodsOnly flag set to false to enable support for
 * protected and package-private @Transactional methods in
 * class-based proxies.
 *
 * @see ProxyTransactionManagementConfiguration#transactionAttributeSource()
 */
@Bean
TransactionAttributeSource transactionAttributeSource() {
    return new AnnotationTransactionAttributeSource(false);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>Spring TestContext Framework</em> supports non-private <code>@Transactional</code> test methods by
default. See <a href="testing.html#testcontext-tx">Transaction Management</a> in the testing
chapter for examples.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can apply the <code>@Transactional</code> annotation to an interface definition, a method
on an interface, a class definition, or a method on a class. However, the
mere presence of the <code>@Transactional</code> annotation is not enough to activate the
transactional behavior. The <code>@Transactional</code> annotation is merely metadata that can
be consumed by some runtime infrastructure that is <code>@Transactional</code>-aware and that
can use the metadata to configure the appropriate beans with transactional behavior.
In the preceding example, the <code>&lt;tx:annotation-driven/&gt;</code> element switches on the
transactional behavior.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The Spring team recommends that you annotate only concrete classes (and methods of
concrete classes) with the <code>@Transactional</code> annotation, as opposed to annotating interfaces.
You certainly can place the <code>@Transactional</code> annotation on an interface (or an interface
method), but this works only as you would expect it to if you use interface-based
proxies. The fact that Java annotations are not inherited from interfaces means that,
if you use class-based proxies (<code>proxy-target-class="true"</code>) or the weaving-based
aspect (<code>mode="aspectj"</code>), the transaction settings are not recognized by the proxying
and weaving infrastructure, and the object is not wrapped in a transactional proxy.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In proxy mode (which is the default), only external method calls coming in through
the proxy are intercepted. This means that self-invocation (in effect, a method within
the target object calling another method of the target object) does not lead to an actual
transaction at runtime even if the invoked method is marked with <code>@Transactional</code>. Also,
the proxy must be fully initialized to provide the expected behavior, so you should not
rely on this feature in your initialization code&#8201;&#8212;&#8201;for example, in a <code>@PostConstruct</code>
method.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Consider using AspectJ mode (see the <code>mode</code> attribute in the following table) if you
expect self-invocations to be wrapped with transactions as well. In this case, there is
no proxy in the first place. Instead, the target class is woven (that is, its byte code
is modified) to support <code>@Transactional</code> runtime behavior on any kind of method.</p>
</div>
<table id="tx-annotation-driven-settings" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. Annotation driven transaction settings</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">XML Attribute</th>
<th class="tableblock halign-left valign-top">Annotation Attribute</th>
<th class="tableblock halign-left valign-top">Default</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>transaction-manager</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N/A (see <a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/transaction/annotation/TransactionManagementConfigurer.html"><code>TransactionManagementConfigurer</code></a> javadoc)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>transactionManager</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Name of the transaction manager to use. Required only if the name of the transaction
  manager is not <code>transactionManager</code>, as in the preceding example.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mode</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mode</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>proxy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The default mode (<code>proxy</code>) processes annotated beans to be proxied by using Spring&#8217;s AOP
  framework (following proxy semantics, as discussed earlier, applying to method calls
  coming in through the proxy only). The alternative mode (<code>aspectj</code>) instead weaves the
  affected classes with Spring&#8217;s AspectJ transaction aspect, modifying the target class
  byte code to apply to any kind of method call. AspectJ weaving requires
  <code>spring-aspects.jar</code> in the classpath as well as having load-time weaving (or compile-time
  weaving) enabled. (See <a href="core.html#aop-aj-ltw-spring">Spring configuration</a>
  for details on how to set up load-time weaving.)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>proxy-target-class</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>proxyTargetClass</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Applies to <code>proxy</code> mode only. Controls what type of transactional proxies are created
  for classes annotated with the <code>@Transactional</code> annotation. If the
  <code>proxy-target-class</code> attribute is set to <code>true</code>, class-based proxies are created.
  If <code>proxy-target-class</code> is <code>false</code> or if the attribute is omitted, then standard JDK
  interface-based proxies are created. (See <a href="core.html#aop-proxying">Proxying Mechanisms</a>
  for a detailed examination of the different proxy types.)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>order</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>order</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Ordered.LOWEST_PRECEDENCE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Defines the order of the transaction advice that is applied to beans annotated with
  <code>@Transactional</code>. (For more information about the rules related to ordering of AOP
  advice, see <a href="core.html#aop-ataspectj-advice-ordering">Advice Ordering</a>.)
  No specified ordering means that the AOP subsystem determines the order of the advice.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The default advice mode for processing <code>@Transactional</code> annotations is <code>proxy</code>,
which allows for interception of calls through the proxy only. Local calls within the
same class cannot get intercepted that way. For a more advanced mode of interception,
consider switching to <code>aspectj</code> mode in combination with compile-time or load-time weaving.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>proxy-target-class</code> attribute controls what type of transactional proxies are
created for classes annotated with the <code>@Transactional</code> annotation. If
<code>proxy-target-class</code> is set to <code>true</code>, class-based proxies are created. If
<code>proxy-target-class</code> is <code>false</code> or if the attribute is omitted, standard JDK
interface-based proxies are created. (See <a href="core.html#aop-proxying">Proxying Mechanisms</a>
for a discussion of the different proxy types.)
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>@EnableTransactionManagement</code> and <code>&lt;tx:annotation-driven/&gt;</code> look for
<code>@Transactional</code> only on beans in the same application context in which they are defined.
This means that, if you put annotation-driven configuration in a <code>WebApplicationContext</code>
for a <code>DispatcherServlet</code>, it checks for <code>@Transactional</code> beans only in your controllers
and not in your services. See <a href="web.html#mvc-servlet">MVC</a> for more information.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The most derived location takes precedence when evaluating the transactional settings
for a method. In the case of the following example, the <code>DefaultFooService</code> class is
annotated at the class level with the settings for a read-only transaction, but the
<code>@Transactional</code> annotation on the <code>updateFoo(Foo)</code> method in the same class takes
precedence over the transactional settings defined at the class level.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Transactional(readOnly = true)
public class DefaultFooService implements FooService {

    public Foo getFoo(String fooName) {
        // ...
    }

    // these settings have precedence for this method
    @Transactional(readOnly = false, propagation = Propagation.REQUIRES_NEW)
    public void updateFoo(Foo foo) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Transactional(readOnly = true)
class DefaultFooService : FooService {

    override fun getFoo(fooName: String): Foo {
        // ...
    }

    // these settings have precedence for this method
    @Transactional(readOnly = false, propagation = Propagation.REQUIRES_NEW)
    override fun updateFoo(foo: Foo) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="transaction-declarative-attransactional-settings"><a class="anchor" href="#transaction-declarative-attransactional-settings"></a><code>@Transactional</code> Settings</h5>
<div class="paragraph">
<p>The <code>@Transactional</code> annotation is metadata that specifies that an interface, class,
or method must have transactional semantics (for example, "start a brand new read-only
transaction when this method is invoked, suspending any existing transaction").
The default <code>@Transactional</code> settings are as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The propagation setting is <code>PROPAGATION_REQUIRED.</code></p>
</li>
<li>
<p>The isolation level is <code>ISOLATION_DEFAULT.</code></p>
</li>
<li>
<p>The transaction is read-write.</p>
</li>
<li>
<p>The transaction timeout defaults to the default timeout of the underlying transaction
system, or to none if timeouts are not supported.</p>
</li>
<li>
<p>Any <code>RuntimeException</code> triggers rollback, and any checked <code>Exception</code> does not.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can change these default settings. The following table summarizes the various
properties of the <code>@Transactional</code> annotation:</p>
</div>
<table id="tx-attransactional-properties" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 3. @Transactional Settings</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Property</th>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#tx-multiple-tx-mgrs-with-attransactional">value</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional qualifier that specifies the transaction manager to be used.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#tx-propagation">propagation</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>enum</code>: <code>Propagation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional propagation setting.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>isolation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>enum</code>: <code>Isolation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional isolation level. Applies only to propagation values of <code>REQUIRED</code> or <code>REQUIRES_NEW</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>timeout</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int</code> (in seconds of granularity)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional transaction timeout. Applies only to propagation values of <code>REQUIRED</code> or <code>REQUIRES_NEW</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>readOnly</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Read-write versus read-only transaction. Only applicable to values of <code>REQUIRED</code> or <code>REQUIRES_NEW</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>rollbackFor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Array of <code>Class</code> objects, which must be derived from <code>Throwable.</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional array of exception classes that must cause rollback.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>rollbackForClassName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Array of class names. The classes must be derived from <code>Throwable.</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional array of names of exception classes that must cause rollback.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>noRollbackFor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Array of <code>Class</code> objects, which must be derived from <code>Throwable.</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional array of exception classes that must not cause rollback.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>noRollbackForClassName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Array of <code>String</code> class names, which must be derived from <code>Throwable.</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional array of names of exception classes that must not cause rollback.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>label</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Array of <code>String</code> labels to add an expressive description to the transaction.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Labels may be evaluated by transaction managers to associate
implementation-specific behavior with the actual transaction.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Currently, you cannot have explicit control over the name of a transaction, where 'name'
means the transaction name that appears in a transaction monitor, if applicable
(for example, WebLogic&#8217;s transaction monitor), and in logging output. For declarative
transactions, the transaction name is always the fully-qualified class name + <code>.</code>
+ the method name of the transactionally advised class. For example, if the
<code>handlePayment(..)</code> method of the <code>BusinessService</code> class started a transaction, the
name of the transaction would be: <code>com.example.BusinessService.handlePayment</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="tx-multiple-tx-mgrs-with-attransactional"><a class="anchor" href="#tx-multiple-tx-mgrs-with-attransactional"></a>Multiple Transaction Managers with <code>@Transactional</code></h5>
<div class="paragraph">
<p>Most Spring applications need only a single transaction manager, but there may be
situations where you want multiple independent transaction managers in a single
application. You can use the <code>value</code> or <code>transactionManager</code> attribute of the
<code>@Transactional</code> annotation to optionally specify the identity of the
<code>TransactionManager</code> to be used. This can either be the bean name or the qualifier value
of the transaction manager bean. For example, using the qualifier notation, you can
combine the following Java code with the following transaction manager bean declarations
in the application context:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class TransactionalService {

    @Transactional("order")
    public void setSomething(String name) { ... }

    @Transactional("account")
    public void doSomething() { ... }

    @Transactional("reactive-account")
    public Mono&lt;Void&gt; doSomethingReactive() { ... }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class TransactionalService {

    @Transactional("order")
    fun setSomething(name: String) {
        // ...
    }

    @Transactional("account")
    fun doSomething() {
        // ...
    }

    @Transactional("reactive-account")
    fun doSomethingReactive(): Mono&lt;Void&gt; {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following listing shows the bean declarations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;tx:annotation-driven/&gt;

    &lt;bean id="transactionManager1" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
        ...
        &lt;qualifier value="order"/&gt;
    &lt;/bean&gt;

    &lt;bean id="transactionManager2" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
        ...
        &lt;qualifier value="account"/&gt;
    &lt;/bean&gt;

    &lt;bean id="transactionManager3" class="org.springframework.data.r2dbc.connectionfactory.R2dbcTransactionManager"&gt;
        ...
        &lt;qualifier value="reactive-account"/&gt;
    &lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, the individual methods on <code>TransactionalService</code> run under separate
transaction managers, differentiated by the <code>order</code>, <code>account</code>, and <code>reactive-account</code>
qualifiers. The default <code>&lt;tx:annotation-driven&gt;</code> target bean name, <code>transactionManager</code>,
is still used if no specifically qualified <code>TransactionManager</code> bean is found.</p>
</div>
</div>
<div class="sect4">
<h5 id="tx-custom-attributes"><a class="anchor" href="#tx-custom-attributes"></a>Custom Composed Annotations</h5>
<div class="paragraph">
<p>If you find you repeatedly use the same attributes with <code>@Transactional</code> on many different
methods, <a href="core.html#beans-meta-annotations">Spring&#8217;s meta-annotation support</a> lets you
define custom composed annotations for your specific use cases. For example, consider the
following annotation definitions:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Transactional(transactionManager = "order", label = "causal-consistency")
public @interface OrderTx {
}

@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Transactional(transactionManager = "account", label = "retryable")
public @interface AccountTx {
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Target(AnnotationTarget.FUNCTION, AnnotationTarget.TYPE)
@Retention(AnnotationRetention.RUNTIME)
@Transactional(transactionManager = "order", label = ["causal-consistency"])
annotation class OrderTx

@Target(AnnotationTarget.FUNCTION, AnnotationTarget.TYPE)
@Retention(AnnotationRetention.RUNTIME)
@Transactional(transactionManager = "account", label = ["retryable"])
annotation class AccountTx</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding annotations let us write the example from the previous section as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class TransactionalService {

    @OrderTx
    public void setSomething(String name) {
        // ...
    }

    @AccountTx
    public void doSomething() {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class TransactionalService {

    @OrderTx
    fun setSomething(name: String) {
        // ...
    }

    @AccountTx
    fun doSomething() {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, we used the syntax to define the transaction manager qualifier
and transactional labels, but we could also have included propagation behavior,
rollback rules, timeouts, and other features.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tx-propagation"><a class="anchor" href="#tx-propagation"></a>1.4.7. Transaction Propagation</h4>
<div class="paragraph">
<p>This section describes some semantics of transaction propagation in Spring. Note
that this section is not an introduction to transaction propagation proper. Rather, it
details some of the semantics regarding transaction propagation in Spring.</p>
</div>
<div class="paragraph">
<p>In Spring-managed transactions, be aware of the difference between physical and
logical transactions, and how the propagation setting applies to this difference.</p>
</div>
<div class="sect4">
<h5 id="tx-propagation-required"><a class="anchor" href="#tx-propagation-required"></a>Understanding <code>PROPAGATION_REQUIRED</code></h5>
<div class="imageblock">
<div class="content">
<img src="images/tx_prop_required.png" alt="tx prop required">
</div>
</div>
<div class="paragraph">
<p><code>PROPAGATION_REQUIRED</code> enforces a physical transaction, either locally for the current
scope if no transaction exists yet or participating in an existing 'outer' transaction
defined for a larger scope. This is a fine default in common call stack arrangements
within the same thread (for example, a service facade that delegates to several repository methods
where all the underlying resources have to participate in the service-level transaction).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
By default, a participating transaction joins the characteristics of the outer scope,
silently ignoring the local isolation level, timeout value, or read-only flag (if any).
Consider switching the <code>validateExistingTransactions</code> flag to <code>true</code> on your transaction
manager if you want isolation level declarations to be rejected when participating in
an existing transaction with a different isolation level. This non-lenient mode also
rejects read-only mismatches (that is, an inner read-write transaction that tries to participate
in a read-only outer scope).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When the propagation setting is <code>PROPAGATION_REQUIRED</code>, a logical transaction scope
is created for each method upon which the setting is applied. Each such logical
transaction scope can determine rollback-only status individually, with an outer
transaction scope being logically independent from the inner transaction scope.
In the case of standard <code>PROPAGATION_REQUIRED</code> behavior, all these scopes are
mapped to the same physical transaction. So a rollback-only marker set in the inner
transaction scope does affect the outer transaction&#8217;s chance to actually commit.</p>
</div>
<div class="paragraph">
<p>However, in the case where an inner transaction scope sets the rollback-only marker, the
outer transaction has not decided on the rollback itself, so the rollback (silently
triggered by the inner transaction scope) is unexpected. A corresponding
<code>UnexpectedRollbackException</code> is thrown at that point. This is expected behavior so
that the caller of a transaction can never be misled to assume that a commit was
performed when it really was not. So, if an inner transaction (of which the outer caller
is not aware) silently marks a transaction as rollback-only, the outer caller still
calls commit. The outer caller needs to receive an <code>UnexpectedRollbackException</code> to
indicate clearly that a rollback was performed instead.</p>
</div>
</div>
<div class="sect4">
<h5 id="tx-propagation-requires_new"><a class="anchor" href="#tx-propagation-requires_new"></a>Understanding <code>PROPAGATION_REQUIRES_NEW</code></h5>
<div class="imageblock">
<div class="content">
<img src="images/tx_prop_requires_new.png" alt="tx prop requires new">
</div>
</div>
<div class="paragraph">
<p><code>PROPAGATION_REQUIRES_NEW</code>, in contrast to <code>PROPAGATION_REQUIRED</code>, always uses an
independent physical transaction for each affected transaction scope, never
participating in an existing transaction for an outer scope. In such an arrangement,
the underlying resource transactions are different and, hence, can commit or roll back
independently, with an outer transaction not affected by an inner transaction&#8217;s rollback
status and with an inner transaction&#8217;s locks released immediately after its completion.
Such an independent inner transaction can also declare its own isolation level, timeout,
and read-only settings and not inherit an outer transaction&#8217;s characteristics.</p>
</div>
</div>
<div class="sect4">
<h5 id="tx-propagation-nested"><a class="anchor" href="#tx-propagation-nested"></a>Understanding <code>PROPAGATION_NESTED</code></h5>
<div class="paragraph">
<p><code>PROPAGATION_NESTED</code> uses a single physical transaction with multiple savepoints
that it can roll back to. Such partial rollbacks let an inner transaction scope
trigger a rollback for its scope, with the outer transaction being able to continue
the physical transaction despite some operations having been rolled back. This setting
is typically mapped onto JDBC savepoints, so it works only with JDBC resource
transactions. See Spring&#8217;s <a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/jdbc/datasource/DataSourceTransactionManager.html"><code>DataSourceTransactionManager</code></a>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="transaction-declarative-applying-more-than-just-tx-advice"><a class="anchor" href="#transaction-declarative-applying-more-than-just-tx-advice"></a>1.4.8. Advising Transactional Operations</h4>
<div class="paragraph">
<p>Suppose you want to run both transactional operations and some basic profiling advice.
How do you effect this in the context of <code>&lt;tx:annotation-driven/&gt;</code>?</p>
</div>
<div class="paragraph">
<p>When you invoke the <code>updateFoo(Foo)</code> method, you want to see the following actions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The configured profiling aspect starts.</p>
</li>
<li>
<p>The transactional advice runs.</p>
</li>
<li>
<p>The method on the advised object runs.</p>
</li>
<li>
<p>The transaction commits.</p>
</li>
<li>
<p>The profiling aspect reports the exact duration of the whole transactional method invocation.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This chapter is not concerned with explaining AOP in any great detail (except as it
applies to transactions). See <a href="core.html#aop">AOP</a> for detailed coverage of the AOP
configuration and AOP in general.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following code shows the simple profiling aspect discussed earlier:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package x.y;

import org.aspectj.lang.ProceedingJoinPoint;
import org.springframework.util.StopWatch;
import org.springframework.core.Ordered;

public class SimpleProfiler implements Ordered {

    private int order;

    // allows us to control the ordering of advice
    public int getOrder() {
        return this.order;
    }

    public void setOrder(int order) {
        this.order = order;
    }

    // this method is the around advice
    public Object profile(ProceedingJoinPoint call) throws Throwable {
        Object returnValue;
        StopWatch clock = new StopWatch(getClass().getName());
        try {
            clock.start(call.toShortString());
            returnValue = call.proceed();
        } finally {
            clock.stop();
            System.out.println(clock.prettyPrint());
        }
        return returnValue;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class SimpleProfiler : Ordered {

    private var order: Int = 0

    // allows us to control the ordering of advice
    override fun getOrder(): Int {
        return this.order
    }

    fun setOrder(order: Int) {
        this.order = order
    }

    // this method is the around advice
    fun profile(call: ProceedingJoinPoint): Any {
        var returnValue: Any
        val clock = StopWatch(javaClass.name)
        try {
            clock.start(call.toShortString())
            returnValue = call.proceed()
        } finally {
            clock.stop()
            println(clock.prettyPrint())
        }
        return returnValue
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The ordering of advice
is controlled through the <code>Ordered</code> interface. For full details on advice ordering, see
<a href="core.html#aop-ataspectj-advice-ordering">Advice ordering</a>.</p>
</div>
<div class="paragraph">
<p>The following configuration creates a <code>fooService</code> bean that has profiling and
transactional aspects applied to it in the desired order:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        https://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd"&gt;

    &lt;bean id="fooService" class="x.y.service.DefaultFooService"/&gt;

    &lt;!-- this is the aspect --&gt;
    &lt;bean id="profiler" class="x.y.SimpleProfiler"&gt;
        &lt;!-- run before the transactional advice (hence the lower order number) --&gt;
        &lt;property name="order" value="1"/&gt;
    &lt;/bean&gt;

    &lt;tx:annotation-driven transaction-manager="txManager" order="200"/&gt;

    &lt;aop:config&gt;
            &lt;!-- this advice runs around the transactional advice --&gt;
            &lt;aop:aspect id="profilingAspect" ref="profiler"&gt;
                &lt;aop:pointcut id="serviceMethodWithReturnValue"
                        expression="execution(!void x.y..*Service.*(..))"/&gt;
                &lt;aop:around method="profile" pointcut-ref="serviceMethodWithReturnValue"/&gt;
            &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;

    &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
        &lt;property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/&gt;
        &lt;property name="url" value="jdbc:oracle:thin:@rj-t42:1521:elvis"/&gt;
        &lt;property name="username" value="scott"/&gt;
        &lt;property name="password" value="tiger"/&gt;
    &lt;/bean&gt;

    &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
        &lt;property name="dataSource" ref="dataSource"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can configure any number
of additional aspects in similar fashion.</p>
</div>
<div class="paragraph">
<p>The following example creates the same setup as the previous two examples but uses the purely XML
declarative approach:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        https://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd"&gt;

    &lt;bean id="fooService" class="x.y.service.DefaultFooService"/&gt;

    &lt;!-- the profiling advice --&gt;
    &lt;bean id="profiler" class="x.y.SimpleProfiler"&gt;
        &lt;!-- run before the transactional advice (hence the lower order number) --&gt;
        &lt;property name="order" value="1"/&gt;
    &lt;/bean&gt;

    &lt;aop:config&gt;
        &lt;aop:pointcut id="entryPointMethod" expression="execution(* x.y..*Service.*(..))"/&gt;
        &lt;!-- runs after the profiling advice (c.f. the order attribute) --&gt;

        &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="entryPointMethod" order="2"/&gt;
        &lt;!-- order value is higher than the profiling aspect --&gt;

        &lt;aop:aspect id="profilingAspect" ref="profiler"&gt;
            &lt;aop:pointcut id="serviceMethodWithReturnValue"
                    expression="execution(!void x.y..*Service.*(..))"/&gt;
            &lt;aop:around method="profile" pointcut-ref="serviceMethodWithReturnValue"/&gt;
        &lt;/aop:aspect&gt;

    &lt;/aop:config&gt;

    &lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt;
        &lt;tx:attributes&gt;
            &lt;tx:method name="get*" read-only="true"/&gt;
            &lt;tx:method name="*"/&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;

    &lt;!-- other &lt;bean/&gt; definitions such as a DataSource and a TransactionManager here --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The result of the preceding configuration is a <code>fooService</code> bean that has profiling and
transactional aspects applied to it in that order. If you want the profiling advice
to run after the transactional advice on the way in and before the
transactional advice on the way out, you can swap the value of the profiling
aspect bean&#8217;s <code>order</code> property so that it is higher than the transactional advice&#8217;s
order value.</p>
</div>
<div class="paragraph">
<p>You can configure additional aspects in similar fashion.</p>
</div>
</div>
<div class="sect3">
<h4 id="transaction-declarative-aspectj"><a class="anchor" href="#transaction-declarative-aspectj"></a>1.4.9. Using <code>@Transactional</code> with AspectJ</h4>
<div class="paragraph">
<p>You can also use the Spring Framework&#8217;s <code>@Transactional</code> support outside of a Spring
container by means of an AspectJ aspect. To do so, first annotate your classes
(and optionally your classes' methods) with the <code>@Transactional</code> annotation,
and then link (weave) your application with the
<code>org.springframework.transaction.aspectj.AnnotationTransactionAspect</code> defined in the
<code>spring-aspects.jar</code> file. You must also configure The aspect with a transaction
manager. You can use the Spring Framework&#8217;s IoC container to take care of
dependency-injecting the aspect. The simplest way to configure the transaction
management aspect is to use the <code>&lt;tx:annotation-driven/&gt;</code> element and specify the <code>mode</code>
attribute to <code>aspectj</code> as described in <a href="#transaction-declarative-annotations">Using <code>@Transactional</code></a>. Because
we focus here on applications that run outside of a Spring container, we show
you how to do it programmatically.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Prior to continuing, you may want to read <a href="#transaction-declarative-annotations">Using <code>@Transactional</code></a> and
<a href="core.html#aop">AOP</a> respectively.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows how to create a transaction manager and configure the
<code>AnnotationTransactionAspect</code> to use it:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// construct an appropriate transaction manager
DataSourceTransactionManager txManager = new DataSourceTransactionManager(getDataSource());

// configure the AnnotationTransactionAspect to use it; this must be done before executing any transactional methods
AnnotationTransactionAspect.aspectOf().setTransactionManager(txManager);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// construct an appropriate transaction manager
val txManager = DataSourceTransactionManager(getDataSource())

// configure the AnnotationTransactionAspect to use it; this must be done before executing any transactional methods
AnnotationTransactionAspect.aspectOf().transactionManager = txManager</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When you use this aspect, you must annotate the implementation class (or the methods
within that class or both), not the interface (if any) that the class implements. AspectJ
follows Java&#8217;s rule that annotations on interfaces are not inherited.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>@Transactional</code> annotation on a class specifies the default transaction semantics
for the execution of any public method in the class.</p>
</div>
<div class="paragraph">
<p>The <code>@Transactional</code> annotation on a method within the class overrides the default
transaction semantics given by the class annotation (if present). You can annotate any method,
regardless of visibility.</p>
</div>
<div class="paragraph">
<p>To weave your applications with the <code>AnnotationTransactionAspect</code>, you must either build
your application with AspectJ (see the
<a href="https://www.eclipse.org/aspectj/doc/released/devguide/index.html">AspectJ Development
Guide</a>) or use load-time weaving. See <a href="core.html#aop-aj-ltw">Load-time weaving with
AspectJ in the Spring Framework</a> for a discussion of load-time weaving with AspectJ.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="transaction-programmatic"><a class="anchor" href="#transaction-programmatic"></a>1.5. Programmatic Transaction Management</h3>
<div class="paragraph">
<p>The Spring Framework provides two means of programmatic transaction management, by using:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>TransactionTemplate</code> or <code>TransactionalOperator</code>.</p>
</li>
<li>
<p>A <code>TransactionManager</code> implementation directly.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Spring team generally recommends the <code>TransactionTemplate</code> for programmatic
transaction management in imperative flows and <code>TransactionalOperator</code> for reactive code.
The second approach is similar to using the JTA <code>UserTransaction</code> API, although exception
handling is less cumbersome.</p>
</div>
<div class="sect3">
<h4 id="tx-prog-template"><a class="anchor" href="#tx-prog-template"></a>1.5.1. Using the <code>TransactionTemplate</code></h4>
<div class="paragraph">
<p>The <code>TransactionTemplate</code> adopts the same approach as other Spring templates, such as
the <code>JdbcTemplate</code>. It uses a callback approach (to free application code from having to
do the boilerplate acquisition and release transactional resources) and results in
code that is intention driven, in that your code focuses solely on what
you want to do.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As the examples that follow show, using the <code>TransactionTemplate</code> absolutely
couples you to Spring&#8217;s transaction infrastructure and APIs. Whether or not programmatic
transaction management is suitable for your development needs is a decision that you
have to make yourself.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Application code that must run in a transactional context and that explicitly uses the
<code>TransactionTemplate</code> resembles the next example. You, as an application
developer, can write a <code>TransactionCallback</code> implementation (typically expressed as an
anonymous inner class) that contains the code that you need to run in the context of
a transaction. You can then pass an instance of your custom <code>TransactionCallback</code> to the
<code>execute(..)</code> method exposed on the <code>TransactionTemplate</code>. The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class SimpleService implements Service {

    // single TransactionTemplate shared amongst all methods in this instance
    private final TransactionTemplate transactionTemplate;

    // use constructor-injection to supply the PlatformTransactionManager
    public SimpleService(PlatformTransactionManager transactionManager) {
        this.transactionTemplate = new TransactionTemplate(transactionManager);
    }

    public Object someServiceMethod() {
        return transactionTemplate.execute(new TransactionCallback() {
            // the code in this method runs in a transactional context
            public Object doInTransaction(TransactionStatus status) {
                updateOperation1();
                return resultOfUpdateOperation2();
            }
        });
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// use constructor-injection to supply the PlatformTransactionManager
class SimpleService(transactionManager: PlatformTransactionManager) : Service {

    // single TransactionTemplate shared amongst all methods in this instance
    private val transactionTemplate = TransactionTemplate(transactionManager)

    fun someServiceMethod() = transactionTemplate.execute&lt;Any?&gt; {
        updateOperation1()
        resultOfUpdateOperation2()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If there is no return value, you can use the convenient <code>TransactionCallbackWithoutResult</code> class
with an anonymous class, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">transactionTemplate.execute(new TransactionCallbackWithoutResult() {
    protected void doInTransactionWithoutResult(TransactionStatus status) {
        updateOperation1();
        updateOperation2();
    }
});</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">transactionTemplate.execute(object : TransactionCallbackWithoutResult() {
    override fun doInTransactionWithoutResult(status: TransactionStatus) {
        updateOperation1()
        updateOperation2()
    }
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Code within the callback can roll the transaction back by calling the
<code>setRollbackOnly()</code> method on the supplied <code>TransactionStatus</code> object, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">transactionTemplate.execute(new TransactionCallbackWithoutResult() {

    protected void doInTransactionWithoutResult(TransactionStatus status) {
        try {
            updateOperation1();
            updateOperation2();
        } catch (SomeBusinessException ex) {
            status.setRollbackOnly();
        }
    }
});</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">transactionTemplate.execute(object : TransactionCallbackWithoutResult() {

    override fun doInTransactionWithoutResult(status: TransactionStatus) {
        try {
            updateOperation1()
            updateOperation2()
        } catch (ex: SomeBusinessException) {
            status.setRollbackOnly()
        }
    }
})</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="tx-prog-template-settings"><a class="anchor" href="#tx-prog-template-settings"></a>Specifying Transaction Settings</h5>
<div class="paragraph">
<p>You can specify transaction settings (such as the propagation mode, the isolation level,
the timeout, and so forth) on the <code>TransactionTemplate</code> either programmatically or in
configuration. By default, <code>TransactionTemplate</code> instances have the
<a href="#transaction-declarative-txadvice-settings">default transactional settings</a>. The
following example shows the programmatic customization of the transactional settings for
a specific <code>TransactionTemplate:</code></p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class SimpleService implements Service {

    private final TransactionTemplate transactionTemplate;

    public SimpleService(PlatformTransactionManager transactionManager) {
        this.transactionTemplate = new TransactionTemplate(transactionManager);

        // the transaction settings can be set here explicitly if so desired
        this.transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_UNCOMMITTED);
        this.transactionTemplate.setTimeout(30); // 30 seconds
        // and so forth...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class SimpleService(transactionManager: PlatformTransactionManager) : Service {

    private val transactionTemplate = TransactionTemplate(transactionManager).apply {
        // the transaction settings can be set here explicitly if so desired
        isolationLevel = TransactionDefinition.ISOLATION_READ_UNCOMMITTED
        timeout = 30 // 30 seconds
        // and so forth...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example defines a <code>TransactionTemplate</code> with some custom transactional
settings by using Spring XML configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="sharedTransactionTemplate"
        class="org.springframework.transaction.support.TransactionTemplate"&gt;
    &lt;property name="isolationLevelName" value="ISOLATION_READ_UNCOMMITTED"/&gt;
    &lt;property name="timeout" value="30"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can then inject the <code>sharedTransactionTemplate</code>
into as many services as are required.</p>
</div>
<div class="paragraph">
<p>Finally, instances of the <code>TransactionTemplate</code> class are thread-safe, in that instances
do not maintain any conversational state. <code>TransactionTemplate</code> instances do, however,
maintain configuration state. So, while a number of classes may share a single instance
of a <code>TransactionTemplate</code>, if a class needs to use a <code>TransactionTemplate</code> with
different settings (for example, a different isolation level), you need to create
two distinct <code>TransactionTemplate</code> instances.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tx-prog-operator"><a class="anchor" href="#tx-prog-operator"></a>1.5.2. Using the <code>TransactionOperator</code></h4>
<div class="paragraph">
<p>The <code>TransactionOperator</code> follows an operator design that is similar to other reactive
operators. It uses a callback approach (to free application code from having to do the
boilerplate acquisition and release transactional resources) and results in code that is
intention driven, in that your code focuses solely on what you want to do.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As the examples that follow show, using the <code>TransactionOperator</code> absolutely
couples you to Spring&#8217;s transaction infrastructure and APIs. Whether or not programmatic
transaction management is suitable for your development needs is a decision that you have
to make yourself.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Application code that must run in a transactional context and that explicitly uses
the <code>TransactionOperator</code> resembles the next example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class SimpleService implements Service {

    // single TransactionOperator shared amongst all methods in this instance
    private final TransactionalOperator transactionalOperator;

    // use constructor-injection to supply the ReactiveTransactionManager
    public SimpleService(ReactiveTransactionManager transactionManager) {
        this.transactionOperator = TransactionalOperator.create(transactionManager);
    }

    public Mono&lt;Object&gt; someServiceMethod() {

        // the code in this method runs in a transactional context

        Mono&lt;Object&gt; update = updateOperation1();

        return update.then(resultOfUpdateOperation2).as(transactionalOperator::transactional);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// use constructor-injection to supply the ReactiveTransactionManager
class SimpleService(transactionManager: ReactiveTransactionManager) : Service {

    // single TransactionalOperator shared amongst all methods in this instance
    private val transactionalOperator = TransactionalOperator.create(transactionManager)

    suspend fun someServiceMethod() = transactionalOperator.executeAndAwait&lt;Any?&gt; {
        updateOperation1()
        resultOfUpdateOperation2()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>TransactionalOperator</code> can be used in two ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Operator-style using Project Reactor types (<code>mono.as(transactionalOperator::transactional)</code>)</p>
</li>
<li>
<p>Callback-style for every other case (<code>transactionalOperator.execute(TransactionCallback&lt;T&gt;)</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Code within the callback can roll the transaction back by calling the <code>setRollbackOnly()</code>
method on the supplied <code>ReactiveTransaction</code> object, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">transactionalOperator.execute(new TransactionCallback&lt;&gt;() {

    public Mono&lt;Object&gt; doInTransaction(ReactiveTransaction status) {
        return updateOperation1().then(updateOperation2)
                    .doOnError(SomeBusinessException.class, e -&gt; status.setRollbackOnly());
        }
    }
});</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">transactionalOperator.execute(object : TransactionCallback() {

    override fun doInTransactionWithoutResult(status: ReactiveTransaction) {
        updateOperation1().then(updateOperation2)
                    .doOnError(SomeBusinessException.class, e -&gt; status.setRollbackOnly())
    }
})</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="tx-prog-operator-cancel"><a class="anchor" href="#tx-prog-operator-cancel"></a>Cancel Signals</h5>
<div class="paragraph">
<p>In Reactive Streams, a <code>Subscriber</code> can cancel its <code>Subscription</code> and stop its
<code>Publisher</code>. Operators in Project Reactor, as well as in other libraries, such as <code>next()</code>,
<code>take(long)</code>, <code>timeout(Duration)</code>, and others can issue cancellations. There is no way to
know the reason for the cancellation, whether it is due to an error or a simply lack of
interest to consume further. Since version 5.3 cancel signals lead to a roll back.
As a result it is important to consider the operators used downstream from a transaction
<code>Publisher</code>. In particular in the case of a <code>Flux</code> or other multi-value <code>Publisher</code>,
the full output must be consumed to allow the transaction to complete.</p>
</div>
</div>
<div class="sect4">
<h5 id="tx-prog-operator-settings"><a class="anchor" href="#tx-prog-operator-settings"></a>Specifying Transaction Settings</h5>
<div class="paragraph">
<p>You can specify transaction settings (such as the propagation mode, the isolation level,
the timeout, and so forth) for the <code>TransactionalOperator</code>. By default,
<code>TransactionalOperator</code> instances have
<a href="#transaction-declarative-txadvice-settings">default transactional settings</a>. The
following example shows customization of the transactional settings for a specific
<code>TransactionalOperator:</code></p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class SimpleService implements Service {

    private final TransactionalOperator transactionalOperator;

    public SimpleService(ReactiveTransactionManager transactionManager) {
        DefaultTransactionDefinition definition = new DefaultTransactionDefinition();

        // the transaction settings can be set here explicitly if so desired
        definition.setIsolationLevel(TransactionDefinition.ISOLATION_READ_UNCOMMITTED);
        definition.setTimeout(30); // 30 seconds
        // and so forth...

        this.transactionalOperator = TransactionalOperator.create(transactionManager, definition);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class SimpleService(transactionManager: ReactiveTransactionManager) : Service {

    private val definition = DefaultTransactionDefinition().apply {
        // the transaction settings can be set here explicitly if so desired
        isolationLevel = TransactionDefinition.ISOLATION_READ_UNCOMMITTED
        timeout = 30 // 30 seconds
        // and so forth...
    }
    private val transactionalOperator = TransactionalOperator(transactionManager, definition)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="transaction-programmatic-tm"><a class="anchor" href="#transaction-programmatic-tm"></a>1.5.3. Using the <code>TransactionManager</code></h4>
<div class="paragraph">
<p>The following sections explain programmatic usage of imperative and reactive transaction
managers.</p>
</div>
<div class="sect4">
<h5 id="transaction-programmatic-ptm"><a class="anchor" href="#transaction-programmatic-ptm"></a>Using the <code>PlatformTransactionManager</code></h5>
<div class="paragraph">
<p>For imperative transactions, you can use a
<code>org.springframework.transaction.PlatformTransactionManager</code> directly to manage your
transaction. To do so, pass the implementation of the <code>PlatformTransactionManager</code> you
use to your bean through a bean reference. Then, by using the <code>TransactionDefinition</code> and
<code>TransactionStatus</code> objects, you can initiate transactions, roll back, and commit. The
following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">DefaultTransactionDefinition def = new DefaultTransactionDefinition();
// explicitly setting the transaction name is something that can be done only programmatically
def.setName("SomeTxName");
def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

TransactionStatus status = txManager.getTransaction(def);
try {
    // put your business logic here
}
catch (MyException ex) {
    txManager.rollback(status);
    throw ex;
}
txManager.commit(status);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val def = DefaultTransactionDefinition()
// explicitly setting the transaction name is something that can be done only programmatically
def.setName("SomeTxName")
def.propagationBehavior = TransactionDefinition.PROPAGATION_REQUIRED

val status = txManager.getTransaction(def)
try {
    // put your business logic here
} catch (ex: MyException) {
    txManager.rollback(status)
    throw ex
}

txManager.commit(status)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="transaction-programmatic-rtm"><a class="anchor" href="#transaction-programmatic-rtm"></a>Using the <code>ReactiveTransactionManager</code></h5>
<div class="paragraph">
<p>When working with reactive transactions, you can use a
<code>org.springframework.transaction.ReactiveTransactionManager</code> directly to manage your
transaction. To do so, pass the implementation of the <code>ReactiveTransactionManager</code> you
use to your bean through a bean reference. Then, by using the <code>TransactionDefinition</code> and
<code>ReactiveTransaction</code> objects, you can initiate transactions, roll back, and commit. The
following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">DefaultTransactionDefinition def = new DefaultTransactionDefinition();
// explicitly setting the transaction name is something that can be done only programmatically
def.setName("SomeTxName");
def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

Mono&lt;ReactiveTransaction&gt; reactiveTx = txManager.getReactiveTransaction(def);

reactiveTx.flatMap(status -&gt; {

    Mono&lt;Object&gt; tx = ...; // put your business logic here

    return tx.then(txManager.commit(status))
            .onErrorResume(ex -&gt; txManager.rollback(status).then(Mono.error(ex)));
});</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val def = DefaultTransactionDefinition()
// explicitly setting the transaction name is something that can be done only programmatically
def.setName("SomeTxName")
def.propagationBehavior = TransactionDefinition.PROPAGATION_REQUIRED

val reactiveTx = txManager.getReactiveTransaction(def)
reactiveTx.flatMap { status -&gt;

    val tx = ... // put your business logic here

    tx.then(txManager.commit(status))
            .onErrorResume { ex -&gt; txManager.rollback(status).then(Mono.error(ex)) }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="tx-decl-vs-prog"><a class="anchor" href="#tx-decl-vs-prog"></a>1.6. Choosing Between Programmatic and Declarative Transaction Management</h3>
<div class="paragraph">
<p>Programmatic transaction management is usually a good idea only if you have a small
number of transactional operations. For example, if you have a web application that
requires transactions only for certain update operations, you may not want to set up
transactional proxies by using Spring or any other technology. In this case, using the
<code>TransactionTemplate</code> may be a good approach. Being able to set the transaction name
explicitly is also something that can be done only by using the programmatic approach
to transaction management.</p>
</div>
<div class="paragraph">
<p>On the other hand, if your application has numerous transactional operations,
declarative transaction management is usually worthwhile. It keeps transaction
management out of business logic and is not difficult to configure. When using the
Spring Framework, rather than EJB CMT, the configuration cost of declarative transaction
management is greatly reduced.</p>
</div>
</div>
<div class="sect2">
<h3 id="transaction-event"><a class="anchor" href="#transaction-event"></a>1.7. Transaction-bound Events</h3>
<div class="paragraph">
<p>As of Spring 4.2, the listener of an event can be bound to a phase of the transaction.
The typical example is to handle the event when the transaction has completed successfully.
Doing so lets events be used with more flexibility when the outcome of the current
transaction actually matters to the listener.</p>
</div>
<div class="paragraph">
<p>You can register a regular event listener by using the <code>@EventListener</code> annotation.
If you need to bind it to the transaction, use <code>@TransactionalEventListener</code>.
When you do so, the listener is bound to the commit phase of the transaction by default.</p>
</div>
<div class="paragraph">
<p>The next example shows this concept. Assume that a component publishes an order-created
event and that we want to define a listener that should only handle that event once the
transaction in which it has been published has committed successfully. The following
example sets up such an event listener:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Component
public class MyComponent {

    @TransactionalEventListener
    public void handleOrderCreatedEvent(CreationEvent&lt;Order&gt; creationEvent) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Component
class MyComponent {

    @TransactionalEventListener
    fun handleOrderCreatedEvent(creationEvent: CreationEvent&lt;Order&gt;) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@TransactionalEventListener</code> annotation exposes a <code>phase</code> attribute that lets you
customize the phase of the transaction to which the listener should be bound.
The valid phases are <code>BEFORE_COMMIT</code>, <code>AFTER_COMMIT</code> (default), <code>AFTER_ROLLBACK</code>, as well as
<code>AFTER_COMPLETION</code> which aggregates the transaction completion (be it a commit or a rollback).</p>
</div>
<div class="paragraph">
<p>If no transaction is running, the listener is not invoked at all, since we cannot honor the
required semantics. You can, however, override that behavior by setting the <code>fallbackExecution</code>
attribute of the annotation to <code>true</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>@TransactionalEventListener</code> only works with thread-bound transactions managed by
<code>PlatformTransactionManager</code>. A reactive transaction managed by <code>ReactiveTransactionManager</code>
uses the Reactor context instead of thread-local attributes, so from the perspective of
an event listener, there is no compatible active transaction that it can participate in.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="transaction-application-server-integration"><a class="anchor" href="#transaction-application-server-integration"></a>1.8. Application server-specific integration</h3>
<div class="paragraph">
<p>Spring&#8217;s transaction abstraction is generally application server-agnostic. Additionally,
Spring&#8217;s <code>JtaTransactionManager</code> class (which can optionally perform a JNDI lookup for
the JTA <code>UserTransaction</code> and <code>TransactionManager</code> objects) autodetects the location for
the latter object, which varies by application server. Having access to the JTA
<code>TransactionManager</code> allows for enhanced transaction semantics&#8201;&#8212;&#8201;in particular,
supporting transaction suspension. See the
<a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/transaction/jta/JtaTransactionManager.html"><code>JtaTransactionManager</code></a>
javadoc for details.</p>
</div>
<div class="paragraph">
<p>Spring&#8217;s <code>JtaTransactionManager</code> is the standard choice to run on Java EE application
servers and is known to work on all common servers. Advanced functionality, such as
transaction suspension, works on many servers as well (including GlassFish, JBoss and
Geronimo) without any special configuration required. However, for fully supported
transaction suspension and further advanced integration, Spring includes special adapters
for WebLogic Server and WebSphere. These adapters are discussed in the following
sections.</p>
</div>
<div class="paragraph">
<p>For standard scenarios, including WebLogic Server and WebSphere, consider using the
convenient <code>&lt;tx:jta-transaction-manager/&gt;</code> configuration element. When configured,
this element automatically detects the underlying server and chooses the best
transaction manager available for the platform. This means that you need not explicitly
configure server-specific adapter classes (as discussed in the following sections).
Rather, they are chosen automatically, with the standard
<code>JtaTransactionManager</code> as the default fallback.</p>
</div>
<div class="sect3">
<h4 id="transaction-application-server-integration-websphere"><a class="anchor" href="#transaction-application-server-integration-websphere"></a>1.8.1. IBM WebSphere</h4>
<div class="paragraph">
<p>On WebSphere 6.1.0.9 and above, the recommended Spring JTA transaction manager to use is
<code>WebSphereUowTransactionManager</code>. This special adapter uses IBM&#8217;s <code>UOWManager</code> API,
which is available in WebSphere Application Server 6.1.0.9 and later. With this adapter,
Spring-driven transaction suspension (suspend and resume as initiated by
<code>PROPAGATION_REQUIRES_NEW</code>) is officially supported by IBM.</p>
</div>
</div>
<div class="sect3">
<h4 id="transaction-application-server-integration-weblogic"><a class="anchor" href="#transaction-application-server-integration-weblogic"></a>1.8.2. Oracle WebLogic Server</h4>
<div class="paragraph">
<p>On WebLogic Server 9.0 or above, you would typically use the
<code>WebLogicJtaTransactionManager</code> instead of the stock <code>JtaTransactionManager</code> class. This
special WebLogic-specific subclass of the normal <code>JtaTransactionManager</code> supports the
full power of Spring&#8217;s transaction definitions in a WebLogic-managed transaction
environment, beyond standard JTA semantics. Features include transaction names,
per-transaction isolation levels, and proper resuming of transactions in all cases.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="transaction-solutions-to-common-problems"><a class="anchor" href="#transaction-solutions-to-common-problems"></a>1.9. Solutions to Common Problems</h3>
<div class="paragraph">
<p>This section describes solutions to some common problems.</p>
</div>
<div class="sect3">
<h4 id="transaction-solutions-to-common-problems-wrong-ptm"><a class="anchor" href="#transaction-solutions-to-common-problems-wrong-ptm"></a>1.9.1. Using the Wrong Transaction Manager for a Specific <code>DataSource</code></h4>
<div class="paragraph">
<p>Use the correct <code>PlatformTransactionManager</code> implementation based on your choice of
transactional technologies and requirements. Used properly, the Spring Framework merely
provides a straightforward and portable abstraction. If you use global
transactions, you must use the
<code>org.springframework.transaction.jta.JtaTransactionManager</code> class (or an
<a href="#transaction-application-server-integration">application server-specific subclass</a> of
it) for all your transactional operations. Otherwise, the transaction infrastructure
tries to perform local transactions on such resources as container <code>DataSource</code>
instances. Such local transactions do not make sense, and a good application server
treats them as errors.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="transaction-resources"><a class="anchor" href="#transaction-resources"></a>1.10. Further Resources</h3>
<div class="paragraph">
<p>For more information about the Spring Framework&#8217;s transaction support, see:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.javaworld.com/javaworld/jw-01-2009/jw-01-spring-transactions.html">Distributed
transactions in Spring, with and without XA</a> is a JavaWorld presentation in which
Spring&#8217;s David Syer guides you through seven patterns for distributed
transactions in Spring applications, three of them with XA and four without.</p>
</li>
<li>
<p><a href="https://www.infoq.com/minibooks/JTDS"><em>Java Transaction Design Strategies</em></a> is a book
available from <a href="https://www.infoq.com/">InfoQ</a> that provides a well-paced introduction
to transactions in Java. It also includes side-by-side examples of how to configure
and use transactions with both the Spring Framework and EJB3.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="dao"><a class="anchor" href="#dao"></a>2. DAO Support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Data Access Object (DAO) support in Spring is aimed at making it easy to work with
data access technologies (such as JDBC, Hibernate, or JPA) in a consistent way. This
lets you switch between the aforementioned persistence technologies fairly easily,
and it also lets you code without worrying about catching exceptions that are
specific to each technology.</p>
</div>
<div class="sect2">
<h3 id="dao-exceptions"><a class="anchor" href="#dao-exceptions"></a>2.1. Consistent Exception Hierarchy</h3>
<div class="paragraph">
<p>Spring provides a convenient translation from technology-specific exceptions, such as
<code>SQLException</code> to its own exception class hierarchy, which has <code>DataAccessException</code> as
the root exception. These exceptions wrap the original exception so that there is never
any risk that you might lose any information about what might have gone wrong.</p>
</div>
<div class="paragraph">
<p>In addition to JDBC exceptions, Spring can also wrap JPA- and Hibernate-specific exceptions,
converting them to a set of focused runtime exceptions. This lets you handle most
non-recoverable persistence exceptions in only the appropriate layers, without having
annoying boilerplate catch-and-throw blocks and exception declarations in your DAOs.
(You can still trap and handle exceptions anywhere you need to though.) As mentioned above,
JDBC exceptions (including database-specific dialects) are also converted to the same
hierarchy, meaning that you can perform some operations with JDBC within a consistent
programming model.</p>
</div>
<div class="paragraph">
<p>The preceding discussion holds true for the various template classes in Spring&#8217;s support
for various ORM frameworks. If you use the interceptor-based classes, the application must
care about handling <code>HibernateExceptions</code> and <code>PersistenceExceptions</code> itself, preferably by
delegating to the <code>convertHibernateAccessException(..)</code> or <code>convertJpaAccessException(..)</code>
methods, respectively, of <code>SessionFactoryUtils</code>. These methods convert the exceptions
to exceptions that are compatible with the exceptions in the <code>org.springframework.dao</code>
exception hierarchy. As <code>PersistenceExceptions</code> are unchecked, they can get thrown, too
(sacrificing generic DAO abstraction in terms of exceptions, though).</p>
</div>
<div class="paragraph">
<p>The following image shows the exception hierarchy that Spring provides.
(Note that the class hierarchy detailed in the image shows only a subset of the entire
<code>DataAccessException</code> hierarchy.)</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/DataAccessException.png" alt="DataAccessException">
</div>
</div>
</div>
<div class="sect2">
<h3 id="dao-annotations"><a class="anchor" href="#dao-annotations"></a>2.2. Annotations Used to Configure DAO or Repository Classes</h3>
<div class="paragraph">
<p>The best way to guarantee that your Data Access Objects (DAOs) or repositories provide
exception translation is to use the <code>@Repository</code> annotation. This annotation also
lets the component scanning support find and configure your DAOs and repositories
without having to provide XML configuration entries for them. The following example shows
how to use the <code>@Repository</code> annotation:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Repository <i class="conum" data-value="1"></i><b>(1)</b>
public class SomeMovieFinder implements MovieFinder {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>@Repository</code> annotation.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Repository <i class="conum" data-value="1"></i><b>(1)</b>
class SomeMovieFinder : MovieFinder {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>@Repository</code> annotation.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Any DAO or repository implementation needs access to a persistence resource,
depending on the persistence technology used. For example, a JDBC-based repository
needs access to a JDBC <code>DataSource</code>, and a JPA-based repository needs access to an
<code>EntityManager</code>. The easiest way to accomplish this is to have this resource dependency
injected by using one of the <code>@Autowired</code>, <code>@Inject</code>, <code>@Resource</code> or <code>@PersistenceContext</code>
annotations. The following example works for a JPA repository:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Repository
public class JpaMovieFinder implements MovieFinder {

    @PersistenceContext
    private EntityManager entityManager;

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Repository
class JpaMovieFinder : MovieFinder {

    @PersistenceContext
    private lateinit var entityManager: EntityManager

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you use the classic Hibernate APIs, you can inject <code>SessionFactory</code>, as the following
example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Repository
public class HibernateMovieFinder implements MovieFinder {

    private SessionFactory sessionFactory;

    @Autowired
    public void setSessionFactory(SessionFactory sessionFactory) {
        this.sessionFactory = sessionFactory;
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Repository
class HibernateMovieFinder(private val sessionFactory: SessionFactory) : MovieFinder {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The last example we show here is for typical JDBC support. You could have the
<code>DataSource</code> injected into an initialization method or a constructor, where you would create a
<code>JdbcTemplate</code> and other data access support classes (such as <code>SimpleJdbcCall</code> and others) by using
this <code>DataSource</code>. The following example autowires a <code>DataSource</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Repository
public class JdbcMovieFinder implements MovieFinder {

    private JdbcTemplate jdbcTemplate;

    @Autowired
    public void init(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Repository
class JdbcMovieFinder(dataSource: DataSource) : MovieFinder {

    private val jdbcTemplate = JdbcTemplate(dataSource)

    // ...
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See the specific coverage of each persistence technology for details on how to
configure the application context to take advantage of these annotations.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jdbc"><a class="anchor" href="#jdbc"></a>3. Data Access with JDBC</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The value provided by the Spring Framework JDBC abstraction is perhaps best shown by
the sequence of actions outlined in the following table below. The table shows which actions Spring
takes care of and which actions are your responsibility.</p>
</div>
<table id="jdbc-who-does-what" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 4. Spring JDBC - who does what?</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Action</th>
<th class="tableblock halign-left valign-top">Spring</th>
<th class="tableblock halign-left valign-top">You</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Define connection parameters.</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Open the connection.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specify the SQL statement.</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Declare parameters and provide parameter values</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Prepare and run the statement.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Set up the loop to iterate through the results (if any).</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Do the work for each iteration.</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Process any exception.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Handle transactions.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Close the connection, the statement, and the resultset.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The Spring Framework takes care of all the low-level details that can make JDBC such a
tedious API.</p>
</div>
<div class="sect2">
<h3 id="jdbc-choose-style"><a class="anchor" href="#jdbc-choose-style"></a>3.1. Choosing an Approach for JDBC Database Access</h3>
<div class="paragraph">
<p>You can choose among several approaches to form the basis for your JDBC database access.
In addition to three flavors of <code>JdbcTemplate</code>, a new <code>SimpleJdbcInsert</code> and
<code>SimpleJdbcCall</code> approach optimizes database metadata, and the RDBMS Object style takes a
more object-oriented approach similar to that of JDO Query design. Once you start using
one of these approaches, you can still mix and match to include a feature from a
different approach. All approaches require a JDBC 2.0-compliant driver, and some
advanced features require a JDBC 3.0 driver.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>JdbcTemplate</code> is the classic and most popular Spring JDBC approach. This
&#8220;lowest-level&#8221; approach and all others use a JdbcTemplate under the covers.</p>
</li>
<li>
<p><code>NamedParameterJdbcTemplate</code> wraps a <code>JdbcTemplate</code> to provide named parameters
instead of the traditional JDBC <code>?</code> placeholders. This approach provides better
documentation and ease of use when you have multiple parameters for an SQL statement.</p>
</li>
<li>
<p><code>SimpleJdbcInsert</code> and <code>SimpleJdbcCall</code> optimize database metadata to limit the amount
of necessary configuration. This approach simplifies coding so that you need to
provide only the name of the table or procedure and provide a map of parameters matching
the column names. This works only if the database provides adequate metadata. If the
database does not provide this metadata, you have to provide explicit
configuration of the parameters.</p>
</li>
<li>
<p>RDBMS objects  including <code>MappingSqlQuery</code>, <code>SqlUpdate</code>, and <code>StoredProcedure</code> 
require you to create reusable and thread-safe objects during initialization of your
data-access layer. This approach is modeled after JDO Query, wherein you define your
query string, declare parameters, and compile the query. Once you do that,
<code>execute(&#8230;&#8203;)</code>, <code>update(&#8230;&#8203;)</code>, and <code>findObject(&#8230;&#8203;)</code> methods can be called multiple
times with various parameter values.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="jdbc-packages"><a class="anchor" href="#jdbc-packages"></a>3.2. Package Hierarchy</h3>
<div class="paragraph">
<p>The Spring Framework&#8217;s JDBC abstraction framework consists of four different packages:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>core</code>: The <code>org.springframework.jdbc.core</code> package contains the <code>JdbcTemplate</code> class and its
various callback interfaces, plus a variety of related classes. A subpackage named
<code>org.springframework.jdbc.core.simple</code> contains the <code>SimpleJdbcInsert</code> and
<code>SimpleJdbcCall</code> classes. Another subpackage named
<code>org.springframework.jdbc.core.namedparam</code> contains the <code>NamedParameterJdbcTemplate</code>
class and the related support classes. See <a href="#jdbc-core">Using the JDBC Core Classes to Control Basic JDBC Processing and Error Handling</a>, <a href="#jdbc-advanced-jdbc">JDBC Batch Operations</a>, and
<a href="#jdbc-simple-jdbc">Simplifying JDBC Operations with the <code>SimpleJdbc</code> Classes</a>.</p>
</li>
<li>
<p><code>datasource</code>: The <code>org.springframework.jdbc.datasource</code> package contains a utility class for easy
<code>DataSource</code> access and various simple <code>DataSource</code> implementations that you can use for
testing and running unmodified JDBC code outside of a Java EE container. A subpackage
named <code>org.springfamework.jdbc.datasource.embedded</code> provides support for creating
embedded databases by using Java database engines, such as HSQL, H2, and Derby. See
<a href="#jdbc-connections">Controlling Database Connections</a> and <a href="#jdbc-embedded-database-support">Embedded Database Support</a>.</p>
</li>
<li>
<p><code>object</code>: The <code>org.springframework.jdbc.object</code> package contains classes that represent RDBMS
queries, updates, and stored procedures as thread-safe, reusable objects. See
<a href="#jdbc-object">Modeling JDBC Operations as Java Objects</a>. This approach is modeled by JDO, although objects returned by queries
are naturally disconnected from the database. This higher-level of JDBC abstraction
depends on the lower-level abstraction in the <code>org.springframework.jdbc.core</code> package.</p>
</li>
<li>
<p><code>support</code>: The <code>org.springframework.jdbc.support</code> package provides <code>SQLException</code> translation
functionality and some utility classes. Exceptions thrown during JDBC processing are
translated to exceptions defined in the <code>org.springframework.dao</code> package. This means
that code using the Spring JDBC abstraction layer does not need to implement JDBC or
RDBMS-specific error handling. All translated exceptions are unchecked, which gives you
the option of catching the exceptions from which you can recover while letting other
exceptions be propagated to the caller. See <a href="#jdbc-SQLExceptionTranslator">Using <code>SQLExceptionTranslator</code></a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="jdbc-core"><a class="anchor" href="#jdbc-core"></a>3.3. Using the JDBC Core Classes to Control Basic JDBC Processing and Error Handling</h3>
<div class="paragraph">
<p>This section covers how to use the JDBC core classes to control basic JDBC processing,
including error handling. It includes the following topics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#jdbc-JdbcTemplate">Using <code>JdbcTemplate</code></a></p>
</li>
<li>
<p><a href="#jdbc-NamedParameterJdbcTemplate">Using <code>NamedParameterJdbcTemplate</code></a></p>
</li>
<li>
<p><a href="#jdbc-SQLExceptionTranslator">Using <code>SQLExceptionTranslator</code></a></p>
</li>
<li>
<p><a href="#jdbc-statements-executing">Running Statements</a></p>
</li>
<li>
<p><a href="#jdbc-statements-querying">Running Queries</a></p>
</li>
<li>
<p><a href="#jdbc-updates">Updating the Database</a></p>
</li>
<li>
<p><a href="#jdbc-auto-generated-keys">Retrieving Auto-generated Keys</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="jdbc-JdbcTemplate"><a class="anchor" href="#jdbc-JdbcTemplate"></a>3.3.1. Using <code>JdbcTemplate</code></h4>
<div class="paragraph">
<p><code>JdbcTemplate</code> is the central class in the JDBC core package. It handles the
creation and release of resources, which helps you avoid common errors, such as
forgetting to close the connection. It performs the basic tasks of the core JDBC
workflow (such as statement creation and execution), leaving application code to provide
SQL and extract results. The <code>JdbcTemplate</code> class:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Runs SQL queries</p>
</li>
<li>
<p>Updates statements and stored procedure calls</p>
</li>
<li>
<p>Performs iteration over <code>ResultSet</code> instances and extraction of returned parameter values.</p>
</li>
<li>
<p>Catches JDBC exceptions and translates them to the generic, more informative, exception
hierarchy defined in the <code>org.springframework.dao</code> package. (See <a href="#dao-exceptions">Consistent Exception Hierarchy</a>.)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When you use the <code>JdbcTemplate</code> for your code, you need only to implement callback
interfaces, giving them a clearly defined contract. Given a <code>Connection</code> provided by the
<code>JdbcTemplate</code> class, the <code>PreparedStatementCreator</code> callback interface creates a prepared
statement, providing SQL and any necessary parameters. The same is true for the
<code>CallableStatementCreator</code> interface, which creates callable statements. The
<code>RowCallbackHandler</code> interface extracts values from each row of a <code>ResultSet</code>.</p>
</div>
<div class="paragraph">
<p>You can use <code>JdbcTemplate</code> within a DAO implementation through direct instantiation
with a <code>DataSource</code> reference, or you can configure it in a Spring IoC container and give it to
DAOs as a bean reference.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>DataSource</code> should always be configured as a bean in the Spring IoC container. In
the first case the bean is given to the service directly; in the second case it is given
to the prepared template.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>All SQL issued by this class is logged at the <code>DEBUG</code> level under the category
corresponding to the fully qualified class name of the template instance (typically
<code>JdbcTemplate</code>, but it may be different if you use a custom subclass of the
<code>JdbcTemplate</code> class).</p>
</div>
<div class="paragraph">
<p>The following sections provide some examples of <code>JdbcTemplate</code> usage. These examples
are not an exhaustive list of all of the functionality exposed by the <code>JdbcTemplate</code>.
See the attendant <a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/jdbc/core/JdbcTemplate.html">javadoc</a> for that.</p>
</div>
<div class="sect4">
<h5 id="jdbc-JdbcTemplate-examples-query"><a class="anchor" href="#jdbc-JdbcTemplate-examples-query"></a>Querying (<code>SELECT</code>)</h5>
<div class="paragraph">
<p>The following query gets the number of rows in a relation:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">int rowCount = this.jdbcTemplate.queryForObject("select count(*) from t_actor", Integer.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val rowCount = jdbcTemplate.queryForObject&lt;Int&gt;("select count(*) from t_actor")!!</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following query uses a bind variable:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">int countOfActorsNamedJoe = this.jdbcTemplate.queryForObject(
        "select count(*) from t_actor where first_name = ?", Integer.class, "Joe");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val countOfActorsNamedJoe = jdbcTemplate.queryForObject&lt;Int&gt;(
        "select count(*) from t_actor where first_name = ?", arrayOf("Joe"))!!</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following query looks for a <code>String</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">String lastName = this.jdbcTemplate.queryForObject(
        "select last_name from t_actor where id = ?",
        String.class, 1212L);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val lastName = this.jdbcTemplate.queryForObject&lt;String&gt;(
        "select last_name from t_actor where id = ?",
        arrayOf(1212L))!!</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following query finds and populates a single domain object:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Actor actor = jdbcTemplate.queryForObject(
        "select first_name, last_name from t_actor where id = ?",
        (resultSet, rowNum) -&gt; {
            Actor newActor = new Actor();
            newActor.setFirstName(resultSet.getString("first_name"));
            newActor.setLastName(resultSet.getString("last_name"));
            return newActor;
        },
        1212L);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val actor = jdbcTemplate.queryForObject(
            "select first_name, last_name from t_actor where id = ?",
            arrayOf(1212L)) { rs, _ -&gt;
        Actor(rs.getString("first_name"), rs.getString("last_name"))
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following query finds and populates a list of domain objects:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">List&lt;Actor&gt; actors = this.jdbcTemplate.query(
        "select first_name, last_name from t_actor",
        (resultSet, rowNum) -&gt; {
            Actor actor = new Actor();
            actor.setFirstName(resultSet.getString("first_name"));
            actor.setLastName(resultSet.getString("last_name"));
            return actor;
        });</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val actors = jdbcTemplate.query("select first_name, last_name from t_actor") { rs, _ -&gt;
        Actor(rs.getString("first_name"), rs.getString("last_name"))</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the last two snippets of code actually existed in the same application, it would make
sense to remove the duplication present in the two <code>RowMapper</code> lambda expressions and
extract them out into a single field that could then be referenced by DAO methods as needed.
For example, it may be better to write the preceding code snippet as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">private final RowMapper&lt;Actor&gt; actorRowMapper = (resultSet, rowNum) -&gt; {
    Actor actor = new Actor();
    actor.setFirstName(resultSet.getString("first_name"));
    actor.setLastName(resultSet.getString("last_name"));
    return actor;
};

public List&lt;Actor&gt; findAllActors() {
    return this.jdbcTemplate.query( "select first_name, last_name from t_actor", actorRowMapper);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val actorMapper = RowMapper&lt;Actor&gt; { rs: ResultSet, rowNum: Int -&gt;
    Actor(rs.getString("first_name"), rs.getString("last_name"))
}

fun findAllActors(): List&lt;Actor&gt; {
    return jdbcTemplate.query("select first_name, last_name from t_actor", actorMapper)
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="jdbc-JdbcTemplate-examples-update"><a class="anchor" href="#jdbc-JdbcTemplate-examples-update"></a>Updating (<code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code>) with <code>JdbcTemplate</code></h5>
<div class="paragraph">
<p>You can use the <code>update(..)</code> method to perform insert, update, and delete operations.
Parameter values are usually provided as variable arguments or, alternatively, as an object array.</p>
</div>
<div class="paragraph">
<p>The following example inserts a new entry:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">this.jdbcTemplate.update(
        "insert into t_actor (first_name, last_name) values (?, ?)",
        "Leonor", "Watling");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">jdbcTemplate.update(
        "insert into t_actor (first_name, last_name) values (?, ?)",
        "Leonor", "Watling")</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example updates an existing entry:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">this.jdbcTemplate.update(
        "update t_actor set last_name = ? where id = ?",
        "Banjo", 5276L);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">jdbcTemplate.update(
        "update t_actor set last_name = ? where id = ?",
        "Banjo", 5276L)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example deletes an entry:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">this.jdbcTemplate.update(
        "delete from t_actor where id = ?",
        Long.valueOf(actorId));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">jdbcTemplate.update("delete from t_actor where id = ?", actorId.toLong())</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="jdbc-JdbcTemplate-examples-other"><a class="anchor" href="#jdbc-JdbcTemplate-examples-other"></a>Other <code>JdbcTemplate</code> Operations</h5>
<div class="paragraph">
<p>You can use the <code>execute(..)</code> method to run any arbitrary SQL. Consequently, the
method is often used for DDL statements. It is heavily overloaded with variants that take
callback interfaces, binding variable arrays, and so on. The following example creates a
table:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">this.jdbcTemplate.execute("create table mytable (id integer, name varchar(100))");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">jdbcTemplate.execute("create table mytable (id integer, name varchar(100))")</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example invokes a stored procedure:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">this.jdbcTemplate.update(
        "call SUPPORT.REFRESH_ACTORS_SUMMARY(?)",
        Long.valueOf(unionId));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">jdbcTemplate.update(
        "call SUPPORT.REFRESH_ACTORS_SUMMARY(?)",
        unionId.toLong())</code></pre>
</div>
</div>
<div class="paragraph">
<p>More sophisticated stored procedure support is <a href="#jdbc-StoredProcedure">covered later</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="jdbc-JdbcTemplate-idioms"><a class="anchor" href="#jdbc-JdbcTemplate-idioms"></a><code>JdbcTemplate</code> Best Practices</h5>
<div class="paragraph">
<p>Instances of the <code>JdbcTemplate</code> class are thread-safe, once configured. This is
important because it means that you can configure a single instance of a <code>JdbcTemplate</code>
and then safely inject this shared reference into multiple DAOs (or repositories).
The <code>JdbcTemplate</code> is stateful, in that it maintains a reference to a <code>DataSource</code>, but
this state is not conversational state.</p>
</div>
<div class="paragraph">
<p>A common practice when using the <code>JdbcTemplate</code> class (and the associated
<a href="#jdbc-NamedParameterJdbcTemplate"><code>NamedParameterJdbcTemplate</code></a> class) is to
configure a <code>DataSource</code> in your Spring configuration file and then dependency-inject
that shared <code>DataSource</code> bean into your DAO classes. The <code>JdbcTemplate</code> is created in
the setter for the <code>DataSource</code>. This leads to DAOs that resemble the following:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class JdbcCorporateEventDao implements CorporateEventDao {

    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    // JDBC-backed implementations of the methods on the CorporateEventDao follow...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class JdbcCorporateEventDao(dataSource: DataSource) : CorporateEventDao {

    private val jdbcTemplate = JdbcTemplate(dataSource)

    // JDBC-backed implementations of the methods on the CorporateEventDao follow...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows the corresponding XML configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd"&gt;

    &lt;bean id="corporateEventDao" class="com.example.JdbcCorporateEventDao"&gt;
        &lt;property name="dataSource" ref="dataSource"/&gt;
    &lt;/bean&gt;

    &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
        &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
        &lt;property name="url" value="${jdbc.url}"/&gt;
        &lt;property name="username" value="${jdbc.username}"/&gt;
        &lt;property name="password" value="${jdbc.password}"/&gt;
    &lt;/bean&gt;

    &lt;context:property-placeholder location="jdbc.properties"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>An alternative to explicit configuration is to use component-scanning and annotation
support for dependency injection. In this case, you can annotate the class with <code>@Repository</code>
(which makes it a candidate for component-scanning) and annotate the <code>DataSource</code> setter
method with <code>@Autowired</code>. The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Repository <i class="conum" data-value="1"></i><b>(1)</b>
public class JdbcCorporateEventDao implements CorporateEventDao {

    private JdbcTemplate jdbcTemplate;

    @Autowired <i class="conum" data-value="2"></i><b>(2)</b>
    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource); <i class="conum" data-value="3"></i><b>(3)</b>
    }

    // JDBC-backed implementations of the methods on the CorporateEventDao follow...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Annotate the class with <code>@Repository</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Annotate the <code>DataSource</code> setter method with <code>@Autowired</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Create a new <code>JdbcTemplate</code> with the <code>DataSource</code>.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Repository <i class="conum" data-value="1"></i><b>(1)</b>
class JdbcCorporateEventDao(dataSource: DataSource) : CorporateEventDao { <i class="conum" data-value="2"></i><b>(2)</b>

    private val jdbcTemplate = JdbcTemplate(dataSource) <i class="conum" data-value="3"></i><b>(3)</b>

    // JDBC-backed implementations of the methods on the CorporateEventDao follow...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Annotate the class with <code>@Repository</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Constructor injection of the <code>DataSource</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Create a new <code>JdbcTemplate</code> with the <code>DataSource</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows the corresponding XML configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd"&gt;

    &lt;!-- Scans within the base package of the application for @Component classes to configure as beans --&gt;
    &lt;context:component-scan base-package="org.springframework.docs.test" /&gt;

    &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
        &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
        &lt;property name="url" value="${jdbc.url}"/&gt;
        &lt;property name="username" value="${jdbc.username}"/&gt;
        &lt;property name="password" value="${jdbc.password}"/&gt;
    &lt;/bean&gt;

    &lt;context:property-placeholder location="jdbc.properties"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you use Spring&#8217;s <code>JdbcDaoSupport</code> class and your various JDBC-backed DAO classes
extend from it, your sub-class inherits a <code>setDataSource(..)</code> method from the
<code>JdbcDaoSupport</code> class. You can choose whether to inherit from this class. The
<code>JdbcDaoSupport</code> class is provided as a convenience only.</p>
</div>
<div class="paragraph">
<p>Regardless of which of the above template initialization styles you choose to use (or
not), it is seldom necessary to create a new instance of a <code>JdbcTemplate</code> class each
time you want to run SQL. Once configured, a <code>JdbcTemplate</code> instance is thread-safe.
If your application accesses multiple
databases, you may want multiple <code>JdbcTemplate</code> instances, which requires multiple <code>DataSources</code> and, subsequently, multiple differently
configured <code>JdbcTemplate</code> instances.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-NamedParameterJdbcTemplate"><a class="anchor" href="#jdbc-NamedParameterJdbcTemplate"></a>3.3.2. Using <code>NamedParameterJdbcTemplate</code></h4>
<div class="paragraph">
<p>The <code>NamedParameterJdbcTemplate</code> class adds support for programming JDBC statements
by using named parameters, as opposed to programming JDBC statements using only classic
placeholder ( <code>'?'</code>) arguments. The <code>NamedParameterJdbcTemplate</code> class wraps a
<code>JdbcTemplate</code> and delegates to the wrapped <code>JdbcTemplate</code> to do much of its work. This
section describes only those areas of the <code>NamedParameterJdbcTemplate</code> class that differ
from the <code>JdbcTemplate</code> itself&#8201;&#8212;&#8201;namely, programming JDBC statements by using named
parameters. The following example shows how to use <code>NamedParameterJdbcTemplate</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// some JDBC-backed DAO class...
private NamedParameterJdbcTemplate namedParameterJdbcTemplate;

public void setDataSource(DataSource dataSource) {
    this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
}

public int countOfActorsByFirstName(String firstName) {

    String sql = "select count(*) from T_ACTOR where first_name = :first_name";

    SqlParameterSource namedParameters = new MapSqlParameterSource("first_name", firstName);

    return this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Integer.class);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">private val namedParameterJdbcTemplate = NamedParameterJdbcTemplate(dataSource)

fun countOfActorsByFirstName(firstName: String): Int {
    val sql = "select count(*) from T_ACTOR where first_name = :first_name"
    val namedParameters = MapSqlParameterSource("first_name", firstName)
    return namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Int::class.java)!!
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice the use of the named parameter notation in the value assigned to the <code>sql</code>
variable and the corresponding value that is plugged into the <code>namedParameters</code>
variable (of type <code>MapSqlParameterSource</code>).</p>
</div>
<div class="paragraph">
<p>Alternatively, you can pass along named parameters and their corresponding values to a
<code>NamedParameterJdbcTemplate</code> instance by using the <code>Map</code>-based style.The remaining
methods exposed by the <code>NamedParameterJdbcOperations</code> and implemented by the
<code>NamedParameterJdbcTemplate</code> class follow a similar pattern and are not covered here.</p>
</div>
<div class="paragraph">
<p>The following example shows the use of the <code>Map</code>-based style:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// some JDBC-backed DAO class...
private NamedParameterJdbcTemplate namedParameterJdbcTemplate;

public void setDataSource(DataSource dataSource) {
    this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
}

public int countOfActorsByFirstName(String firstName) {

    String sql = "select count(*) from T_ACTOR where first_name = :first_name";

    Map&lt;String, String&gt; namedParameters = Collections.singletonMap("first_name", firstName);

    return this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters,  Integer.class);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// some JDBC-backed DAO class...
private val namedParameterJdbcTemplate = NamedParameterJdbcTemplate(dataSource)

fun countOfActorsByFirstName(firstName: String): Int {
    val sql = "select count(*) from T_ACTOR where first_name = :first_name"
    val namedParameters = mapOf("first_name" to firstName)
    return namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Int::class.java)!!
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>One nice feature related to the <code>NamedParameterJdbcTemplate</code> (and existing in the same
Java package) is the <code>SqlParameterSource</code> interface. You have already seen an example of
an implementation of this interface in one of the previous code snippets (the
<code>MapSqlParameterSource</code> class). An <code>SqlParameterSource</code> is a source of named parameter
values to a <code>NamedParameterJdbcTemplate</code>. The <code>MapSqlParameterSource</code> class is a
simple implementation that is an adapter around a <code>java.util.Map</code>, where the keys
are the parameter names and the values are the parameter values.</p>
</div>
<div class="paragraph">
<p>Another <code>SqlParameterSource</code> implementation is the <code>BeanPropertySqlParameterSource</code>
class. This class wraps an arbitrary JavaBean (that is, an instance of a class that
adheres to <a href="https://www.oracle.com/technetwork/java/javase/documentation/spec-136004.html">the
JavaBean conventions</a>) and uses the properties of the wrapped JavaBean as the source
of named parameter values.</p>
</div>
<div class="paragraph">
<p>The following example shows a typical JavaBean:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class Actor {

    private Long id;
    private String firstName;
    private String lastName;

    public String getFirstName() {
        return this.firstName;
    }

    public String getLastName() {
        return this.lastName;
    }

    public Long getId() {
        return this.id;
    }

    // setters omitted...

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">data class Actor(val id: Long, val firstName: String, val lastName: String)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example uses a <code>NamedParameterJdbcTemplate</code> to return the count of the
members of the class shown in the preceding example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// some JDBC-backed DAO class...
private NamedParameterJdbcTemplate namedParameterJdbcTemplate;

public void setDataSource(DataSource dataSource) {
    this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
}

public int countOfActors(Actor exampleActor) {

    // notice how the named parameters match the properties of the above 'Actor' class
    String sql = "select count(*) from T_ACTOR where first_name = :firstName and last_name = :lastName";

    SqlParameterSource namedParameters = new BeanPropertySqlParameterSource(exampleActor);

    return this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Integer.class);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// some JDBC-backed DAO class...
private val namedParameterJdbcTemplate = NamedParameterJdbcTemplate(dataSource)

private val namedParameterJdbcTemplate = NamedParameterJdbcTemplate(dataSource)

fun countOfActors(exampleActor: Actor): Int {
    // notice how the named parameters match the properties of the above 'Actor' class
    val sql = "select count(*) from T_ACTOR where first_name = :firstName and last_name = :lastName"
    val namedParameters = BeanPropertySqlParameterSource(exampleActor)
    return namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Int::class.java)!!
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Remember that the <code>NamedParameterJdbcTemplate</code> class wraps a classic <code>JdbcTemplate</code>
template. If you need access to the wrapped <code>JdbcTemplate</code> instance to access
functionality that is present only in the <code>JdbcTemplate</code> class, you can use the
<code>getJdbcOperations()</code> method to access the wrapped <code>JdbcTemplate</code> through the
<code>JdbcOperations</code> interface.</p>
</div>
<div class="paragraph">
<p>See also <a href="#jdbc-JdbcTemplate-idioms"><code>JdbcTemplate</code> Best Practices</a> for guidelines on using the
<code>NamedParameterJdbcTemplate</code> class in the context of an application.</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-SQLExceptionTranslator"><a class="anchor" href="#jdbc-SQLExceptionTranslator"></a>3.3.3. Using <code>SQLExceptionTranslator</code></h4>
<div class="paragraph">
<p><code>SQLExceptionTranslator</code> is an interface to be implemented by classes that can translate
between <code>SQLExceptions</code> and Spring&#8217;s own <code>org.springframework.dao.DataAccessException</code>,
which is agnostic in regard to data access strategy. Implementations can be generic (for
example, using SQLState codes for JDBC) or proprietary (for example, using Oracle error
codes) for greater precision.</p>
</div>
<div class="paragraph">
<p><code>SQLErrorCodeSQLExceptionTranslator</code> is the implementation of <code>SQLExceptionTranslator</code>
that is used by default. This implementation uses specific vendor codes. It is more
precise than the <code>SQLState</code> implementation. The error code translations are based on
codes held in a JavaBean type class called <code>SQLErrorCodes</code>. This class is created and
populated by an <code>SQLErrorCodesFactory</code>, which (as the name suggests) is a factory for
creating <code>SQLErrorCodes</code> based on the contents of a configuration file named
<code>sql-error-codes.xml</code>. This file is populated with vendor codes and based on the
<code>DatabaseProductName</code> taken from <code>DatabaseMetaData</code>. The codes for the actual
database you are using are used.</p>
</div>
<div class="paragraph">
<p>The <code>SQLErrorCodeSQLExceptionTranslator</code> applies matching rules in the following sequence:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Any custom translation implemented by a subclass. Normally, the provided concrete
<code>SQLErrorCodeSQLExceptionTranslator</code> is used, so this rule does not apply. It
applies only if you have actually provided a subclass implementation.</p>
</li>
<li>
<p>Any custom implementation of the <code>SQLExceptionTranslator</code> interface that is provided
as the <code>customSqlExceptionTranslator</code> property of the <code>SQLErrorCodes</code> class.</p>
</li>
<li>
<p>The list of instances of the <code>CustomSQLErrorCodesTranslation</code> class (provided for the
<code>customTranslations</code> property of the <code>SQLErrorCodes</code> class) are searched for a match.</p>
</li>
<li>
<p>Error code matching is applied.</p>
</li>
<li>
<p>Use the fallback translator. <code>SQLExceptionSubclassTranslator</code> is the default fallback
translator. If this translation is not available, the next fallback translator is
the <code>SQLStateSQLExceptionTranslator</code>.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>SQLErrorCodesFactory</code> is used by default to define <code>Error</code> codes and custom exception
translations. They are looked up in a file named <code>sql-error-codes.xml</code> from the
classpath, and the matching <code>SQLErrorCodes</code> instance is located based on the database
name from the database metadata of the database in use.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can extend <code>SQLErrorCodeSQLExceptionTranslator</code>, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class CustomSQLErrorCodesTranslator extends SQLErrorCodeSQLExceptionTranslator {

    protected DataAccessException customTranslate(String task, String sql, SQLException sqlEx) {
        if (sqlEx.getErrorCode() == -12345) {
            return new DeadlockLoserDataAccessException(task, sqlEx);
        }
        return null;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class CustomSQLErrorCodesTranslator : SQLErrorCodeSQLExceptionTranslator() {

    override fun customTranslate(task: String, sql: String?, sqlEx: SQLException): DataAccessException? {
        if (sqlEx.errorCode == -12345) {
                return DeadlockLoserDataAccessException(task, sqlEx)
            }
            return null;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the specific error code (<code>-12345</code>) is translated, while other errors are
left to be translated by the default translator implementation. To use this custom
translator, you must pass it to the <code>JdbcTemplate</code> through the method
<code>setExceptionTranslator</code>, and you must use this <code>JdbcTemplate</code> for all of the data access
processing where this translator is needed. The following example shows how you can use this custom
translator:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">private JdbcTemplate jdbcTemplate;

public void setDataSource(DataSource dataSource) {

    // create a JdbcTemplate and set data source
    this.jdbcTemplate = new JdbcTemplate();
    this.jdbcTemplate.setDataSource(dataSource);

    // create a custom translator and set the DataSource for the default translation lookup
    CustomSQLErrorCodesTranslator tr = new CustomSQLErrorCodesTranslator();
    tr.setDataSource(dataSource);
    this.jdbcTemplate.setExceptionTranslator(tr);

}

public void updateShippingCharge(long orderId, long pct) {
    // use the prepared JdbcTemplate for this update
    this.jdbcTemplate.update("update orders" +
        " set shipping_charge = shipping_charge * ? / 100" +
        " where id = ?", pct, orderId);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// create a JdbcTemplate and set data source
private val jdbcTemplate = JdbcTemplate(dataSource).apply {
    // create a custom translator and set the DataSource for the default translation lookup
    exceptionTranslator = CustomSQLErrorCodesTranslator().apply {
        this.dataSource = dataSource
    }
}

fun updateShippingCharge(orderId: Long, pct: Long) {
    // use the prepared JdbcTemplate for this update
    this.jdbcTemplate!!.update("update orders" +
            " set shipping_charge = shipping_charge * ? / 100" +
            " where id = ?", pct, orderId)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The custom translator is passed a data source in order to look up the error codes in
<code>sql-error-codes.xml</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-statements-executing"><a class="anchor" href="#jdbc-statements-executing"></a>3.3.4. Running Statements</h4>
<div class="paragraph">
<p>Running an SQL statement requires very little code. You need a <code>DataSource</code> and a
<code>JdbcTemplate</code>, including the convenience methods that are provided with the
<code>JdbcTemplate</code>. The following example shows what you need to include for a minimal but
fully functional class that creates a new table:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import javax.sql.DataSource;
import org.springframework.jdbc.core.JdbcTemplate;

public class ExecuteAStatement {

    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    public void doExecute() {
        this.jdbcTemplate.execute("create table mytable (id integer, name varchar(100))");
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import javax.sql.DataSource
import org.springframework.jdbc.core.JdbcTemplate

class ExecuteAStatement(dataSource: DataSource) {

    private val jdbcTemplate = JdbcTemplate(dataSource)

    fun doExecute() {
        jdbcTemplate.execute("create table mytable (id integer, name varchar(100))")
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-statements-querying"><a class="anchor" href="#jdbc-statements-querying"></a>3.3.5. Running Queries</h4>
<div class="paragraph">
<p>Some query methods return a single value. To retrieve a count or a specific value from
one row, use <code>queryForObject(..)</code>. The latter converts the returned JDBC <code>Type</code> to the
Java class that is passed in as an argument. If the type conversion is invalid, an
<code>InvalidDataAccessApiUsageException</code> is thrown. The following example contains two
query methods, one for an <code>int</code> and one that queries for a <code>String</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import javax.sql.DataSource;
import org.springframework.jdbc.core.JdbcTemplate;

public class RunAQuery {

    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    public int getCount() {
        return this.jdbcTemplate.queryForObject("select count(*) from mytable", Integer.class);
    }

    public String getName() {
        return this.jdbcTemplate.queryForObject("select name from mytable", String.class);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import javax.sql.DataSource
import org.springframework.jdbc.core.JdbcTemplate

class RunAQuery(dataSource: DataSource) {

    private val jdbcTemplate = JdbcTemplate(dataSource)

    val count: Int
        get() = jdbcTemplate.queryForObject("select count(*) from mytable")!!

    val name: String?
        get() = jdbcTemplate.queryForObject("select name from mytable")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In addition to the single result query methods, several methods return a list with an
entry for each row that the query returned. The most generic method is <code>queryForList(..)</code>,
which returns a <code>List</code> where each element is a <code>Map</code> containing one entry for each column,
using the column name as the key. If you add a method to the preceding example to retrieve a
list of all the rows, it might be as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">private JdbcTemplate jdbcTemplate;

public void setDataSource(DataSource dataSource) {
    this.jdbcTemplate = new JdbcTemplate(dataSource);
}

public List&lt;Map&lt;String, Object&gt;&gt; getList() {
    return this.jdbcTemplate.queryForList("select * from mytable");
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">private val jdbcTemplate = JdbcTemplate(dataSource)

fun getList(): List&lt;Map&lt;String, Any&gt;&gt; {
    return jdbcTemplate.queryForList("select * from mytable")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The returned list would resemble the following:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>[{name=Bob, id=1}, {name=Mary, id=2}]</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-updates"><a class="anchor" href="#jdbc-updates"></a>3.3.6. Updating the Database</h4>
<div class="paragraph">
<p>The following example updates a column for a certain primary key:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import javax.sql.DataSource;
import org.springframework.jdbc.core.JdbcTemplate;

public class ExecuteAnUpdate {

    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    public void setName(int id, String name) {
        this.jdbcTemplate.update("update mytable set name = ? where id = ?", name, id);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import javax.sql.DataSource
import org.springframework.jdbc.core.JdbcTemplate

class ExecuteAnUpdate(dataSource: DataSource) {

    private val jdbcTemplate = JdbcTemplate(dataSource)

    fun setName(id: Int, name: String) {
        jdbcTemplate.update("update mytable set name = ? where id = ?", name, id)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example,
an SQL statement has placeholders for row parameters. You can pass the parameter values
in as varargs or ,alternatively, as an array of objects. Thus, you should explicitly wrap primitives
in the primitive wrapper classes, or you should use auto-boxing.</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-auto-generated-keys"><a class="anchor" href="#jdbc-auto-generated-keys"></a>3.3.7. Retrieving Auto-generated Keys</h4>
<div class="paragraph">
<p>An <code>update()</code> convenience method supports the retrieval of primary keys generated by the
database. This support is part of the JDBC 3.0 standard. See Chapter 13.6 of the
specification for details. The method takes a <code>PreparedStatementCreator</code> as its first
argument, and this is the way the required insert statement is specified. The other
argument is a <code>KeyHolder</code>, which contains the generated key on successful return from the
update. There is no standard single way to create an appropriate <code>PreparedStatement</code>
(which explains why the method signature is the way it is). The following example works
on Oracle but may not work on other platforms:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">final String INSERT_SQL = "insert into my_test (name) values(?)";
final String name = "Rob";

KeyHolder keyHolder = new GeneratedKeyHolder();
jdbcTemplate.update(connection -&gt; {
    PreparedStatement ps = connection.prepareStatement(INSERT_SQL, new String[] { "id" });
    ps.setString(1, name);
    return ps;
}, keyHolder);

// keyHolder.getKey() now contains the generated key</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val INSERT_SQL = "insert into my_test (name) values(?)"
val name = "Rob"

val keyHolder = GeneratedKeyHolder()
jdbcTemplate.update({
    it.prepareStatement (INSERT_SQL, arrayOf("id")).apply { setString(1, name) }
}, keyHolder)

// keyHolder.getKey() now contains the generated key</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jdbc-connections"><a class="anchor" href="#jdbc-connections"></a>3.4. Controlling Database Connections</h3>
<div class="paragraph">
<p>This section covers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#jdbc-datasource">Using <code>DataSource</code></a></p>
</li>
<li>
<p><a href="#jdbc-DataSourceUtils">Using <code>DataSourceUtils</code></a></p>
</li>
<li>
<p><a href="#jdbc-SmartDataSource">Implementing <code>SmartDataSource</code></a></p>
</li>
<li>
<p><a href="#jdbc-AbstractDataSource">Extending <code>AbstractDataSource</code></a></p>
</li>
<li>
<p><a href="#jdbc-SingleConnectionDataSource">Using <code>SingleConnectionDataSource</code></a></p>
</li>
<li>
<p><a href="#jdbc-DriverManagerDataSource">Using <code>DriverManagerDataSource</code></a></p>
</li>
<li>
<p><a href="#jdbc-TransactionAwareDataSourceProxy">Using <code>TransactionAwareDataSourceProxy</code></a></p>
</li>
<li>
<p><a href="#jdbc-DataSourceTransactionManager">Using <code>DataSourceTransactionManager</code></a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="jdbc-datasource"><a class="anchor" href="#jdbc-datasource"></a>3.4.1. Using <code>DataSource</code></h4>
<div class="paragraph">
<p>Spring obtains a connection to the database through a <code>DataSource</code>. A <code>DataSource</code> is
part of the JDBC specification and is a generalized connection factory. It lets a
container or a framework hide connection pooling and transaction management issues
from the application code. As a developer, you need not know details about how to
connect to the database. That is the responsibility of the administrator who sets up
the datasource. You most likely fill both roles as you develop and test code, but you
do not necessarily have to know how the production data source is configured.</p>
</div>
<div class="paragraph">
<p>When you use Spring&#8217;s JDBC layer, you can obtain a data source from JNDI, or you can
configure your own with a connection pool implementation provided by a third party.
Traditional choices are Apache Commons DBCP and C3P0 with bean-style <code>DataSource</code> classes;
for a modern JDBC connection pool, consider HikariCP with its builder-style API instead.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You should use the <code>DriverManagerDataSource</code> and <code>SimpleDriverDataSource</code> classes
(as included in the Spring distribution) only for testing purposes! Those variants do not
provide pooling and perform poorly when multiple requests for a connection are made.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following section uses Spring&#8217;s <code>DriverManagerDataSource</code> implementation.
Several other <code>DataSource</code> variants are covered later.</p>
</div>
<div class="paragraph">
<p>To configure a <code>DriverManagerDataSource</code>:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Obtain a connection with <code>DriverManagerDataSource</code> as you typically obtain a JDBC
connection.</p>
</li>
<li>
<p>Specify the fully qualified classname of the JDBC driver so that the <code>DriverManager</code>
can load the driver class.</p>
</li>
<li>
<p>Provide a URL that varies between JDBC drivers. (See the documentation for your driver
for the correct value.)</p>
</li>
<li>
<p>Provide a username and a password to connect to the database.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The following example shows how to configure a <code>DriverManagerDataSource</code> in Java:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">DriverManagerDataSource dataSource = new DriverManagerDataSource();
dataSource.setDriverClassName("org.hsqldb.jdbcDriver");
dataSource.setUrl("jdbc:hsqldb:hsql://localhost:");
dataSource.setUsername("sa");
dataSource.setPassword("");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val dataSource = DriverManagerDataSource().apply {
    setDriverClassName("org.hsqldb.jdbcDriver")
    url = "jdbc:hsqldb:hsql://localhost:"
    username = "sa"
    password = ""
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows the corresponding XML configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;
    &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
    &lt;property name="url" value="${jdbc.url}"/&gt;
    &lt;property name="username" value="${jdbc.username}"/&gt;
    &lt;property name="password" value="${jdbc.password}"/&gt;
&lt;/bean&gt;

&lt;context:property-placeholder location="jdbc.properties"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The next two examples show the basic connectivity and configuration for DBCP and C3P0.
To learn about more options that help control the pooling features, see the product
documentation for the respective connection pooling implementations.</p>
</div>
<div class="paragraph">
<p>The following example shows DBCP configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
    &lt;property name="url" value="${jdbc.url}"/&gt;
    &lt;property name="username" value="${jdbc.username}"/&gt;
    &lt;property name="password" value="${jdbc.password}"/&gt;
&lt;/bean&gt;

&lt;context:property-placeholder location="jdbc.properties"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows C3P0 configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource" destroy-method="close"&gt;
    &lt;property name="driverClass" value="${jdbc.driverClassName}"/&gt;
    &lt;property name="jdbcUrl" value="${jdbc.url}"/&gt;
    &lt;property name="user" value="${jdbc.username}"/&gt;
    &lt;property name="password" value="${jdbc.password}"/&gt;
&lt;/bean&gt;

&lt;context:property-placeholder location="jdbc.properties"/&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-DataSourceUtils"><a class="anchor" href="#jdbc-DataSourceUtils"></a>3.4.2. Using <code>DataSourceUtils</code></h4>
<div class="paragraph">
<p>The <code>DataSourceUtils</code> class is a convenient and powerful helper class that provides
<code>static</code> methods to obtain connections from JNDI and close connections if necessary. It
supports thread-bound connections with, for example, <code>DataSourceTransactionManager</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-SmartDataSource"><a class="anchor" href="#jdbc-SmartDataSource"></a>3.4.3. Implementing <code>SmartDataSource</code></h4>
<div class="paragraph">
<p>The <code>SmartDataSource</code> interface should be implemented by classes that can provide a
connection to a relational database. It extends the <code>DataSource</code> interface to let
classes that use it query whether the connection should be closed after a given
operation. This usage is efficient when you know that you need to reuse a connection.</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-AbstractDataSource"><a class="anchor" href="#jdbc-AbstractDataSource"></a>3.4.4. Extending <code>AbstractDataSource</code></h4>
<div class="paragraph">
<p><code>AbstractDataSource</code> is an <code>abstract</code> base class for Spring&#8217;s <code>DataSource</code>
implementations. It implements code that is common to all <code>DataSource</code> implementations.
You should extend the <code>AbstractDataSource</code> class if you write your own <code>DataSource</code>
implementation.</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-SingleConnectionDataSource"><a class="anchor" href="#jdbc-SingleConnectionDataSource"></a>3.4.5. Using <code>SingleConnectionDataSource</code></h4>
<div class="paragraph">
<p>The <code>SingleConnectionDataSource</code> class is an implementation of the <code>SmartDataSource</code>
interface that wraps a single <code>Connection</code> that is not closed after each use.
This is not multi-threading capable.</p>
</div>
<div class="paragraph">
<p>If any client code calls <code>close</code> on the assumption of a pooled connection (as when using
persistence tools), you should set the <code>suppressClose</code> property to <code>true</code>. This setting
returns a close-suppressing proxy that wraps the physical connection. Note that you can
no longer cast this to a native Oracle <code>Connection</code> or a similar object.</p>
</div>
<div class="paragraph">
<p><code>SingleConnectionDataSource</code> is primarily a test class. It typically enables easy testing
of code outside an application server, in conjunction with a simple JNDI environment.
In contrast to <code>DriverManagerDataSource</code>, it reuses the same connection all the time,
avoiding excessive creation of physical connections.</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-DriverManagerDataSource"><a class="anchor" href="#jdbc-DriverManagerDataSource"></a>3.4.6. Using <code>DriverManagerDataSource</code></h4>
<div class="paragraph">
<p>The <code>DriverManagerDataSource</code> class is an implementation of the standard <code>DataSource</code>
interface that configures a plain JDBC driver through bean properties and returns a new
<code>Connection</code> every time.</p>
</div>
<div class="paragraph">
<p>This implementation is useful for test and stand-alone environments outside of a Java EE
container, either as a <code>DataSource</code> bean in a Spring IoC container or in conjunction
with a simple JNDI environment. Pool-assuming <code>Connection.close()</code> calls
close the connection, so any <code>DataSource</code>-aware persistence code should work. However,
using JavaBean-style connection pools (such as <code>commons-dbcp</code>) is so easy, even in a test
environment, that it is almost always preferable to use such a connection pool over
<code>DriverManagerDataSource</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-TransactionAwareDataSourceProxy"><a class="anchor" href="#jdbc-TransactionAwareDataSourceProxy"></a>3.4.7. Using <code>TransactionAwareDataSourceProxy</code></h4>
<div class="paragraph">
<p><code>TransactionAwareDataSourceProxy</code> is a proxy for a target <code>DataSource</code>. The proxy wraps that
target <code>DataSource</code> to add awareness of Spring-managed transactions. In this respect, it
is similar to a transactional JNDI <code>DataSource</code>, as provided by a Java EE server.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It is rarely desirable to use this class, except when already existing code must be
called and passed a standard JDBC <code>DataSource</code> interface implementation. In this case,
you can still have this code be usable and, at the same time, have this code
participating in Spring managed transactions. It is generally preferable to write your
own new code by using the higher level abstractions for resource management, such as
<code>JdbcTemplate</code> or <code>DataSourceUtils</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>See the <a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/jdbc/datasource/TransactionAwareDataSourceProxy.html"><code>TransactionAwareDataSourceProxy</code></a>
javadoc for more details.</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-DataSourceTransactionManager"><a class="anchor" href="#jdbc-DataSourceTransactionManager"></a>3.4.8. Using <code>DataSourceTransactionManager</code></h4>
<div class="paragraph">
<p>The <code>DataSourceTransactionManager</code> class is a <code>PlatformTransactionManager</code>
implementation for single JDBC datasources. It binds a JDBC connection from the
specified data source to the currently executing thread, potentially allowing for one
thread connection per data source.</p>
</div>
<div class="paragraph">
<p>Application code is required to retrieve the JDBC connection through
<code>DataSourceUtils.getConnection(DataSource)</code> instead of Java EE&#8217;s standard
<code>DataSource.getConnection</code>. It throws unchecked <code>org.springframework.dao</code> exceptions
instead of checked <code>SQLExceptions</code>. All framework classes (such as <code>JdbcTemplate</code>) use this
strategy implicitly. If not used with this transaction manager, the lookup strategy
behaves exactly like the common one. Thus, it can be used in any case.</p>
</div>
<div class="paragraph">
<p>The <code>DataSourceTransactionManager</code> class supports custom isolation levels and timeouts
that get applied as appropriate JDBC statement query timeouts. To support the latter,
application code must either use <code>JdbcTemplate</code> or call the
<code>DataSourceUtils.applyTransactionTimeout(..)</code> method for each created statement.</p>
</div>
<div class="paragraph">
<p>You can use this implementation instead of <code>JtaTransactionManager</code> in the single-resource
case, as it does not require the container to support JTA. Switching between
both is just a matter of configuration, provided you stick to the required connection lookup
pattern. JTA does not support custom isolation levels.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jdbc-advanced-jdbc"><a class="anchor" href="#jdbc-advanced-jdbc"></a>3.5. JDBC Batch Operations</h3>
<div class="paragraph">
<p>Most JDBC drivers provide improved performance if you batch multiple calls to the same
prepared statement. By grouping updates into batches, you limit the number of round trips
to the database.</p>
</div>
<div class="sect3">
<h4 id="jdbc-batch-classic"><a class="anchor" href="#jdbc-batch-classic"></a>3.5.1. Basic Batch Operations with <code>JdbcTemplate</code></h4>
<div class="paragraph">
<p>You accomplish <code>JdbcTemplate</code> batch processing by implementing two methods of a special
interface, <code>BatchPreparedStatementSetter</code>, and passing that implementation in as the second parameter
in your <code>batchUpdate</code> method call. You can use the <code>getBatchSize</code> method to provide the size of
the current batch. You can use the <code>setValues</code> method to set the values for the parameters of
the prepared statement. This method is called the number of times that you
specified in the <code>getBatchSize</code> call. The following example updates the <code>t_actor</code> table
based on entries in a list, and the entire list is used as the batch:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class JdbcActorDao implements ActorDao {

    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    public int[] batchUpdate(final List&lt;Actor&gt; actors) {
        return this.jdbcTemplate.batchUpdate(
                "update t_actor set first_name = ?, last_name = ? where id = ?",
                new BatchPreparedStatementSetter() {
                    public void setValues(PreparedStatement ps, int i) throws SQLException {
                        Actor actor = actors.get(i);
                        ps.setString(1, actor.getFirstName());
                        ps.setString(2, actor.getLastName());
                        ps.setLong(3, actor.getId().longValue());
                    }
                    public int getBatchSize() {
                        return actors.size();
                    }
                });
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class JdbcActorDao(dataSource: DataSource) : ActorDao {

    private val jdbcTemplate = JdbcTemplate(dataSource)

    fun batchUpdate(actors: List&lt;Actor&gt;): IntArray {
        return jdbcTemplate.batchUpdate(
                "update t_actor set first_name = ?, last_name = ? where id = ?",
                object: BatchPreparedStatementSetter {
                    override fun setValues(ps: PreparedStatement, i: Int) {
                        ps.setString(1, actors[i].firstName)
                        ps.setString(2, actors[i].lastName)
                        ps.setLong(3, actors[i].id)
                    }

                    override fun getBatchSize() = actors.size
                })
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you process a stream of updates or reading from a file, you might have a
preferred batch size, but the last batch might not have that number of entries. In this
case, you can use the <code>InterruptibleBatchPreparedStatementSetter</code> interface, which lets
you interrupt a batch once the input source is exhausted. The <code>isBatchExhausted</code> method
lets you signal the end of the batch.</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-batch-list"><a class="anchor" href="#jdbc-batch-list"></a>3.5.2. Batch Operations with a List of Objects</h4>
<div class="paragraph">
<p>Both the <code>JdbcTemplate</code> and the <code>NamedParameterJdbcTemplate</code> provides an alternate way
of providing the batch update. Instead of implementing a special batch interface, you
provide all parameter values in the call as a list. The framework loops over these
values and uses an internal prepared statement setter. The API varies, depending on
whether you use named parameters. For the named parameters, you provide an array of
<code>SqlParameterSource</code>, one entry for each member of the batch. You can use the
<code>SqlParameterSourceUtils.createBatch</code> convenience methods to create this array, passing
in an array of bean-style objects (with getter methods corresponding to parameters),
<code>String</code>-keyed <code>Map</code> instances (containing the corresponding parameters as values), or a mix of both.</p>
</div>
<div class="paragraph">
<p>The following example shows a batch update using named parameters:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class JdbcActorDao implements ActorDao {

    private NamedParameterTemplate namedParameterJdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
    }

    public int[] batchUpdate(List&lt;Actor&gt; actors) {
        return this.namedParameterJdbcTemplate.batchUpdate(
                "update t_actor set first_name = :firstName, last_name = :lastName where id = :id",
                SqlParameterSourceUtils.createBatch(actors));
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class JdbcActorDao(dataSource: DataSource) : ActorDao {

    private val namedParameterJdbcTemplate = NamedParameterJdbcTemplate(dataSource)

    fun batchUpdate(actors: List&lt;Actor&gt;): IntArray {
        return this.namedParameterJdbcTemplate.batchUpdate(
                "update t_actor set first_name = :firstName, last_name = :lastName where id = :id",
                SqlParameterSourceUtils.createBatch(actors));
    }

        // ... additional methods
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For an SQL statement that uses the classic <code>?</code> placeholders, you pass in a list
containing an object array with the update values. This object array must have one entry
for each placeholder in the SQL statement, and they must be in the same order as they are
defined in the SQL statement.</p>
</div>
<div class="paragraph">
<p>The following example is the same as the preceding example, except that it uses classic
JDBC <code>?</code> placeholders:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class JdbcActorDao implements ActorDao {

    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    public int[] batchUpdate(final List&lt;Actor&gt; actors) {
        List&lt;Object[]&gt; batch = new ArrayList&lt;Object[]&gt;();
        for (Actor actor : actors) {
            Object[] values = new Object[] {
                    actor.getFirstName(), actor.getLastName(), actor.getId()};
            batch.add(values);
        }
        return this.jdbcTemplate.batchUpdate(
                "update t_actor set first_name = ?, last_name = ? where id = ?",
                batch);
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class JdbcActorDao(dataSource: DataSource) : ActorDao {

    private val jdbcTemplate = JdbcTemplate(dataSource)

    fun batchUpdate(actors: List&lt;Actor&gt;): IntArray {
        val batch = mutableListOf&lt;Array&lt;Any&gt;&gt;()
        for (actor in actors) {
            batch.add(arrayOf(actor.firstName, actor.lastName, actor.id))
        }
        return jdbcTemplate.batchUpdate(
                "update t_actor set first_name = ?, last_name = ? where id = ?", batch)
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>All of the batch update methods that we described earlier return an <code>int</code> array
containing the number of affected rows for each batch entry. This count is reported by
the JDBC driver. If the count is not available, the JDBC driver returns a value of <code>-2</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In such a scenario, with automatic setting of values on an underlying <code>PreparedStatement</code>,
the corresponding JDBC type for each value needs to be derived from the given Java type.
While this usually works well, there is a potential for issues (for example, with Map-contained
<code>null</code> values). Spring, by default, calls <code>ParameterMetaData.getParameterType</code> in such a
case, which can be expensive with your JDBC driver. You should use a recent driver
version and consider setting the <code>spring.jdbc.getParameterType.ignore</code> property to <code>true</code>
(as a JVM system property or via the
<a href="appendix.html#appendix-spring-properties"><code>SpringProperties</code></a> mechanism) if you encounter
a performance issue (as reported on Oracle 12c, JBoss, and PostgreSQL).</p>
</div>
<div class="paragraph">
<p>Alternatively, you might consider specifying the corresponding JDBC types explicitly,
either through a <code>BatchPreparedStatementSetter</code> (as shown earlier), through an explicit type
array given to a <code>List&lt;Object[]&gt;</code> based call, through <code>registerSqlType</code> calls on a
custom <code>MapSqlParameterSource</code> instance, or through a <code>BeanPropertySqlParameterSource</code>
that derives the SQL type from the Java-declared property type even for a null value.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-batch-multi"><a class="anchor" href="#jdbc-batch-multi"></a>3.5.3. Batch Operations with Multiple Batches</h4>
<div class="paragraph">
<p>The preceding example of a batch update deals with batches that are so large that you want to
break them up into several smaller batches. You can do this with the methods
mentioned earlier by making multiple calls to the <code>batchUpdate</code> method, but there is now a
more convenient method. This method takes, in addition to the SQL statement, a
<code>Collection</code> of objects that contain the parameters, the number of updates to make for each
batch, and a <code>ParameterizedPreparedStatementSetter</code> to set the values for the parameters
of the prepared statement. The framework loops over the provided values and breaks the
update calls into batches of the size specified.</p>
</div>
<div class="paragraph">
<p>The following example shows a batch update that uses a batch size of 100:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class JdbcActorDao implements ActorDao {

    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    public int[][] batchUpdate(final Collection&lt;Actor&gt; actors) {
        int[][] updateCounts = jdbcTemplate.batchUpdate(
                "update t_actor set first_name = ?, last_name = ? where id = ?",
                actors,
                100,
                (PreparedStatement ps, Actor actor) -&gt; {
                    ps.setString(1, actor.getFirstName());
                    ps.setString(2, actor.getLastName());
                    ps.setLong(3, actor.getId().longValue());
                });
        return updateCounts;
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class JdbcActorDao(dataSource: DataSource) : ActorDao {

    private val jdbcTemplate = JdbcTemplate(dataSource)

    fun batchUpdate(actors: List&lt;Actor&gt;): Array&lt;IntArray&gt; {
        return jdbcTemplate.batchUpdate(
                    "update t_actor set first_name = ?, last_name = ? where id = ?",
                    actors, 100) { ps, argument -&gt;
            ps.setString(1, argument.firstName)
            ps.setString(2, argument.lastName)
            ps.setLong(3, argument.id)
        }
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The batch update methods for this call returns an array of <code>int</code> arrays that contains an
array entry for each batch with an array of the number of affected rows for each update.
The top-level array&#8217;s length indicates the number of batches run, and the second level
array&#8217;s length indicates the number of updates in that batch. The number of updates in
each batch should be the batch size provided for all batches (except that the last one
that might be less), depending on the total number of update objects provided. The update
count for each update statement is the one reported by the JDBC driver. If the count is
not available, the JDBC driver returns a value of <code>-2</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jdbc-simple-jdbc"><a class="anchor" href="#jdbc-simple-jdbc"></a>3.6. Simplifying JDBC Operations with the <code>SimpleJdbc</code> Classes</h3>
<div class="paragraph">
<p>The <code>SimpleJdbcInsert</code> and <code>SimpleJdbcCall</code> classes provide a simplified configuration
by taking advantage of database metadata that can be retrieved through the JDBC driver.
This means that you have less to configure up front, although you can override or turn off
the metadata processing if you prefer to provide all the details in your code.</p>
</div>
<div class="sect3">
<h4 id="jdbc-simple-jdbc-insert-1"><a class="anchor" href="#jdbc-simple-jdbc-insert-1"></a>3.6.1. Inserting Data by Using <code>SimpleJdbcInsert</code></h4>
<div class="paragraph">
<p>We start by looking at the <code>SimpleJdbcInsert</code> class with the minimal amount of
configuration options. You should instantiate the <code>SimpleJdbcInsert</code> in the data access
layer&#8217;s initialization method. For this example, the initializing method is the
<code>setDataSource</code> method. You do not need to subclass the <code>SimpleJdbcInsert</code> class. Instead,
you can create a new instance and set the table name by using the <code>withTableName</code> method.
Configuration methods for this class follow the <code>fluid</code> style that returns the instance
of the <code>SimpleJdbcInsert</code>, which lets you chain all configuration methods. The following
example uses only one configuration method (we show examples of multiple methods later):</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class JdbcActorDao implements ActorDao {

    private SimpleJdbcInsert insertActor;

    public void setDataSource(DataSource dataSource) {
        this.insertActor = new SimpleJdbcInsert(dataSource).withTableName("t_actor");
    }

    public void add(Actor actor) {
        Map&lt;String, Object&gt; parameters = new HashMap&lt;String, Object&gt;(3);
        parameters.put("id", actor.getId());
        parameters.put("first_name", actor.getFirstName());
        parameters.put("last_name", actor.getLastName());
        insertActor.execute(parameters);
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class JdbcActorDao(dataSource: DataSource) : ActorDao {

    private val insertActor = SimpleJdbcInsert(dataSource).withTableName("t_actor")

    fun add(actor: Actor) {
        val parameters = mutableMapOf&lt;String, Any&gt;()
        parameters["id"] = actor.id
        parameters["first_name"] = actor.firstName
        parameters["last_name"] = actor.lastName
        insertActor.execute(parameters)
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>execute</code> method used here takes a plain <code>java.util.Map</code> as its only parameter. The
important thing to note here is that the keys used for the <code>Map</code> must match the column
names of the table, as defined in the database. This is because we read the metadata
to construct the actual insert statement.</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-simple-jdbc-insert-2"><a class="anchor" href="#jdbc-simple-jdbc-insert-2"></a>3.6.2. Retrieving Auto-generated Keys by Using <code>SimpleJdbcInsert</code></h4>
<div class="paragraph">
<p>The next example uses the same insert as the preceding example, but, instead of passing in the <code>id</code>, it
retrieves the auto-generated key and sets it on the new <code>Actor</code> object. When it creates
the <code>SimpleJdbcInsert</code>, in addition to specifying the table name, it specifies the name
of the generated key column with the <code>usingGeneratedKeyColumns</code> method. The following
listing shows how it works:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class JdbcActorDao implements ActorDao {

    private SimpleJdbcInsert insertActor;

    public void setDataSource(DataSource dataSource) {
        this.insertActor = new SimpleJdbcInsert(dataSource)
                .withTableName("t_actor")
                .usingGeneratedKeyColumns("id");
    }

    public void add(Actor actor) {
        Map&lt;String, Object&gt; parameters = new HashMap&lt;String, Object&gt;(2);
        parameters.put("first_name", actor.getFirstName());
        parameters.put("last_name", actor.getLastName());
        Number newId = insertActor.executeAndReturnKey(parameters);
        actor.setId(newId.longValue());
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class JdbcActorDao(dataSource: DataSource) : ActorDao {

    private val insertActor = SimpleJdbcInsert(dataSource)
            .withTableName("t_actor").usingGeneratedKeyColumns("id")

    fun add(actor: Actor): Actor {
        val parameters = mapOf(
                "first_name" to actor.firstName,
                "last_name" to actor.lastName)
        val newId = insertActor.executeAndReturnKey(parameters);
        return actor.copy(id = newId.toLong())
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The main difference when you run the insert by using this second approach is that you do not
add the <code>id</code> to the <code>Map</code>, and you call the <code>executeAndReturnKey</code> method. This returns a
<code>java.lang.Number</code> object with which you can create an instance of the numerical type that
is used in your domain class. You cannot rely on all databases to return a specific Java
class here. <code>java.lang.Number</code> is the base class that you can rely on. If you have
multiple auto-generated columns or the generated values are non-numeric, you can
use a <code>KeyHolder</code> that is returned from the <code>executeAndReturnKeyHolder</code> method.</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-simple-jdbc-insert-3"><a class="anchor" href="#jdbc-simple-jdbc-insert-3"></a>3.6.3. Specifying Columns for a <code>SimpleJdbcInsert</code></h4>
<div class="paragraph">
<p>You can limit the columns for an insert by specifying a list of column names with the
<code>usingColumns</code> method, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class JdbcActorDao implements ActorDao {

    private SimpleJdbcInsert insertActor;

    public void setDataSource(DataSource dataSource) {
        this.insertActor = new SimpleJdbcInsert(dataSource)
                .withTableName("t_actor")
                .usingColumns("first_name", "last_name")
                .usingGeneratedKeyColumns("id");
    }

    public void add(Actor actor) {
        Map&lt;String, Object&gt; parameters = new HashMap&lt;String, Object&gt;(2);
        parameters.put("first_name", actor.getFirstName());
        parameters.put("last_name", actor.getLastName());
        Number newId = insertActor.executeAndReturnKey(parameters);
        actor.setId(newId.longValue());
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class JdbcActorDao(dataSource: DataSource) : ActorDao {

    private val insertActor = SimpleJdbcInsert(dataSource)
            .withTableName("t_actor")
            .usingColumns("first_name", "last_name")
            .usingGeneratedKeyColumns("id")

    fun add(actor: Actor): Actor {
        val parameters = mapOf(
                "first_name" to actor.firstName,
                "last_name" to actor.lastName)
        val newId = insertActor.executeAndReturnKey(parameters);
        return actor.copy(id = newId.toLong())
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The execution of the insert is the same as if you had relied on the metadata to determine
which columns to use.</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-simple-jdbc-parameters"><a class="anchor" href="#jdbc-simple-jdbc-parameters"></a>3.6.4. Using <code>SqlParameterSource</code> to Provide Parameter Values</h4>
<div class="paragraph">
<p>Using a <code>Map</code> to provide parameter values works fine, but it is not the most convenient
class to use. Spring provides a couple of implementations of the <code>SqlParameterSource</code>
interface that you can use instead. The first one is <code>BeanPropertySqlParameterSource</code>,
which is a very convenient class if you have a JavaBean-compliant class that contains
your values. It uses the corresponding getter method to extract the parameter
values. The following example shows how to use <code>BeanPropertySqlParameterSource</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class JdbcActorDao implements ActorDao {

    private SimpleJdbcInsert insertActor;

    public void setDataSource(DataSource dataSource) {
        this.insertActor = new SimpleJdbcInsert(dataSource)
                .withTableName("t_actor")
                .usingGeneratedKeyColumns("id");
    }

    public void add(Actor actor) {
        SqlParameterSource parameters = new BeanPropertySqlParameterSource(actor);
        Number newId = insertActor.executeAndReturnKey(parameters);
        actor.setId(newId.longValue());
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class JdbcActorDao(dataSource: DataSource) : ActorDao {

    private val insertActor = SimpleJdbcInsert(dataSource)
            .withTableName("t_actor")
            .usingGeneratedKeyColumns("id")

    fun add(actor: Actor): Actor {
        val parameters = BeanPropertySqlParameterSource(actor)
        val newId = insertActor.executeAndReturnKey(parameters)
        return actor.copy(id = newId.toLong())
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another option is the <code>MapSqlParameterSource</code> that resembles a <code>Map</code> but provides a more
convenient <code>addValue</code> method that can be chained. The following example shows how to use it:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class JdbcActorDao implements ActorDao {

    private SimpleJdbcInsert insertActor;

    public void setDataSource(DataSource dataSource) {
        this.insertActor = new SimpleJdbcInsert(dataSource)
                .withTableName("t_actor")
                .usingGeneratedKeyColumns("id");
    }

    public void add(Actor actor) {
        SqlParameterSource parameters = new MapSqlParameterSource()
                .addValue("first_name", actor.getFirstName())
                .addValue("last_name", actor.getLastName());
        Number newId = insertActor.executeAndReturnKey(parameters);
        actor.setId(newId.longValue());
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class JdbcActorDao(dataSource: DataSource) : ActorDao {

    private val insertActor = SimpleJdbcInsert(dataSource)
            .withTableName("t_actor")
            .usingGeneratedKeyColumns("id")

    fun add(actor: Actor): Actor {
        val parameters = MapSqlParameterSource()
                    .addValue("first_name", actor.firstName)
                    .addValue("last_name", actor.lastName)
        val newId = insertActor.executeAndReturnKey(parameters)
        return actor.copy(id = newId.toLong())
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, the configuration is the same. Only the executing code has to change to
use these alternative input classes.</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-simple-jdbc-call-1"><a class="anchor" href="#jdbc-simple-jdbc-call-1"></a>3.6.5. Calling a Stored Procedure with <code>SimpleJdbcCall</code></h4>
<div class="paragraph">
<p>The <code>SimpleJdbcCall</code> class uses metadata in the database to look up names of <code>in</code>
and <code>out</code> parameters so that you do not have to explicitly declare them. You can
declare parameters if you prefer to do that or if you have parameters (such as <code>ARRAY</code>
or <code>STRUCT</code>) that do not have an automatic mapping to a Java class. The first example
shows a simple procedure that returns only scalar values in <code>VARCHAR</code> and <code>DATE</code> format
from a MySQL database. The example procedure reads a specified actor entry and returns
<code>first_name</code>, <code>last_name</code>, and <code>birth_date</code> columns in the form of <code>out</code> parameters.
The following listing shows the first example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="sql" class="language-sql hljs">CREATE PROCEDURE read_actor (
    IN in_id INTEGER,
    OUT out_first_name VARCHAR(100),
    OUT out_last_name VARCHAR(100),
    OUT out_birth_date DATE)
BEGIN
    SELECT first_name, last_name, birth_date
    INTO out_first_name, out_last_name, out_birth_date
    FROM t_actor where id = in_id;
END;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>in_id</code> parameter contains the <code>id</code> of the actor that you are looking up. The <code>out</code>
parameters return the data read from the table.</p>
</div>
<div class="paragraph">
<p>You can declare <code>SimpleJdbcCall</code> in a manner similar to declaring <code>SimpleJdbcInsert</code>. You
should instantiate and configure the class in the initialization method of your data-access
layer. Compared to the <code>StoredProcedure</code> class, you need not create a subclass
and you need not to declare parameters that can be looked up in the database metadata.
The following example of a <code>SimpleJdbcCall</code> configuration uses the preceding stored
procedure (the only configuration option, in addition to the <code>DataSource</code>, is the name
of the stored procedure):</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class JdbcActorDao implements ActorDao {

    private SimpleJdbcCall procReadActor;

    public void setDataSource(DataSource dataSource) {
        this.procReadActor = new SimpleJdbcCall(dataSource)
                .withProcedureName("read_actor");
    }

    public Actor readActor(Long id) {
        SqlParameterSource in = new MapSqlParameterSource()
                .addValue("in_id", id);
        Map out = procReadActor.execute(in);
        Actor actor = new Actor();
        actor.setId(id);
        actor.setFirstName((String) out.get("out_first_name"));
        actor.setLastName((String) out.get("out_last_name"));
        actor.setBirthDate((Date) out.get("out_birth_date"));
        return actor;
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class JdbcActorDao(dataSource: DataSource) : ActorDao {

    private val procReadActor = SimpleJdbcCall(dataSource)
            .withProcedureName("read_actor")


    fun readActor(id: Long): Actor {
        val source = MapSqlParameterSource().addValue("in_id", id)
        val output = procReadActor.execute(source)
        return Actor(
                id,
                output["out_first_name"] as String,
                output["out_last_name"] as String,
                output["out_birth_date"] as Date)
    }

        // ... additional methods
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code you write for the execution of the call involves creating an <code>SqlParameterSource</code>
containing the IN parameter. You must match the name provided for the input value
with that of the parameter name declared in the stored procedure. The case does not have
to match because you use metadata to determine how database objects should be referred to
in a stored procedure. What is specified in the source for the stored procedure is not
necessarily the way it is stored in the database. Some databases transform names to all
upper case, while others use lower case or use the case as specified.</p>
</div>
<div class="paragraph">
<p>The <code>execute</code> method takes the IN parameters and returns a <code>Map</code> that contains any <code>out</code>
parameters keyed by the name, as specified in the stored procedure. In this case, they are
<code>out_first_name</code>, <code>out_last_name</code>, and <code>out_birth_date</code>.</p>
</div>
<div class="paragraph">
<p>The last part of the <code>execute</code> method creates an <code>Actor</code> instance to use to return the
data retrieved. Again, it is important to use the names of the <code>out</code> parameters as they
are declared in the stored procedure. Also, the case in the names of the <code>out</code>
parameters stored in the results map matches that of the <code>out</code> parameter names in the
database, which could vary between databases. To make your code more portable, you should
do a case-insensitive lookup or instruct Spring to use a <code>LinkedCaseInsensitiveMap</code>.
To do the latter, you can create your own <code>JdbcTemplate</code> and set the <code>setResultsMapCaseInsensitive</code>
property to <code>true</code>. Then you can pass this customized <code>JdbcTemplate</code> instance into
the constructor of your <code>SimpleJdbcCall</code>. The following example shows this configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class JdbcActorDao implements ActorDao {

    private SimpleJdbcCall procReadActor;

    public void setDataSource(DataSource dataSource) {
        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
        jdbcTemplate.setResultsMapCaseInsensitive(true);
        this.procReadActor = new SimpleJdbcCall(jdbcTemplate)
                .withProcedureName("read_actor");
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class JdbcActorDao(dataSource: DataSource) : ActorDao {

    private var procReadActor = SimpleJdbcCall(JdbcTemplate(dataSource).apply {
        isResultsMapCaseInsensitive = true
    }).withProcedureName("read_actor")

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>By taking this action, you avoid conflicts in the case used for the names of your
returned <code>out</code> parameters.</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-simple-jdbc-call-2"><a class="anchor" href="#jdbc-simple-jdbc-call-2"></a>3.6.6. Explicitly Declaring Parameters to Use for a <code>SimpleJdbcCall</code></h4>
<div class="paragraph">
<p>Earlier in this chapter, we described how parameters are deduced from metadata, but you can declare them
explicitly if you wish. You can do so by creating and configuring <code>SimpleJdbcCall</code> with
the <code>declareParameters</code> method, which takes a variable number of <code>SqlParameter</code> objects
as input. See the <a href="#jdbc-params">next section</a> for details on how to define an <code>SqlParameter</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Explicit declarations are necessary if the database you use is not a Spring-supported
database. Currently, Spring supports metadata lookup of stored procedure calls for the
following databases: Apache Derby, DB2, MySQL, Microsoft SQL Server, Oracle, and Sybase.
We also support metadata lookup of stored functions for MySQL, Microsoft SQL Server,
and Oracle.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can opt to explicitly declare one, some, or all of the parameters. The parameter
metadata is still used where you do not explicitly declare parameters. To bypass all
processing of metadata lookups for potential parameters and use only the declared
parameters, you can call the method <code>withoutProcedureColumnMetaDataAccess</code> as part of the
declaration. Suppose that you have two or more different call signatures declared for a
database function. In this case, you call <code>useInParameterNames</code> to specify the list
of IN parameter names to include for a given signature.</p>
</div>
<div class="paragraph">
<p>The following example shows a fully declared procedure call and uses the information from
the preceding example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class JdbcActorDao implements ActorDao {

    private SimpleJdbcCall procReadActor;

    public void setDataSource(DataSource dataSource) {
        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
        jdbcTemplate.setResultsMapCaseInsensitive(true);
        this.procReadActor = new SimpleJdbcCall(jdbcTemplate)
                .withProcedureName("read_actor")
                .withoutProcedureColumnMetaDataAccess()
                .useInParameterNames("in_id")
                .declareParameters(
                        new SqlParameter("in_id", Types.NUMERIC),
                        new SqlOutParameter("out_first_name", Types.VARCHAR),
                        new SqlOutParameter("out_last_name", Types.VARCHAR),
                        new SqlOutParameter("out_birth_date", Types.DATE)
                );
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class JdbcActorDao(dataSource: DataSource) : ActorDao {

        private val procReadActor = SimpleJdbcCall(JdbcTemplate(dataSource).apply {
            isResultsMapCaseInsensitive = true
        }).withProcedureName("read_actor")
                .withoutProcedureColumnMetaDataAccess()
                .useInParameterNames("in_id")
                .declareParameters(
                        SqlParameter("in_id", Types.NUMERIC),
                        SqlOutParameter("out_first_name", Types.VARCHAR),
                        SqlOutParameter("out_last_name", Types.VARCHAR),
                        SqlOutParameter("out_birth_date", Types.DATE)
    )

        // ... additional methods
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The execution and end results of the two examples are the same. The second example specifies all
details explicitly rather than relying on metadata.</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-params"><a class="anchor" href="#jdbc-params"></a>3.6.7. How to Define <code>SqlParameters</code></h4>
<div class="paragraph">
<p>To define a parameter for the <code>SimpleJdbc</code> classes and also for the RDBMS operations
classes (covered in <a href="#jdbc-object">Modeling JDBC Operations as Java Objects</a>) you can use <code>SqlParameter</code> or one of its subclasses.
To do so, you typically specify the parameter name and SQL type in the constructor. The SQL type
is specified by using the <code>java.sql.Types</code> constants. Earlier in this chapter, we saw declarations
similar to the following:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">new SqlParameter("in_id", Types.NUMERIC),
new SqlOutParameter("out_first_name", Types.VARCHAR),</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">SqlParameter("in_id", Types.NUMERIC),
SqlOutParameter("out_first_name", Types.VARCHAR),</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first line with the <code>SqlParameter</code> declares an IN parameter. You can use IN parameters
for both stored procedure calls and for queries by using the <code>SqlQuery</code> and its
subclasses (covered in <a href="#jdbc-SqlQuery">Understanding <code>SqlQuery</code></a>).</p>
</div>
<div class="paragraph">
<p>The second line (with the <code>SqlOutParameter</code>) declares an <code>out</code> parameter to be used in a
stored procedure call. There is also an <code>SqlInOutParameter</code> for <code>InOut</code> parameters
(parameters that provide an IN value to the procedure and that also return a value).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Only parameters declared as <code>SqlParameter</code> and <code>SqlInOutParameter</code> are used to
provide input values. This is different from the <code>StoredProcedure</code> class, which (for
backwards compatibility reasons) lets input values be provided for parameters
declared as <code>SqlOutParameter</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For IN parameters, in addition to the name and the SQL type, you can specify a scale for
numeric data or a type name for custom database types. For <code>out</code> parameters, you can
provide a <code>RowMapper</code> to handle mapping of rows returned from a <code>REF</code> cursor. Another
option is to specify an <code>SqlReturnType</code> that provides an opportunity to define
customized handling of the return values.</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-simple-jdbc-call-3"><a class="anchor" href="#jdbc-simple-jdbc-call-3"></a>3.6.8. Calling a Stored Function by Using <code>SimpleJdbcCall</code></h4>
<div class="paragraph">
<p>You can call a stored function in almost the same way as you call a stored procedure, except
that you provide a function name rather than a procedure name. You use the
<code>withFunctionName</code> method as part of the configuration to indicate that you want to make
a call to a function, and the corresponding string for a function call is generated. A
specialized call (<code>executeFunction</code>) is used to run the function, and it
returns the function return value as an object of a specified type, which means you do
not have to retrieve the return value from the results map. A similar convenience method
(named <code>executeObject</code>) is also available for stored procedures that have only one <code>out</code>
parameter. The following example (for MySQL) is based on a stored function named <code>get_actor_name</code>
that returns an actor&#8217;s full name:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="sql" class="language-sql hljs">CREATE FUNCTION get_actor_name (in_id INTEGER)
RETURNS VARCHAR(200) READS SQL DATA
BEGIN
    DECLARE out_name VARCHAR(200);
    SELECT concat(first_name, ' ', last_name)
        INTO out_name
        FROM t_actor where id = in_id;
    RETURN out_name;
END;</code></pre>
</div>
</div>
<div class="paragraph">
<p>To call this function, we again create a <code>SimpleJdbcCall</code> in the initialization method,
as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class JdbcActorDao implements ActorDao {

    private JdbcTemplate jdbcTemplate;
    private SimpleJdbcCall funcGetActorName;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
        jdbcTemplate.setResultsMapCaseInsensitive(true);
        this.funcGetActorName = new SimpleJdbcCall(jdbcTemplate)
                .withFunctionName("get_actor_name");
    }

    public String getActorName(Long id) {
        SqlParameterSource in = new MapSqlParameterSource()
                .addValue("in_id", id);
        String name = funcGetActorName.executeFunction(String.class, in);
        return name;
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class JdbcActorDao(dataSource: DataSource) : ActorDao {

    private val jdbcTemplate = JdbcTemplate(dataSource).apply {
        isResultsMapCaseInsensitive = true
    }
    private val funcGetActorName = SimpleJdbcCall(jdbcTemplate)
            .withFunctionName("get_actor_name")

    fun getActorName(id: Long): String {
        val source = MapSqlParameterSource().addValue("in_id", id)
        return funcGetActorName.executeFunction(String::class.java, source)
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>executeFunction</code> method used returns a <code>String</code> that contains the return value from the
function call.</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-simple-jdbc-call-4"><a class="anchor" href="#jdbc-simple-jdbc-call-4"></a>3.6.9. Returning a <code>ResultSet</code> or REF Cursor from a <code>SimpleJdbcCall</code></h4>
<div class="paragraph">
<p>Calling a stored procedure or function that returns a result set is a bit tricky. Some
databases return result sets during the JDBC results processing, while others require an
explicitly registered <code>out</code> parameter of a specific type. Both approaches need
additional processing to loop over the result set and process the returned rows. With
the <code>SimpleJdbcCall</code>, you can use the <code>returningResultSet</code> method and declare a <code>RowMapper</code>
implementation to be used for a specific parameter. If the result set is
returned during the results processing, there are no names defined, so the returned
results must match the order in which you declare the <code>RowMapper</code>
implementations. The name specified is still used to store the processed list of results
in the results map that is returned from the <code>execute</code> statement.</p>
</div>
<div class="paragraph">
<p>The next example (for MySQL) uses a stored procedure that takes no IN parameters and returns
all rows from the <code>t_actor</code> table:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="sql" class="language-sql hljs">CREATE PROCEDURE read_all_actors()
BEGIN
 SELECT a.id, a.first_name, a.last_name, a.birth_date FROM t_actor a;
END;</code></pre>
</div>
</div>
<div class="paragraph">
<p>To call this procedure, you can declare the <code>RowMapper</code>. Because the class to which you want
to map follows the JavaBean rules, you can use a <code>BeanPropertyRowMapper</code> that is created by
passing in the required class to map to in the <code>newInstance</code> method.
The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class JdbcActorDao implements ActorDao {

    private SimpleJdbcCall procReadAllActors;

    public void setDataSource(DataSource dataSource) {
        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
        jdbcTemplate.setResultsMapCaseInsensitive(true);
        this.procReadAllActors = new SimpleJdbcCall(jdbcTemplate)
                .withProcedureName("read_all_actors")
                .returningResultSet("actors",
                BeanPropertyRowMapper.newInstance(Actor.class));
    }

    public List getActorsList() {
        Map m = procReadAllActors.execute(new HashMap&lt;String, Object&gt;(0));
        return (List) m.get("actors");
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class JdbcActorDao(dataSource: DataSource) : ActorDao {

        private val procReadAllActors = SimpleJdbcCall(JdbcTemplate(dataSource).apply {
            isResultsMapCaseInsensitive = true
        }).withProcedureName("read_all_actors")
                .returningResultSet("actors",
                        BeanPropertyRowMapper.newInstance(Actor::class.java))

    fun getActorsList(): List&lt;Actor&gt; {
        val m = procReadAllActors.execute(mapOf&lt;String, Any&gt;())
        return m["actors"] as List&lt;Actor&gt;
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>execute</code> call passes in an empty <code>Map</code>, because this call does not take any parameters.
The list of actors is then retrieved from the results map and returned to the caller.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jdbc-object"><a class="anchor" href="#jdbc-object"></a>3.7. Modeling JDBC Operations as Java Objects</h3>
<div class="paragraph">
<p>The <code>org.springframework.jdbc.object</code> package contains classes that let you access
the database in a more object-oriented manner. As an example, you can run queries
and get the results back as a list that contains business objects with the relational
column data mapped to the properties of the business object. You can also run stored
procedures and run update, delete, and insert statements.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Many Spring developers believe that the various RDBMS operation classes described below
(with the exception of the <a href="#jdbc-StoredProcedure"><code>StoredProcedure</code></a> class) can often
be replaced with straight <code>JdbcTemplate</code> calls. Often, it is simpler to write a DAO
method that calls a method on a <code>JdbcTemplate</code> directly (as opposed to
encapsulating a query as a full-blown class).</p>
</div>
<div class="paragraph">
<p>However, if you are getting measurable value from using the RDBMS operation classes,
you should continue to use these classes.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="jdbc-SqlQuery"><a class="anchor" href="#jdbc-SqlQuery"></a>3.7.1. Understanding <code>SqlQuery</code></h4>
<div class="paragraph">
<p><code>SqlQuery</code> is a reusable, thread-safe class that encapsulates an SQL query. Subclasses
must implement the <code>newRowMapper(..)</code> method to provide a <code>RowMapper</code> instance that can
create one object per row obtained from iterating over the <code>ResultSet</code> that is created
during the execution of the query. The <code>SqlQuery</code> class is rarely used directly, because
the <code>MappingSqlQuery</code> subclass provides a much more convenient implementation for
mapping rows to Java classes. Other implementations that extend <code>SqlQuery</code> are
<code>MappingSqlQueryWithParameters</code> and <code>UpdatableSqlQuery</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-MappingSqlQuery"><a class="anchor" href="#jdbc-MappingSqlQuery"></a>3.7.2. Using <code>MappingSqlQuery</code></h4>
<div class="paragraph">
<p><code>MappingSqlQuery</code> is a reusable query in which concrete subclasses must implement the
abstract <code>mapRow(..)</code> method to convert each row of the supplied <code>ResultSet</code> into an
object of the type specified. The following example shows a custom query that maps the
data from the <code>t_actor</code> relation to an instance of the <code>Actor</code> class:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class ActorMappingQuery extends MappingSqlQuery&lt;Actor&gt; {

    public ActorMappingQuery(DataSource ds) {
        super(ds, "select id, first_name, last_name from t_actor where id = ?");
        declareParameter(new SqlParameter("id", Types.INTEGER));
        compile();
    }

    @Override
    protected Actor mapRow(ResultSet rs, int rowNumber) throws SQLException {
        Actor actor = new Actor();
        actor.setId(rs.getLong("id"));
        actor.setFirstName(rs.getString("first_name"));
        actor.setLastName(rs.getString("last_name"));
        return actor;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class ActorMappingQuery(ds: DataSource) : MappingSqlQuery&lt;Actor&gt;(ds, "select id, first_name, last_name from t_actor where id = ?") {

    init {
        declareParameter(SqlParameter("id", Types.INTEGER))
        compile()
    }

    override fun mapRow(rs: ResultSet, rowNumber: Int) = Actor(
            rs.getLong("id"),
            rs.getString("first_name"),
            rs.getString("last_name")
    )
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The class extends <code>MappingSqlQuery</code> parameterized with the <code>Actor</code> type. The constructor
for this customer query takes a <code>DataSource</code> as the only parameter. In this
constructor, you can call the constructor on the superclass with the <code>DataSource</code> and the SQL
that should be run to retrieve the rows for this query. This SQL is used to
create a <code>PreparedStatement</code>, so it may contain placeholders for any parameters to be
passed in during execution. You must declare each parameter by using the <code>declareParameter</code>
method passing in an <code>SqlParameter</code>. The <code>SqlParameter</code> takes a name, and the JDBC type
as defined in <code>java.sql.Types</code>. After you define all parameters, you can call the
<code>compile()</code> method so that the statement can be prepared and later run. This class is
thread-safe after it is compiled, so, as long as these instances are created when the DAO
is initialized, they can be kept as instance variables and be reused. The following
example shows how to define such a class:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">private ActorMappingQuery actorMappingQuery;

@Autowired
public void setDataSource(DataSource dataSource) {
    this.actorMappingQuery = new ActorMappingQuery(dataSource);
}

public Customer getCustomer(Long id) {
    return actorMappingQuery.findObject(id);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">private val actorMappingQuery = ActorMappingQuery(dataSource)

fun getCustomer(id: Long) = actorMappingQuery.findObject(id)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The method in the preceding example retrieves the customer with the <code>id</code> that is passed in as the
only parameter. Since we want only one object to be returned, we call the <code>findObject</code> convenience
method with the <code>id</code> as the parameter. If we had instead a query that returned a
list of objects and took additional parameters, we would use one of the <code>execute</code>
methods that takes an array of parameter values passed in as varargs. The following
example shows such a method:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public List&lt;Actor&gt; searchForActors(int age, String namePattern) {
    List&lt;Actor&gt; actors = actorSearchMappingQuery.execute(age, namePattern);
    return actors;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">fun searchForActors(age: Int, namePattern: String) =
            actorSearchMappingQuery.execute(age, namePattern)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-SqlUpdate"><a class="anchor" href="#jdbc-SqlUpdate"></a>3.7.3. Using <code>SqlUpdate</code></h4>
<div class="paragraph">
<p>The <code>SqlUpdate</code> class encapsulates an SQL update. As with a query, an update object is
reusable, and, as with all <code>RdbmsOperation</code> classes, an update can have parameters and is
defined in SQL. This class provides a number of <code>update(..)</code> methods analogous to the
<code>execute(..)</code> methods of query objects. The <code>SQLUpdate</code> class is concrete. It can be
subclassed&#8201;&#8212;&#8201;for example, to add a custom update method.
However, you do not have to subclass the <code>SqlUpdate</code>
class, since it can easily be parameterized by setting SQL and declaring parameters.
The following example creates a custom update method named <code>execute</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import java.sql.Types;
import javax.sql.DataSource;
import org.springframework.jdbc.core.SqlParameter;
import org.springframework.jdbc.object.SqlUpdate;

public class UpdateCreditRating extends SqlUpdate {

    public UpdateCreditRating(DataSource ds) {
        setDataSource(ds);
        setSql("update customer set credit_rating = ? where id = ?");
        declareParameter(new SqlParameter("creditRating", Types.NUMERIC));
        declareParameter(new SqlParameter("id", Types.NUMERIC));
        compile();
    }

    /**
     * @param id for the Customer to be updated
     * @param rating the new value for credit rating
     * @return number of rows updated
     */
    public int execute(int id, int rating) {
        return update(rating, id);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import java.sql.Types
import javax.sql.DataSource
import org.springframework.jdbc.core.SqlParameter
import org.springframework.jdbc.<code>object</code>.SqlUpdate

class UpdateCreditRating(ds: DataSource) : SqlUpdate() {

    init {
        setDataSource(ds)
        sql = "update customer set credit_rating = ? where id = ?"
        declareParameter(SqlParameter("creditRating", Types.NUMERIC))
        declareParameter(SqlParameter("id", Types.NUMERIC))
        compile()
    }

    /**
     * @param id for the Customer to be updated
     * @param rating the new value for credit rating
     * @return number of rows updated
     */
    fun execute(id: Int, rating: Int): Int {
        return update(rating, id)
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-StoredProcedure"><a class="anchor" href="#jdbc-StoredProcedure"></a>3.7.4. Using <code>StoredProcedure</code></h4>
<div class="paragraph">
<p>The <code>StoredProcedure</code> class is an <code>abstract</code> superclass for object abstractions of RDBMS
stored procedures.</p>
</div>
<div class="paragraph">
<p>The inherited <code>sql</code> property is the name of the stored procedure in the RDBMS.</p>
</div>
<div class="paragraph">
<p>To define a parameter for the <code>StoredProcedure</code> class, you can use an <code>SqlParameter</code> or one
of its subclasses. You must specify the parameter name and SQL type in the constructor,
as the following code snippet shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">new SqlParameter("in_id", Types.NUMERIC),
new SqlOutParameter("out_first_name", Types.VARCHAR),</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">SqlParameter("in_id", Types.NUMERIC),
SqlOutParameter("out_first_name", Types.VARCHAR),</code></pre>
</div>
</div>
<div class="paragraph">
<p>The SQL type is specified using the <code>java.sql.Types</code> constants.</p>
</div>
<div class="paragraph">
<p>The first line (with the <code>SqlParameter</code>) declares an IN parameter. You can use IN parameters
both for stored procedure calls and for queries using the <code>SqlQuery</code> and its
subclasses (covered in <a href="#jdbc-SqlQuery">Understanding <code>SqlQuery</code></a>).</p>
</div>
<div class="paragraph">
<p>The second line (with the <code>SqlOutParameter</code>) declares an <code>out</code> parameter to be used in the
stored procedure call. There is also an <code>SqlInOutParameter</code> for <code>InOut</code> parameters
(parameters that provide an <code>in</code> value to the procedure and that also return a value).</p>
</div>
<div class="paragraph">
<p>For <code>in</code> parameters, in addition to the name and the SQL type, you can specify a
scale for numeric data or a type name for custom database types. For <code>out</code> parameters,
you can provide a <code>RowMapper</code> to handle mapping of rows returned from a <code>REF</code> cursor.
Another option is to specify an <code>SqlReturnType</code> that lets you define customized
handling of the return values.</p>
</div>
<div class="paragraph">
<p>The next example of a simple DAO uses a <code>StoredProcedure</code> to call a function
(<code>sysdate()</code>), which comes with any Oracle database. To use the stored procedure
functionality, you have to create a class that extends <code>StoredProcedure</code>. In this
example, the <code>StoredProcedure</code> class is an inner class. However, if you need to reuse the
<code>StoredProcedure</code>, you can declare it as a top-level class. This example has no input
parameters, but an output parameter is declared as a date type by using the
<code>SqlOutParameter</code> class. The <code>execute()</code> method runs the procedure and extracts the
returned date from the results <code>Map</code>. The results <code>Map</code> has an entry for each declared
output parameter (in this case, only one) by using the parameter name as the key.
The following listing shows our custom StoredProcedure class:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import java.sql.Types;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import javax.sql.DataSource;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.SqlOutParameter;
import org.springframework.jdbc.object.StoredProcedure;

public class StoredProcedureDao {

    private GetSysdateProcedure getSysdate;

    @Autowired
    public void init(DataSource dataSource) {
        this.getSysdate = new GetSysdateProcedure(dataSource);
    }

    public Date getSysdate() {
        return getSysdate.execute();
    }

    private class GetSysdateProcedure extends StoredProcedure {

        private static final String SQL = "sysdate";

        public GetSysdateProcedure(DataSource dataSource) {
            setDataSource(dataSource);
            setFunction(true);
            setSql(SQL);
            declareParameter(new SqlOutParameter("date", Types.DATE));
            compile();
        }

        public Date execute() {
            // the 'sysdate' sproc has no input parameters, so an empty Map is supplied...
            Map&lt;String, Object&gt; results = execute(new HashMap&lt;String, Object&gt;());
            Date sysdate = (Date) results.get("date");
            return sysdate;
        }
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import java.sql.Types
import java.util.Date
import java.util.Map
import javax.sql.DataSource
import org.springframework.jdbc.core.SqlOutParameter
import org.springframework.jdbc.object.StoredProcedure

class StoredProcedureDao(dataSource: DataSource) {

    private val SQL = "sysdate"

    private val getSysdate = GetSysdateProcedure(dataSource)

    val sysdate: Date
        get() = getSysdate.execute()

    private inner class GetSysdateProcedure(dataSource: DataSource) : StoredProcedure() {

        init {
            setDataSource(dataSource)
            isFunction = true
            sql = SQL
            declareParameter(SqlOutParameter("date", Types.DATE))
            compile()
        }

        fun execute(): Date {
            // the 'sysdate' sproc has no input parameters, so an empty Map is supplied...
            val results = execute(mutableMapOf&lt;String, Any&gt;())
            return results["date"] as Date
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example of a <code>StoredProcedure</code> has two output parameters (in this case,
Oracle REF cursors):</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import java.util.HashMap;
import java.util.Map;
import javax.sql.DataSource;
import oracle.jdbc.OracleTypes;
import org.springframework.jdbc.core.SqlOutParameter;
import org.springframework.jdbc.object.StoredProcedure;

public class TitlesAndGenresStoredProcedure extends StoredProcedure {

    private static final String SPROC_NAME = "AllTitlesAndGenres";

    public TitlesAndGenresStoredProcedure(DataSource dataSource) {
        super(dataSource, SPROC_NAME);
        declareParameter(new SqlOutParameter("titles", OracleTypes.CURSOR, new TitleMapper()));
        declareParameter(new SqlOutParameter("genres", OracleTypes.CURSOR, new GenreMapper()));
        compile();
    }

    public Map&lt;String, Object&gt; execute() {
        // again, this sproc has no input parameters, so an empty Map is supplied
        return super.execute(new HashMap&lt;String, Object&gt;());
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import java.util.HashMap
import javax.sql.DataSource
import oracle.jdbc.OracleTypes
import org.springframework.jdbc.core.SqlOutParameter
import org.springframework.jdbc.<code>object</code>.StoredProcedure

class TitlesAndGenresStoredProcedure(dataSource: DataSource) : StoredProcedure(dataSource, SPROC_NAME) {

    companion object {
        private const val SPROC_NAME = "AllTitlesAndGenres"
    }

    init {
        declareParameter(SqlOutParameter("titles", OracleTypes.CURSOR, TitleMapper()))
        declareParameter(SqlOutParameter("genres", OracleTypes.CURSOR, GenreMapper()))
        compile()
    }

    fun execute(): Map&lt;String, Any&gt; {
        // again, this sproc has no input parameters, so an empty Map is supplied
        return super.execute(HashMap&lt;String, Any&gt;())
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice how the overloaded variants of the <code>declareParameter(..)</code> method that have been
used in the <code>TitlesAndGenresStoredProcedure</code> constructor are passed <code>RowMapper</code>
implementation instances. This is a very convenient and powerful way to reuse existing
functionality. The next two examples provide code for the two <code>RowMapper</code> implementations.</p>
</div>
<div class="paragraph">
<p>The <code>TitleMapper</code> class maps a <code>ResultSet</code> to a <code>Title</code> domain object for each row in
the supplied <code>ResultSet</code>, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import java.sql.ResultSet;
import java.sql.SQLException;
import com.foo.domain.Title;
import org.springframework.jdbc.core.RowMapper;

public final class TitleMapper implements RowMapper&lt;Title&gt; {

    public Title mapRow(ResultSet rs, int rowNum) throws SQLException {
        Title title = new Title();
        title.setId(rs.getLong("id"));
        title.setName(rs.getString("name"));
        return title;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import java.sql.ResultSet
import com.foo.domain.Title
import org.springframework.jdbc.core.RowMapper

class TitleMapper : RowMapper&lt;Title&gt; {

    override fun mapRow(rs: ResultSet, rowNum: Int) =
            Title(rs.getLong("id"), rs.getString("name"))
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>GenreMapper</code> class maps a <code>ResultSet</code> to a <code>Genre</code> domain object for each row in
the supplied <code>ResultSet</code>, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import java.sql.ResultSet;
import java.sql.SQLException;
import com.foo.domain.Genre;
import org.springframework.jdbc.core.RowMapper;

public final class GenreMapper implements RowMapper&lt;Genre&gt; {

    public Genre mapRow(ResultSet rs, int rowNum) throws SQLException {
        return new Genre(rs.getString("name"));
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import java.sql.ResultSet
import com.foo.domain.Genre
import org.springframework.jdbc.core.RowMapper

class GenreMapper : RowMapper&lt;Genre&gt; {

    override fun mapRow(rs: ResultSet, rowNum: Int): Genre {
        return Genre(rs.getString("name"))
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To pass parameters to a stored procedure that has one or more input parameters in its
definition in the RDBMS, you can code a strongly typed <code>execute(..)</code> method that would
delegate to the untyped <code>execute(Map)</code> method in the superclass, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import java.sql.Types;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import javax.sql.DataSource;
import oracle.jdbc.OracleTypes;
import org.springframework.jdbc.core.SqlOutParameter;
import org.springframework.jdbc.core.SqlParameter;
import org.springframework.jdbc.object.StoredProcedure;

public class TitlesAfterDateStoredProcedure extends StoredProcedure {

    private static final String SPROC_NAME = "TitlesAfterDate";
    private static final String CUTOFF_DATE_PARAM = "cutoffDate";

    public TitlesAfterDateStoredProcedure(DataSource dataSource) {
        super(dataSource, SPROC_NAME);
        declareParameter(new SqlParameter(CUTOFF_DATE_PARAM, Types.DATE);
        declareParameter(new SqlOutParameter("titles", OracleTypes.CURSOR, new TitleMapper()));
        compile();
    }

    public Map&lt;String, Object&gt; execute(Date cutoffDate) {
        Map&lt;String, Object&gt; inputs = new HashMap&lt;String, Object&gt;();
        inputs.put(CUTOFF_DATE_PARAM, cutoffDate);
        return super.execute(inputs);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import java.sql.Types
import java.util.Date
import javax.sql.DataSource
import oracle.jdbc.OracleTypes
import org.springframework.jdbc.core.SqlOutParameter
import org.springframework.jdbc.core.SqlParameter
import org.springframework.jdbc.<code>object</code>.StoredProcedure

class TitlesAfterDateStoredProcedure(dataSource: DataSource) : StoredProcedure(dataSource, SPROC_NAME) {

    companion object {
        private const val SPROC_NAME = "TitlesAfterDate"
        private const val CUTOFF_DATE_PARAM = "cutoffDate"
    }

    init {
        declareParameter(SqlParameter(CUTOFF_DATE_PARAM, Types.DATE))
        declareParameter(SqlOutParameter("titles", OracleTypes.CURSOR, TitleMapper()))
        compile()
    }

    fun execute(cutoffDate: Date) = super.execute(
            mapOf&lt;String, Any&gt;(CUTOFF_DATE_PARAM to cutoffDate))
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jdbc-parameter-handling"><a class="anchor" href="#jdbc-parameter-handling"></a>3.8. Common Problems with Parameter and Data Value Handling</h3>
<div class="paragraph">
<p>Common problems with parameters and data values exist in the different approaches
provided by Spring Framework&#8217;s JDBC support. This section covers how to address them.</p>
</div>
<div class="sect3">
<h4 id="jdbc-type-information"><a class="anchor" href="#jdbc-type-information"></a>3.8.1. Providing SQL Type Information for Parameters</h4>
<div class="paragraph">
<p>Usually, Spring determines the SQL type of the parameters based on the type of parameter
passed in. It is possible to explicitly provide the SQL type to be used when setting
parameter values. This is sometimes necessary to correctly set <code>NULL</code> values.</p>
</div>
<div class="paragraph">
<p>You can provide SQL type information in several ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Many update and query methods of the <code>JdbcTemplate</code> take an additional parameter in
the form of an <code>int</code> array. This array is used to indicate the SQL type of the
corresponding parameter by using constant values from the <code>java.sql.Types</code> class. Provide
one entry for each parameter.</p>
</li>
<li>
<p>You can use the <code>SqlParameterValue</code> class to wrap the parameter value that needs this
additional information. To do so, create a new instance for each value and pass in the SQL type
and the parameter value in the constructor. You can also provide an optional scale
parameter for numeric values.</p>
</li>
<li>
<p>For methods that work with named parameters, you can use the <code>SqlParameterSource</code> classes,
<code>BeanPropertySqlParameterSource</code> or <code>MapSqlParameterSource</code>. They both have methods
for registering the SQL type for any of the named parameter values.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-lob"><a class="anchor" href="#jdbc-lob"></a>3.8.2. Handling BLOB and CLOB objects</h4>
<div class="paragraph">
<p>You can store images, other binary data, and large chunks of text in the database. These
large objects are called BLOBs (Binary Large OBject) for binary data and CLOBs (Character
Large OBject) for character data. In Spring, you can handle these large objects by using
the <code>JdbcTemplate</code> directly and also when using the higher abstractions provided by RDBMS
Objects and the <code>SimpleJdbc</code> classes. All of these approaches use an implementation of
the <code>LobHandler</code> interface for the actual management of the LOB (Large OBject) data.
<code>LobHandler</code> provides access to a <code>LobCreator</code> class, through the <code>getLobCreator</code> method,
that is used for creating new LOB objects to be inserted.</p>
</div>
<div class="paragraph">
<p><code>LobCreator</code> and <code>LobHandler</code> provide the following support for LOB input and output:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>BLOB</p>
<div class="ulist">
<ul>
<li>
<p><code>byte[]</code>: <code>getBlobAsBytes</code> and <code>setBlobAsBytes</code></p>
</li>
<li>
<p><code>InputStream</code>: <code>getBlobAsBinaryStream</code> and <code>setBlobAsBinaryStream</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>CLOB</p>
<div class="ulist">
<ul>
<li>
<p><code>String</code>: <code>getClobAsString</code> and <code>setClobAsString</code></p>
</li>
<li>
<p><code>InputStream</code>: <code>getClobAsAsciiStream</code> and <code>setClobAsAsciiStream</code></p>
</li>
<li>
<p><code>Reader</code>: <code>getClobAsCharacterStream</code> and <code>setClobAsCharacterStream</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The next example shows how to create and insert a BLOB. Later we show how to read
it back from the database.</p>
</div>
<div class="paragraph">
<p>This example uses a <code>JdbcTemplate</code> and an implementation of the
<code>AbstractLobCreatingPreparedStatementCallback</code>. It implements one method,
<code>setValues</code>. This method provides a <code>LobCreator</code> that we use to set the values for the
LOB columns in your SQL insert statement.</p>
</div>
<div class="paragraph">
<p>For this example, we assume that there is a variable, <code>lobHandler</code>, that is already
set to an instance of a <code>DefaultLobHandler</code>. You typically set this value through
dependency injection.</p>
</div>
<div class="paragraph">
<p>The following example shows how to create and insert a BLOB:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">final File blobIn = new File("spring2004.jpg");
final InputStream blobIs = new FileInputStream(blobIn);
final File clobIn = new File("large.txt");
final InputStream clobIs = new FileInputStream(clobIn);
final InputStreamReader clobReader = new InputStreamReader(clobIs);

jdbcTemplate.execute(
    "INSERT INTO lob_table (id, a_clob, a_blob) VALUES (?, ?, ?)",
    new AbstractLobCreatingPreparedStatementCallback(lobHandler) {  <i class="conum" data-value="1"></i><b>(1)</b>
        protected void setValues(PreparedStatement ps, LobCreator lobCreator) throws SQLException {
            ps.setLong(1, 1L);
            lobCreator.setClobAsCharacterStream(ps, 2, clobReader, (int)clobIn.length());  <i class="conum" data-value="2"></i><b>(2)</b>
            lobCreator.setBlobAsBinaryStream(ps, 3, blobIs, (int)blobIn.length());  <i class="conum" data-value="3"></i><b>(3)</b>
        }
    }
);

blobIs.close();
clobReader.close();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Pass in the <code>lobHandler</code> that (in this example) is a plain <code>DefaultLobHandler</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Using the method <code>setClobAsCharacterStream</code> to pass in the contents of the CLOB.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Using the method <code>setBlobAsBinaryStream</code> to pass in the contents of the BLOB.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val blobIn = File("spring2004.jpg")
val blobIs = FileInputStream(blobIn)
val clobIn = File("large.txt")
val clobIs = FileInputStream(clobIn)
val clobReader = InputStreamReader(clobIs)

jdbcTemplate.execute(
        "INSERT INTO lob_table (id, a_clob, a_blob) VALUES (?, ?, ?)",
        object: AbstractLobCreatingPreparedStatementCallback(lobHandler) {  <i class="conum" data-value="1"></i><b>(1)</b>
            override fun setValues(ps: PreparedStatement, lobCreator: LobCreator) {
                ps.setLong(1, 1L)
                lobCreator.setClobAsCharacterStream(ps, 2, clobReader, clobIn.length().toInt())  <i class="conum" data-value="2"></i><b>(2)</b>
                lobCreator.setBlobAsBinaryStream(ps, 3, blobIs, blobIn.length().toInt())  <i class="conum" data-value="3"></i><b>(3)</b>
            }
        }
)
blobIs.close()
clobReader.close()</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Pass in the <code>lobHandler</code> that (in this example) is a plain <code>DefaultLobHandler</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Using the method <code>setClobAsCharacterStream</code> to pass in the contents of the CLOB.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Using the method <code>setBlobAsBinaryStream</code> to pass in the contents of the BLOB.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you invoke the <code>setBlobAsBinaryStream</code>, <code>setClobAsAsciiStream</code>, or
<code>setClobAsCharacterStream</code> method on the <code>LobCreator</code> returned from
<code>DefaultLobHandler.getLobCreator()</code>, you can optionally specify a negative value for the
<code>contentLength</code> argument. If the specified content length is negative, the
<code>DefaultLobHandler</code> uses the JDBC 4.0 variants of the set-stream methods without a
length parameter. Otherwise, it passes the specified length on to the driver.</p>
</div>
<div class="paragraph">
<p>See the documentation for the JDBC driver you use to verify that it supports streaming a
LOB without providing the content length.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now it is time to read the LOB data from the database. Again, you use a <code>JdbcTemplate</code>
with the same instance variable <code>lobHandler</code> and a reference to a <code>DefaultLobHandler</code>.
The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">List&lt;Map&lt;String, Object&gt;&gt; l = jdbcTemplate.query("select id, a_clob, a_blob from lob_table",
    new RowMapper&lt;Map&lt;String, Object&gt;&gt;() {
        public Map&lt;String, Object&gt; mapRow(ResultSet rs, int i) throws SQLException {
            Map&lt;String, Object&gt; results = new HashMap&lt;String, Object&gt;();
            String clobText = lobHandler.getClobAsString(rs, "a_clob");  <i class="conum" data-value="1"></i><b>(1)</b>
            results.put("CLOB", clobText);
            byte[] blobBytes = lobHandler.getBlobAsBytes(rs, "a_blob");  <i class="conum" data-value="2"></i><b>(2)</b>
            results.put("BLOB", blobBytes);
            return results;
        }
    });</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using the method <code>getClobAsString</code> to retrieve the contents of the CLOB.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Using the method <code>getBlobAsBytes</code> to retrieve the contents of the BLOB.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val l = jdbcTemplate.query("select id, a_clob, a_blob from lob_table") { rs, _ -&gt;
    val clobText = lobHandler.getClobAsString(rs, "a_clob")  <i class="conum" data-value="1"></i><b>(1)</b>
    val blobBytes = lobHandler.getBlobAsBytes(rs, "a_blob")  <i class="conum" data-value="2"></i><b>(2)</b>
    mapOf("CLOB" to clobText, "BLOB" to blobBytes)
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using the method <code>getClobAsString</code> to retrieve the contents of the CLOB.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Using the method <code>getBlobAsBytes</code> to retrieve the contents of the BLOB.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-in-clause"><a class="anchor" href="#jdbc-in-clause"></a>3.8.3. Passing in Lists of Values for IN Clause</h4>
<div class="paragraph">
<p>The SQL standard allows for selecting rows based on an expression that includes a
variable list of values. A typical example would be <code>select * from T_ACTOR where id in
(1, 2, 3)</code>. This variable list is not directly supported for prepared statements by the
JDBC standard. You cannot declare a variable number of placeholders. You need a number
of variations with the desired number of placeholders prepared, or you need to generate
the SQL string dynamically once you know how many placeholders are required. The named
parameter support provided in the <code>NamedParameterJdbcTemplate</code> and <code>JdbcTemplate</code> takes
the latter approach. You can pass in the values as a <code>java.util.List</code> of primitive objects. This
list is used to insert the required placeholders and pass in the values during
statement execution.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Be careful when passing in many values. The JDBC standard does not guarantee that you
can use more than 100 values for an <code>in</code> expression list. Various databases exceed this
number, but they usually have a hard limit for how many values are allowed. For example, Oracle&#8217;s
limit is 1000.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In addition to the primitive values in the value list, you can create a <code>java.util.List</code>
of object arrays. This list can support multiple expressions being defined for the <code>in</code>
clause, such as <code>select * from T_ACTOR where (id, last_name) in ((1, 'Johnson'), (2,
'Harrop'\))</code>. This, of course, requires that your database supports this syntax.</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-complex-types"><a class="anchor" href="#jdbc-complex-types"></a>3.8.4. Handling Complex Types for Stored Procedure Calls</h4>
<div class="paragraph">
<p>When you call stored procedures, you can sometimes use complex types specific to the
database. To accommodate these types, Spring provides a <code>SqlReturnType</code> for handling
them when they are returned from the stored procedure call and <code>SqlTypeValue</code> when they
are passed in as a parameter to the stored procedure.</p>
</div>
<div class="paragraph">
<p>The <code>SqlReturnType</code> interface has a single method (named <code>getTypeValue</code>) that must be
implemented. This interface is used as part of the declaration of an <code>SqlOutParameter</code>.
The following example shows returning the value of an Oracle <code>STRUCT</code> object of the user
declared type <code>ITEM_TYPE</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class TestItemStoredProcedure extends StoredProcedure {

    public TestItemStoredProcedure(DataSource dataSource) {
        // ...
        declareParameter(new SqlOutParameter("item", OracleTypes.STRUCT, "ITEM_TYPE",
            (CallableStatement cs, int colIndx, int sqlType, String typeName) -&gt; {
                STRUCT struct = (STRUCT) cs.getObject(colIndx);
                Object[] attr = struct.getAttributes();
                TestItem item = new TestItem();
                item.setId(((Number) attr[0]).longValue());
                item.setDescription((String) attr[1]);
                item.setExpirationDate((java.util.Date) attr[2]);
                return item;
            }));
        // ...
    }</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class TestItemStoredProcedure(dataSource: DataSource) : StoredProcedure() {

    init {
        // ...
        declareParameter(SqlOutParameter("item", OracleTypes.STRUCT, "ITEM_TYPE") { cs, colIndx, sqlType, typeName -&gt;
            val struct = cs.getObject(colIndx) as STRUCT
            val attr = struct.getAttributes()
            TestItem((attr[0] as Long, attr[1] as String, attr[2] as Date)
        })
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use <code>SqlTypeValue</code> to pass the value of a Java object (such as <code>TestItem</code>) to a
stored procedure. The <code>SqlTypeValue</code> interface has a single method (named
<code>createTypeValue</code>) that you must implement. The active connection is passed in, and you
can use it to create database-specific objects, such as <code>StructDescriptor</code> instances
or <code>ArrayDescriptor</code> instances. The following example creates a <code>StructDescriptor</code> instance:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">final TestItem testItem = new TestItem(123L, "A test item",
        new SimpleDateFormat("yyyy-M-d").parse("2010-12-31"));

SqlTypeValue value = new AbstractSqlTypeValue() {
    protected Object createTypeValue(Connection conn, int sqlType, String typeName) throws SQLException {
        StructDescriptor itemDescriptor = new StructDescriptor(typeName, conn);
        Struct item = new STRUCT(itemDescriptor, conn,
        new Object[] {
            testItem.getId(),
            testItem.getDescription(),
            new java.sql.Date(testItem.getExpirationDate().getTime())
        });
        return item;
    }
};</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val (id, description, expirationDate) = TestItem(123L, "A test item",
        SimpleDateFormat("yyyy-M-d").parse("2010-12-31"))

val value = object : AbstractSqlTypeValue() {
    override fun createTypeValue(conn: Connection, sqlType: Int, typeName: String?): Any {
        val itemDescriptor = StructDescriptor(typeName, conn)
        return STRUCT(itemDescriptor, conn,
                arrayOf(id, description, java.sql.Date(expirationDate.time)))
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can now add this <code>SqlTypeValue</code> to the <code>Map</code> that contains the input parameters for the
<code>execute</code> call of the stored procedure.</p>
</div>
<div class="paragraph">
<p>Another use for the <code>SqlTypeValue</code> is passing in an array of values to an Oracle stored
procedure. Oracle has its own internal <code>ARRAY</code> class that must be used in this case, and
you can use the <code>SqlTypeValue</code> to create an instance of the Oracle <code>ARRAY</code> and populate
it with values from the Java <code>ARRAY</code>, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">final Long[] ids = new Long[] {1L, 2L};

SqlTypeValue value = new AbstractSqlTypeValue() {
    protected Object createTypeValue(Connection conn, int sqlType, String typeName) throws SQLException {
        ArrayDescriptor arrayDescriptor = new ArrayDescriptor(typeName, conn);
        ARRAY idArray = new ARRAY(arrayDescriptor, conn, ids);
        return idArray;
    }
};</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class TestItemStoredProcedure(dataSource: DataSource) : StoredProcedure() {

    init {
        val ids = arrayOf(1L, 2L)
        val value = object : AbstractSqlTypeValue() {
            override fun createTypeValue(conn: Connection, sqlType: Int, typeName: String?): Any {
                val arrayDescriptor = ArrayDescriptor(typeName, conn)
                return ARRAY(arrayDescriptor, conn, ids)
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jdbc-embedded-database-support"><a class="anchor" href="#jdbc-embedded-database-support"></a>3.9. Embedded Database Support</h3>
<div class="paragraph">
<p>The <code>org.springframework.jdbc.datasource.embedded</code> package provides support for embedded
Java database engines. Support for <a href="http://www.hsqldb.org">HSQL</a>,
<a href="https://www.h2database.com">H2</a>, and <a href="https://db.apache.org/derby">Derby</a> is provided
natively. You can also use an extensible API to plug in new embedded database types and
<code>DataSource</code> implementations.</p>
</div>
<div class="sect3">
<h4 id="jdbc-why-embedded-database"><a class="anchor" href="#jdbc-why-embedded-database"></a>3.9.1. Why Use an Embedded Database?</h4>
<div class="paragraph">
<p>An embedded database can be useful during the development phase of a project because of its
lightweight nature. Benefits include ease of configuration, quick startup time,
testability, and the ability to rapidly evolve your SQL during development.</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-embedded-database-xml"><a class="anchor" href="#jdbc-embedded-database-xml"></a>3.9.2. Creating an Embedded Database by Using Spring XML</h4>
<div class="paragraph">
<p>If you want to expose an embedded database instance as a bean in a Spring
<code>ApplicationContext</code>, you can use the <code>embedded-database</code> tag in the <code>spring-jdbc</code> namespace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;jdbc:embedded-database id="dataSource" generate-name="true"&gt;
    &lt;jdbc:script location="classpath:schema.sql"/&gt;
    &lt;jdbc:script location="classpath:test-data.sql"/&gt;
&lt;/jdbc:embedded-database&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding configuration creates an embedded HSQL database that is populated with SQL from
the <code>schema.sql</code> and <code>test-data.sql</code> resources in the root of the classpath. In addition, as
a best practice, the embedded database is assigned a uniquely generated name. The
embedded database is made available to the Spring container as a bean of type
<code>javax.sql.DataSource</code> that can then be injected into data access objects as needed.</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-embedded-database-java"><a class="anchor" href="#jdbc-embedded-database-java"></a>3.9.3. Creating an Embedded Database Programmatically</h4>
<div class="paragraph">
<p>The <code>EmbeddedDatabaseBuilder</code> class provides a fluent API for constructing an embedded
database programmatically. You can use this when you need to create an embedded database in a
stand-alone environment or in a stand-alone integration test, as in the following example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">EmbeddedDatabase db = new EmbeddedDatabaseBuilder()
        .generateUniqueName(true)
        .setType(H2)
        .setScriptEncoding("UTF-8")
        .ignoreFailedDrops(true)
        .addScript("schema.sql")
        .addScripts("user_data.sql", "country_data.sql")
        .build();

// perform actions against the db (EmbeddedDatabase extends javax.sql.DataSource)

db.shutdown()</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val db = EmbeddedDatabaseBuilder()
        .generateUniqueName(true)
        .setType(H2)
        .setScriptEncoding("UTF-8")
        .ignoreFailedDrops(true)
        .addScript("schema.sql")
        .addScripts("user_data.sql", "country_data.sql")
        .build()

// perform actions against the db (EmbeddedDatabase extends javax.sql.DataSource)

db.shutdown()</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the <a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/jdbc/datasource/embedded/EmbeddedDatabaseBuilder.html">javadoc for <code>EmbeddedDatabaseBuilder</code></a>
for further details on all supported options.</p>
</div>
<div class="paragraph">
<p>You can also use the <code>EmbeddedDatabaseBuilder</code> to create an embedded database by using Java
configuration, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
public class DataSourceConfig {

    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
                .generateUniqueName(true)
                .setType(H2)
                .setScriptEncoding("UTF-8")
                .ignoreFailedDrops(true)
                .addScript("schema.sql")
                .addScripts("user_data.sql", "country_data.sql")
                .build();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
class DataSourceConfig {

    @Bean
    fun dataSource(): DataSource {
        return EmbeddedDatabaseBuilder()
                .generateUniqueName(true)
                .setType(H2)
                .setScriptEncoding("UTF-8")
                .ignoreFailedDrops(true)
                .addScript("schema.sql")
                .addScripts("user_data.sql", "country_data.sql")
                .build()
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-embedded-database-types"><a class="anchor" href="#jdbc-embedded-database-types"></a>3.9.4. Selecting the Embedded Database Type</h4>
<div class="paragraph">
<p>This section covers how to select one of the three embedded databases that Spring
supports. It includes the following topics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#jdbc-embedded-database-using-HSQL">Using HSQL</a></p>
</li>
<li>
<p><a href="#jdbc-embedded-database-using-H2">Using H2</a></p>
</li>
<li>
<p><a href="#jdbc-embedded-database-using-Derby">Using Derby</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="jdbc-embedded-database-using-HSQL"><a class="anchor" href="#jdbc-embedded-database-using-HSQL"></a>Using HSQL</h5>
<div class="paragraph">
<p>Spring supports HSQL 1.8.0 and above. HSQL is the default embedded database if no type is
explicitly specified. To specify HSQL explicitly, set the <code>type</code> attribute of the
<code>embedded-database</code> tag to <code>HSQL</code>. If you use the builder API, call the
<code>setType(EmbeddedDatabaseType)</code> method with <code>EmbeddedDatabaseType.HSQL</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="jdbc-embedded-database-using-H2"><a class="anchor" href="#jdbc-embedded-database-using-H2"></a>Using H2</h5>
<div class="paragraph">
<p>Spring supports the H2 database. To enable H2, set the <code>type</code> attribute of the
<code>embedded-database</code> tag to <code>H2</code>. If you use the builder API, call the
<code>setType(EmbeddedDatabaseType)</code> method with <code>EmbeddedDatabaseType.H2</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="jdbc-embedded-database-using-Derby"><a class="anchor" href="#jdbc-embedded-database-using-Derby"></a>Using Derby</h5>
<div class="paragraph">
<p>Spring supports Apache Derby 10.5 and above. To enable Derby, set the <code>type</code>
attribute of the <code>embedded-database</code> tag to <code>DERBY</code>. If you use the builder API,
call the <code>setType(EmbeddedDatabaseType)</code> method with <code>EmbeddedDatabaseType.DERBY</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-embedded-database-dao-testing"><a class="anchor" href="#jdbc-embedded-database-dao-testing"></a>3.9.5. Testing Data Access Logic with an Embedded Database</h4>
<div class="paragraph">
<p>Embedded databases provide a lightweight way to test data access code. The next example is a
data access integration test template that uses an embedded database. Using such a template
can be useful for one-offs when the embedded database does not need to be reused across test
classes. However, if you wish to create an embedded database that is shared within a test suite,
consider using the <a href="testing.html#testcontext-framework">Spring TestContext Framework</a> and
configuring the embedded database as a bean in the Spring <code>ApplicationContext</code> as described
in <a href="#jdbc-embedded-database-xml">Creating an Embedded Database by Using Spring XML</a> and <a href="#jdbc-embedded-database-java">Creating an Embedded Database Programmatically</a>. The following listing
shows the test template:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class DataAccessIntegrationTestTemplate {

    private EmbeddedDatabase db;

    @BeforeEach
    public void setUp() {
        // creates an HSQL in-memory database populated from default scripts
        // classpath:schema.sql and classpath:data.sql
        db = new EmbeddedDatabaseBuilder()
                .generateUniqueName(true)
                .addDefaultScripts()
                .build();
    }

    @Test
    public void testDataAccess() {
        JdbcTemplate template = new JdbcTemplate(db);
        template.query( /* ... */ );
    }

    @AfterEach
    public void tearDown() {
        db.shutdown();
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class DataAccessIntegrationTestTemplate {

    private lateinit var db: EmbeddedDatabase

    @BeforeEach
    fun setUp() {
        // creates an HSQL in-memory database populated from default scripts
        // classpath:schema.sql and classpath:data.sql
        db = EmbeddedDatabaseBuilder()
                .generateUniqueName(true)
                .addDefaultScripts()
                .build()
    }

    @Test
    fun testDataAccess() {
        val template = JdbcTemplate(db)
        template.query( /* ... */)
    }

    @AfterEach
    fun tearDown() {
        db.shutdown()
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-embedded-database-unique-names"><a class="anchor" href="#jdbc-embedded-database-unique-names"></a>3.9.6. Generating Unique Names for Embedded Databases</h4>
<div class="paragraph">
<p>Development teams often encounter errors with embedded databases if their test suite
inadvertently attempts to recreate additional instances of the same database. This can
happen quite easily if an XML configuration file or <code>@Configuration</code> class is responsible
for creating an embedded database and the corresponding configuration is then reused
across multiple testing scenarios within the same test suite (that is, within the same JVM
process)&#8201;&#8212;&#8201;for example, integration tests against embedded databases whose
<code>ApplicationContext</code> configuration differs only with regard to which bean definition
profiles are active.</p>
</div>
<div class="paragraph">
<p>The root cause of such errors is the fact that Spring&#8217;s <code>EmbeddedDatabaseFactory</code> (used
internally by both the <code>&lt;jdbc:embedded-database&gt;</code> XML namespace element and the
<code>EmbeddedDatabaseBuilder</code> for Java configuration) sets the name of the embedded database to
<code>testdb</code> if not otherwise specified. For the case of <code>&lt;jdbc:embedded-database&gt;</code>, the
embedded database is typically assigned a name equal to the bean&#8217;s <code>id</code> (often,
something like <code>dataSource</code>). Thus, subsequent attempts to create an embedded database
do not result in a new database. Instead, the same JDBC connection URL is reused,
and attempts to create a new embedded database actually point to an existing
embedded database created from the same configuration.</p>
</div>
<div class="paragraph">
<p>To address this common issue, Spring Framework 4.2 provides support for generating
unique names for embedded databases. To enable the use of generated names, use one of
the following options.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>EmbeddedDatabaseFactory.setGenerateUniqueDatabaseName()</code></p>
</li>
<li>
<p><code>EmbeddedDatabaseBuilder.generateUniqueName()</code></p>
</li>
<li>
<p><code>&lt;jdbc:embedded-database generate-name="true" &#8230;&#8203; &gt;</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-embedded-database-extension"><a class="anchor" href="#jdbc-embedded-database-extension"></a>3.9.7. Extending the Embedded Database Support</h4>
<div class="paragraph">
<p>You can extend Spring JDBC embedded database support in two ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Implement <code>EmbeddedDatabaseConfigurer</code> to support a new embedded database type.</p>
</li>
<li>
<p>Implement <code>DataSourceFactory</code> to support a new <code>DataSource</code> implementation, such as a
connection pool to manage embedded database connections.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We encourage you to contribute extensions to the Spring community at
<a href="https://github.com/spring-projects/spring-framework/issues">GitHub Issues</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jdbc-initializing-datasource"><a class="anchor" href="#jdbc-initializing-datasource"></a>3.10. Initializing a <code>DataSource</code></h3>
<div class="paragraph">
<p>The <code>org.springframework.jdbc.datasource.init</code> package provides support for initializing
an existing <code>DataSource</code>. The embedded database support provides one option for creating
and initializing a <code>DataSource</code> for an application. However, you may sometimes need to initialize
an instance that runs on a server somewhere.</p>
</div>
<div class="sect3">
<h4 id="jdbc-initializing-datasource-xml"><a class="anchor" href="#jdbc-initializing-datasource-xml"></a>3.10.1. Initializing a Database by Using Spring XML</h4>
<div class="paragraph">
<p>If you want to initialize a database and you can provide a reference to a <code>DataSource</code>
bean, you can use the <code>initialize-database</code> tag in the <code>spring-jdbc</code> namespace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;jdbc:initialize-database data-source="dataSource"&gt;
    &lt;jdbc:script location="classpath:com/foo/sql/db-schema.sql"/&gt;
    &lt;jdbc:script location="classpath:com/foo/sql/db-test-data.sql"/&gt;
&lt;/jdbc:initialize-database&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding example runs the two specified scripts against the database. The first
script creates a schema, and the second populates tables with a test data set. The script
locations can also be patterns with wildcards in the usual Ant style used for resources
in Spring (for example,
<code>classpath*:/com/foo/**/sql/*-data.sql</code>). If you use a
pattern, the scripts are run in the lexical order of their URL or filename.</p>
</div>
<div class="paragraph">
<p>The default behavior of the database initializer is to unconditionally run the provided
scripts. This may not always be what you want&#8201;&#8212;&#8201;for instance, if you run
the scripts against a database that already has test data in it. The likelihood
of accidentally deleting data is reduced by following the common pattern (shown earlier)
of creating the tables first and then inserting the data. The first step fails if
the tables already exist.</p>
</div>
<div class="paragraph">
<p>However, to gain more control over the creation and deletion of existing data, the XML
namespace provides a few additional options. The first is a flag to switch the
initialization on and off. You can set this according to the environment (such as pulling a
boolean value from system properties or from an environment bean). The following example gets a value from a system property:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;jdbc:initialize-database data-source="dataSource"
    enabled="#{systemProperties.INITIALIZE_DATABASE}"&gt; <i class="conum" data-value="1"></i><b>(1)</b>
    &lt;jdbc:script location="..."/&gt;
&lt;/jdbc:initialize-database&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Get the value for <code>enabled</code> from a system property called <code>INITIALIZE_DATABASE</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The second option to control what happens with existing data is to be more tolerant of
failures. To this end, you can control the ability of the initializer to ignore certain
errors in the SQL it runs from the scripts, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;jdbc:initialize-database data-source="dataSource" ignore-failures="DROPS"&gt;
    &lt;jdbc:script location="..."/&gt;
&lt;/jdbc:initialize-database&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, we are saying that we expect that, sometimes, the scripts are run
against an empty database, and there are some <code>DROP</code> statements in the scripts that
would, therefore, fail. So failed SQL <code>DROP</code> statements will be ignored, but other failures
will cause an exception. This is useful if your SQL dialect doesn&#8217;t support <code>DROP &#8230;&#8203; IF
EXISTS</code> (or similar) but you want to unconditionally remove all test data before
re-creating it. In that case the first script is usually a set of <code>DROP</code> statements,
followed by a set of <code>CREATE</code> statements.</p>
</div>
<div class="paragraph">
<p>The <code>ignore-failures</code> option can be set to <code>NONE</code> (the default), <code>DROPS</code> (ignore failed
drops), or <code>ALL</code> (ignore all failures).</p>
</div>
<div class="paragraph">
<p>Each statement should be separated by <code>;</code> or a new line if the <code>;</code> character is not
present at all in the script. You can control that globally or script by script, as the
following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;jdbc:initialize-database data-source="dataSource" separator="@@"&gt; <i class="conum" data-value="1"></i><b>(1)</b>
    &lt;jdbc:script location="classpath:com/myapp/sql/db-schema.sql" separator=";"/&gt; <i class="conum" data-value="2"></i><b>(2)</b>
    &lt;jdbc:script location="classpath:com/myapp/sql/db-test-data-1.sql"/&gt;
    &lt;jdbc:script location="classpath:com/myapp/sql/db-test-data-2.sql"/&gt;
&lt;/jdbc:initialize-database&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Set the separator scripts to <code>@@</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Set the separator for <code>db-schema.sql</code> to <code>;</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In this example, the two <code>test-data</code> scripts use <code>@@</code> as statement separator and only
the <code>db-schema.sql</code> uses <code>;</code>. This configuration specifies that the default separator
is <code>@@</code> and overrides that default for the <code>db-schema</code> script.</p>
</div>
<div class="paragraph">
<p>If you need more control than you get from the XML namespace, you can use the
<code>DataSourceInitializer</code> directly and define it as a component in your application.</p>
</div>
<div class="sect4">
<h5 id="jdbc-client-component-initialization"><a class="anchor" href="#jdbc-client-component-initialization"></a>Initialization of Other Components that Depend on the Database</h5>
<div class="paragraph">
<p>A large class of applications (those that do not use the database until after the Spring context has
started) can use the database initializer with no further
complications. If your application is not one of those, you might need to read the rest
of this section.</p>
</div>
<div class="paragraph">
<p>The database initializer depends on a <code>DataSource</code> instance and runs the scripts
provided in its initialization callback (analogous to an <code>init-method</code> in an XML bean
definition, a <code>@PostConstruct</code> method in a component, or the <code>afterPropertiesSet()</code>
method in a component that implements <code>InitializingBean</code>). If other beans depend on the
same data source and use the data source in an initialization callback, there
might be a problem because the data has not yet been initialized. A common example of
this is a cache that initializes eagerly and loads data from the database on application
startup.</p>
</div>
<div class="paragraph">
<p>To get around this issue, you have two options: change your cache initialization strategy
to a later phase or ensure that the database initializer is initialized first.</p>
</div>
<div class="paragraph">
<p>Changing your cache initialization strategy might be easy if the application is in your control and not otherwise.
Some suggestions for how to implement this include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Make the cache initialize lazily on first usage, which improves application startup
time.</p>
</li>
<li>
<p>Have your cache or a separate component that initializes the cache implement
<code>Lifecycle</code> or <code>SmartLifecycle</code>. When the application context starts, you can
automatically start a <code>SmartLifecycle</code> by setting its <code>autoStartup</code> flag, and you can
manually start a <code>Lifecycle</code> by calling <code>ConfigurableApplicationContext.start()</code>
on the enclosing context.</p>
</li>
<li>
<p>Use a Spring <code>ApplicationEvent</code> or similar custom observer mechanism to trigger the
cache initialization. <code>ContextRefreshedEvent</code> is always published by the context when
it is ready for use (after all beans have been initialized), so that is often a useful
hook (this is how the <code>SmartLifecycle</code> works by default).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ensuring that the database initializer is initialized first can also be easy. Some suggestions on how to implement this include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Rely on the default behavior of the Spring <code>BeanFactory</code>, which is that beans are
initialized in registration order. You can easily arrange that by adopting the common
practice of a set of <code>&lt;import/&gt;</code> elements in XML configuration that order your
application modules and ensuring that the database and database initialization are
listed first.</p>
</li>
<li>
<p>Separate the <code>DataSource</code> and the business components that use it and control their
startup order by putting them in separate <code>ApplicationContext</code> instances (for example, the
parent context contains the <code>DataSource</code>, and the child context contains the business
components). This structure is common in Spring web applications but can be more
generally applied.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="r2dbc"><a class="anchor" href="#r2dbc"></a>4. Data Access with R2DBC</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://r2dbc.io">R2DBC</a> ("Reactive Relational Database Connectivity") is a community-driven
specification effort to standardize access to SQL databases using reactive patterns.</p>
</div>
<div class="sect2">
<h3 id="r2dbc-packages"><a class="anchor" href="#r2dbc-packages"></a>4.1. Package Hierarchy</h3>
<div class="paragraph">
<p>The Spring Framework&#8217;s R2DBC abstraction framework consists of two different packages:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>core</code>: The <code>org.springframework.r2dbc.core</code> package contains the <code>DatabaseClient</code>
class plus a variety of related classes. See <a href="#r2dbc-core">Using the R2DBC Core Classes to Control Basic R2DBC Processing and Error Handling</a>.</p>
</li>
<li>
<p><code>connection</code>: The <code>org.springframework.r2dbc.connection</code> package contains a utility class
for easy <code>ConnectionFactory</code> access and various simple <code>ConnectionFactory</code> implementations
that you can use for testing and running unmodified R2DBC. See <a href="#r2dbc-connections">Controlling Database Connections</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="r2dbc-core"><a class="anchor" href="#r2dbc-core"></a>4.2. Using the R2DBC Core Classes to Control Basic R2DBC Processing and Error Handling</h3>
<div class="paragraph">
<p>This section covers how to use the R2DBC core classes to control basic R2DBC processing,
including error handling. It includes the following topics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#r2dbc-DatabaseClient">Using <code>DatabaseClient</code></a></p>
</li>
<li>
<p><a href="#r2dbc-DatabaseClient-examples-statement">Executing Statements</a></p>
</li>
<li>
<p><a href="#r2dbc-DatabaseClient-examples-query">Querying (<code>SELECT</code>)</a></p>
</li>
<li>
<p><a href="#r2dbc-DatabaseClient-examples-update">Updating (<code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code>) with <code>DatabaseClient</code></a></p>
</li>
<li>
<p><a href="#r2dbc-DatabaseClient-filter">Statement Filters</a></p>
</li>
<li>
<p><a href="#r2dbc-auto-generated-keys">Retrieving Auto-generated Keys</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="r2dbc-DatabaseClient"><a class="anchor" href="#r2dbc-DatabaseClient"></a>4.2.1. Using <code>DatabaseClient</code></h4>
<div class="paragraph">
<p><code>DatabaseClient</code> is the central class in the R2DBC core package. It handles the
creation and release of resources, which helps to avoid common errors, such as
forgetting to close the connection. It performs the basic tasks of the core R2DBC
workflow (such as statement creation and execution), leaving application code to provide
SQL and extract results. The <code>DatabaseClient</code> class:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Runs SQL queries</p>
</li>
<li>
<p>Update statements and stored procedure calls</p>
</li>
<li>
<p>Performs iteration over <code>Result</code> instances</p>
</li>
<li>
<p>Catches R2DBC exceptions and translates them to the generic, more informative, exception
hierarchy defined in the <code>org.springframework.dao</code> package. (See <a href="#dao-exceptions">Consistent Exception Hierarchy</a>.)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The client has a functional, fluent API using reactive types for declarative composition.</p>
</div>
<div class="paragraph">
<p>When you use the <code>DatabaseClient</code> for your code, you need only to implement
<code>java.util.function</code> interfaces, giving them a clearly defined contract.
Given a <code>Connection</code> provided by the <code>DatabaseClient</code> class, a <code>Function</code>
callback creates a <code>Publisher</code>. The same is true for mapping functions that
extract a <code>Row</code> result.</p>
</div>
<div class="paragraph">
<p>You can use <code>DatabaseClient</code> within a DAO implementation through direct instantiation
with a <code>ConnectionFactory</code> reference, or you can configure it in a Spring IoC container
and give it to DAOs as a bean reference.</p>
</div>
<div class="paragraph">
<p>The simplest way to create a <code>DatabaseClient</code> object is through a static factory method, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">DatabaseClient client = DatabaseClient.create(connectionFactory);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val client = DatabaseClient.create(connectionFactory)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>ConnectionFactory</code> should always be configured as a bean in the Spring IoC
container.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The preceding method creates a <code>DatabaseClient</code> with default settings.</p>
</div>
<div class="paragraph">
<p>You can also obtain a <code>Builder</code> instance from <code>DatabaseClient.builder()</code>.
You can customize the client by calling the following methods:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>.bindMarkers()</code>: Supply a specific <code>BindMarkersFactory</code> to configure named
parameter to database bind marker translation.</p>
</li>
<li>
<p><code>.executeFunction()</code>: Set the <code>ExecuteFunction</code> how <code>Statement</code> objects get
run.</p>
</li>
<li>
<p><code>.namedParameters(false)</code>: Disable named parameter expansion. Enabled by default.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Dialects are resolved by <a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/r2dbc/core/binding/BindMarkersFactoryResolver.html"><code>BindMarkersFactoryResolver</code></a>
 from a <code>ConnectionFactory</code>, typically by inspecting <code>ConnectionFactoryMetadata</code>.
<br>
You can let Spring auto-discover your <code>BindMarkersFactory</code> by registering a
class that implements <code>org.springframework.r2dbc.core.binding.BindMarkersFactoryResolver$BindMarkerFactoryProvider</code>
through <code>META-INF/spring.factories</code>.
<code>BindMarkersFactoryResolver</code> discovers bind marker provider implementations from
the class path using Spring&#8217;s <code>SpringFactoriesLoader</code>.
<br>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Currently supported databases are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>H2</p>
</li>
<li>
<p>MariaDB</p>
</li>
<li>
<p>Microsoft SQL Server</p>
</li>
<li>
<p>MySQL</p>
</li>
<li>
<p>Postgres</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All SQL issued by this class is logged at the <code>DEBUG</code> level under the category
corresponding to the fully qualified class name of the client instance (typically
<code>DefaultDatabaseClient</code>). Additionally, each execution registers a checkpoint in
the reactive sequence to aid debugging.</p>
</div>
<div class="paragraph">
<p>The following sections provide some examples of <code>DatabaseClient</code> usage. These examples
are not an exhaustive list of all of the functionality exposed by the <code>DatabaseClient</code>.
See the attendant <a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/r2dbc/core/DatabaseClient.html">javadoc</a> for that.</p>
</div>
<div class="sect4">
<h5 id="r2dbc-DatabaseClient-examples-statement"><a class="anchor" href="#r2dbc-DatabaseClient-examples-statement"></a>Executing Statements</h5>
<div class="paragraph">
<p><code>DatabaseClient</code> provides the basic functionality of running a statement.
The following example shows what you need to include for minimal but fully functional
code that creates a new table:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Mono&lt;Void&gt; completion = client.sql("CREATE TABLE person (id VARCHAR(255) PRIMARY KEY, name VARCHAR(255), age INTEGER);")
        .then();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">client.sql("CREATE TABLE person (id VARCHAR(255) PRIMARY KEY, name VARCHAR(255), age INTEGER);")
        .await()</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>DatabaseClient</code> is designed for convenient, fluent usage.
It exposes intermediate, continuation, and terminal methods at each stage of the
execution specification. The preceding example above uses <code>then()</code> to return a completion
<code>Publisher</code> that completes as soon as the query (or queries, if the SQL query contains
multiple statements) completes.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>execute()</code> accepts either the SQL query string or a query <code>Supplier&lt;String&gt;</code>
to defer the actual query creation until execution.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="r2dbc-DatabaseClient-examples-query"><a class="anchor" href="#r2dbc-DatabaseClient-examples-query"></a>Querying (<code>SELECT</code>)</h5>
<div class="paragraph">
<p>SQL queries can return values through <code>Row</code> objects or the number of affected rows.
<code>DatabaseClient</code> can return the number of updated rows or the rows themselves,
depending on the issued query.</p>
</div>
<div class="paragraph">
<p>The following query gets the <code>id</code> and <code>name</code> columns from a table:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Mono&lt;Map&lt;String, Object&gt;&gt; first = client.sql("SELECT id, name FROM person")
        .fetch().first();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val first = client.sql("SELECT id, name FROM person")
        .fetch().awaitSingle()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following query uses a bind variable:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Mono&lt;Map&lt;String, Object&gt;&gt; first = client.sql("SELECT id, name FROM person WHERE first_name = :fn")
        .bind("fn", "Joe")
        .fetch().first();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val first = client.sql("SELECT id, name FROM person WHERE WHERE first_name = :fn")
        .bind("fn", "Joe")
        .fetch().awaitSingle()</code></pre>
</div>
</div>
<div class="paragraph">
<p>You might have noticed the use of <code>fetch()</code> in the example above. <code>fetch()</code> is a
continuation operator that lets you specify how much data you want to consume.</p>
</div>
<div class="paragraph">
<p>Calling <code>first()</code> returns the first row from the result and discards remaining rows.
You can consume data with the following operators:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>first()</code> return the first row of the entire result. Its Kotlin Coroutine variant
is named <code>awaitSingle()</code> for non-nullable return values and <code>awaitSingleOrNull()</code>
if the value is optional.</p>
</li>
<li>
<p><code>one()</code> returns exactly one result and fails if the result contains more rows.
Using Kotlin Coroutines, <code>awaitOne()</code> for exactly one value or <code>awaitOneOrNull()</code>
if the value may be <code>null</code>.</p>
</li>
<li>
<p><code>all()</code> returns all rows of the result. When using Kotlin Coroutines, use <code>flow()</code>.</p>
</li>
<li>
<p><code>rowsUpdated()</code> returns the number of affected rows (<code>INSERT</code>/<code>UPDATE</code>/<code>DELETE</code>
count). Its Kotlin Coroutine variant is named <code>awaitRowsUpdated()</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Without specifying further mapping details, queries return tabular results
as <code>Map</code> whose keys are case-insensitive column names that map to their column value.</p>
</div>
<div class="paragraph">
<p>You can take control over result mapping by supplying a <code>Function&lt;Row, T&gt;</code> that gets
called for each <code>Row</code> so it can can return arbitrary values (singular values,
collections and maps, and objects).</p>
</div>
<div class="paragraph">
<p>The following example extracts the <code>id</code> column and emits its value:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux&lt;String&gt; names = client.sql("SELECT name FROM person")
        .map(row -&gt; row.get("id", String.class))
        .all();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val names = client.sql("SELECT name FROM person")
        .map{ row: Row -&gt; row.get("id", String.class) }
        .flow()</code></pre>
</div>
</div>
<div id="r2dbc-DatabaseClient-mapping-null" class="sidebarblock">
<div class="content">
<div class="title">What about <code>null</code>?</div>
<div class="paragraph">
<p>Relational database results can contain <code>null</code> values.
The Reactive Streams specification forbids the emission of <code>null</code> values.
That requirement mandates proper <code>null</code> handling in the extractor function.
While you can obtain <code>null</code> values from a <code>Row</code>, you must not emit a <code>null</code>
value. You must wrap any <code>null</code> values in an object (for example, <code>Optional</code>
for singular values) to make sure a <code>null</code> value is never returned directly
by your extractor function.</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="r2dbc-DatabaseClient-examples-update"><a class="anchor" href="#r2dbc-DatabaseClient-examples-update"></a>Updating (<code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code>) with <code>DatabaseClient</code></h5>
<div class="paragraph">
<p>The only difference of modifying statements is that these statements typically
do not return tabular data so you use <code>rowsUpdated()</code> to consume results.</p>
</div>
<div class="paragraph">
<p>The following example shows an <code>UPDATE</code> statement that returns the number
of updated rows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Mono&lt;Integer&gt; affectedRows = client.sql("UPDATE person SET first_name = :fn")
        .bind("fn", "Joe")
        .fetch().rowsUpdated();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val affectedRows = client.sql("UPDATE person SET first_name = :fn")
        .bind("fn", "Joe")
        .fetch().awaitRowsUpdated()</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="r2dbc-DatabaseClient-named-parameters"><a class="anchor" href="#r2dbc-DatabaseClient-named-parameters"></a>Binding Values to Queries</h5>
<div class="paragraph">
<p>A typical application requires parameterized SQL statements to select or
update rows according to some input. These are typically <code>SELECT</code> statements
constrained by a <code>WHERE</code> clause or <code>INSERT</code> and <code>UPDATE</code> statements that accept
input parameters. Parameterized statements bear the risk of SQL injection if
parameters are not escaped properly. <code>DatabaseClient</code> leverages R2DBC&#8217;s
<code>bind</code> API to eliminate the risk of SQL injection for query parameters.
You can provide a parameterized SQL statement with the <code>execute()</code> operator
and bind parameters to the actual <code>Statement</code>. Your R2DBC driver then runs
the statement by using prepared statements and parameter substitution.</p>
</div>
<div class="paragraph">
<p>Parameter binding supports two binding strategies:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>By Index, using zero-based parameter indexes.</p>
</li>
<li>
<p>By Name, using the placeholder name.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example shows parameter binding for a query:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">db.sql("INSERT INTO person (id, name, age) VALUES(:id, :name, :age)")
    .bind("id", "joe")
    .bind("name", "Joe")
    .bind("age", 34);</code></pre>
</div>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">R2DBC Native Bind Markers</div>
<div class="paragraph">
<p>R2DBC uses database-native bind markers that depend on the actual database vendor.
As an example, Postgres uses indexed markers, such as <code>$1</code>, <code>$2</code>, <code>$n</code>.
Another example is SQL Server, which uses named bind markers prefixed with <code>@</code>.</p>
</div>
<div class="paragraph">
<p>This is different from JDBC, which requires <code>?</code> as bind markers.
In JDBC, the actual drivers translate <code>?</code> bind markers to database-native
markers as part of their statement execution.</p>
</div>
<div class="paragraph">
<p>Spring Framework&#8217;s R2DBC support lets you use native bind markers or named bind
markers with the <code>:name</code> syntax.</p>
</div>
<div class="paragraph">
<p>Named parameter support leverages a <code>BindMarkersFactory</code> instance to expand named
parameters to native bind markers at the time of query execution, which gives you
a certain degree of query portability across various database vendors.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>The query-preprocessor unrolls named <code>Collection</code> parameters into a series of bind
markers to remove the need of dynamic query creation based on the number of arguments.
Nested object arrays are expanded to allow usage of (for example) select lists.</p>
</div>
<div class="paragraph">
<p>Consider the following query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="sql" class="language-sql hljs">SELECT id, name, state FROM table WHERE (name, age) IN (('John', 35), ('Ann', 50))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding query can be parametrized and run as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">List&lt;Object[]&gt; tuples = new ArrayList&lt;&gt;();
tuples.add(new Object[] {"John", 35});
tuples.add(new Object[] {"Ann",  50});

client.sql("SELECT id, name, state FROM table WHERE (name, age) IN (:tuples)")
    .bind("tuples", tuples);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val tuples: MutableList&lt;Array&lt;Any&gt;&gt; = ArrayList()
tuples.add(arrayOf("John", 35))
tuples.add(arrayOf("Ann", 50))

client.sql("SELECT id, name, state FROM table WHERE (name, age) IN (:tuples)")
    .bind("tuples", tuples)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Usage of select lists is vendor-dependent.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows a simpler variant using <code>IN</code> predicates:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">client.sql("SELECT id, name, state FROM table WHERE age IN (:ages)")
    .bind("ages", Arrays.asList(35, 50));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val tuples: MutableList&lt;Array&lt;Any&gt;&gt; = ArrayList()
tuples.add(arrayOf("John", 35))
tuples.add(arrayOf("Ann", 50))

client.sql("SELECT id, name, state FROM table WHERE age IN (:ages)")
    .bind("tuples", arrayOf(35, 50))</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
R2DBC itself does not support Collection-like values. Nevertheless,
expanding a given <code>List</code> in the example above works for named parameters
in Spring&#8217;s R2DBC support, e.g. for use in <code>IN</code> clauses as shown above.
However, inserting or updating array-typed columns (e.g. in Postgres)
requires an array type that is supported by the underlying R2DBC driver:
typically a Java array, e.g. <code>String[]</code> to update a <code>text[]</code> column.
Do not pass <code>Collection&lt;String&gt;</code> or the like as an array parameter.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="r2dbc-DatabaseClient-filter"><a class="anchor" href="#r2dbc-DatabaseClient-filter"></a>Statement Filters</h5>
<div class="paragraph">
<p>Sometimes it you need to fine-tune options on the actual <code>Statement</code>
before it gets run. Register a <code>Statement</code> filter
(<code>StatementFilterFunction</code>) through <code>DatabaseClient</code> to intercept and
modify statements in their execution, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">client.sql("INSERT INTO table (name, state) VALUES(:name, :state)")
    .filter((s, next) -&gt; next.execute(s.returnGeneratedValues("id")))
    .bind("name", )
    .bind("state", );</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">client.sql("INSERT INTO table (name, state) VALUES(:name, :state)")
            .filter { s: Statement, next: ExecuteFunction -&gt; next.execute(s.returnGeneratedValues("id")) }
            .bind("name", )
            .bind("state", )</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>DatabaseClient</code> exposes also simplified <code>filter()</code> overload accepting <code>Function&lt;Statement, Statement&gt;</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">client.sql("INSERT INTO table (name, state) VALUES(:name, :state)")
    .filter(statement -&gt; s.returnGeneratedValues("id"));

client.sql("SELECT id, name, state FROM table")
    .filter(statement -&gt; s.fetchSize(25));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">client.sql("INSERT INTO table (name, state) VALUES(:name, :state)")
    .filter { statement -&gt; s.returnGeneratedValues("id") }

client.sql("SELECT id, name, state FROM table")
    .filter { statement -&gt; s.fetchSize(25) }</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>StatementFilterFunction</code> implementations allow filtering of the
<code>Statement</code> and filtering of <code>Result</code> objects.</p>
</div>
</div>
<div class="sect4">
<h5 id="r2dbc-DatabaseClient-idioms"><a class="anchor" href="#r2dbc-DatabaseClient-idioms"></a><code>DatabaseClient</code> Best Practices</h5>
<div class="paragraph">
<p>Instances of the <code>DatabaseClient</code> class are thread-safe, once configured. This is
important because it means that you can configure a single instance of a <code>DatabaseClient</code>
and then safely inject this shared reference into multiple DAOs (or repositories).
The <code>DatabaseClient</code> is stateful, in that it maintains a reference to a <code>ConnectionFactory</code>,
but this state is not conversational state.</p>
</div>
<div class="paragraph">
<p>A common practice when using the <code>DatabaseClient</code> class is to configure a <code>ConnectionFactory</code>
in your Spring configuration file and then dependency-inject
that shared <code>ConnectionFactory</code> bean into your DAO classes. The <code>DatabaseClient</code> is created in
the setter for the <code>ConnectionFactory</code>. This leads to DAOs that resemble the following:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class R2dbcCorporateEventDao implements CorporateEventDao {

    private DatabaseClient databaseClient;

    public void setConnectionFactory(ConnectionFactory connectionFactory) {
        this.databaseClient = DatabaseClient.create(connectionFactory);
    }

    // R2DBC-backed implementations of the methods on the CorporateEventDao follow...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class R2dbcCorporateEventDao(connectionFactory: ConnectionFactory) : CorporateEventDao {

    private val databaseClient = DatabaseClient.create(connectionFactory)

    // R2DBC-backed implementations of the methods on the CorporateEventDao follow...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>An alternative to explicit configuration is to use component-scanning and annotation
support for dependency injection. In this case, you can annotate the class with <code>@Component</code>
(which makes it a candidate for component-scanning) and annotate the <code>ConnectionFactory</code> setter
method with <code>@Autowired</code>. The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Component <i class="conum" data-value="1"></i><b>(1)</b>
public class R2dbcCorporateEventDao implements CorporateEventDao {

    private DatabaseClient databaseClient;

    @Autowired <i class="conum" data-value="2"></i><b>(2)</b>
    public void setConnectionFactory(ConnectionFactory connectionFactory) {
        this.databaseClient = DatabaseClient.create(connectionFactory); <i class="conum" data-value="3"></i><b>(3)</b>
    }

    // R2DBC-backed implementations of the methods on the CorporateEventDao follow...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Annotate the class with <code>@Component</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Annotate the <code>ConnectionFactory</code> setter method with <code>@Autowired</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Create a new <code>DatabaseClient</code> with the <code>ConnectionFactory</code>.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Component <i class="conum" data-value="1"></i><b>(1)</b>
class R2dbcCorporateEventDao(connectionFactory: ConnectionFactory) : CorporateEventDao { <i class="conum" data-value="2"></i><b>(2)</b>

    private val databaseClient = DatabaseClient(connectionFactory) <i class="conum" data-value="3"></i><b>(3)</b>

    // R2DBC-backed implementations of the methods on the CorporateEventDao follow...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Annotate the class with <code>@Component</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Constructor injection of the <code>ConnectionFactory</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Create a new <code>DatabaseClient</code> with the <code>ConnectionFactory</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Regardless of which of the above template initialization styles you choose to use (or
not), it is seldom necessary to create a new instance of a <code>DatabaseClient</code> class each
time you want to run SQL. Once configured, a <code>DatabaseClient</code> instance is thread-safe.
If your application accesses multiple
databases, you may want multiple <code>DatabaseClient</code> instances, which requires multiple
<code>ConnectionFactory</code> and, subsequently, multiple differently configured <code>DatabaseClient</code>
instances.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="r2dbc-auto-generated-keys"><a class="anchor" href="#r2dbc-auto-generated-keys"></a>5. Retrieving Auto-generated Keys</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>INSERT</code> statements may generate keys when inserting rows into a table
that defines an auto-increment or identity column. To get full control over
the column name to generate, simply register a <code>StatementFilterFunction</code> that
requests the generated key for the desired column.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Mono&lt;Integer&gt; generatedId = client.sql("INSERT INTO table (name, state) VALUES(:name, :state)")
    .filter(statement -&gt; s.returnGeneratedValues("id"))
        .map(row -&gt; row.get("id", Integer.class))
        .first();

// generatedId emits the generated key once the INSERT statement has finished</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val generatedId = client.sql("INSERT INTO table (name, state) VALUES(:name, :state)")
    .filter { statement -&gt; s.returnGeneratedValues("id") }
        .map { row -&gt; row.get("id", Integer.class) }
        .awaitOne()

// generatedId emits the generated key once the INSERT statement has finished</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="r2dbc-connections"><a class="anchor" href="#r2dbc-connections"></a>5.1. Controlling Database Connections</h3>
<div class="paragraph">
<p>This section covers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#r2dbc-ConnectionFactory">Using <code>ConnectionFactory</code></a></p>
</li>
<li>
<p><a href="#r2dbc-ConnectionFactoryUtils">Using <code>ConnectionFactoryUtils</code></a></p>
</li>
<li>
<p><a href="#r2dbc-SingleConnectionFactory">Using <code>SingleConnectionFactory</code></a></p>
</li>
<li>
<p><a href="#r2dbc-TransactionAwareConnectionFactoryProxy">Using <code>TransactionAwareConnectionFactoryProxy</code></a></p>
</li>
<li>
<p><a href="#r2dbc-R2dbcTransactionManager">Using <code>R2dbcTransactionManager</code></a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="r2dbc-ConnectionFactory"><a class="anchor" href="#r2dbc-ConnectionFactory"></a>5.1.1. Using <code>ConnectionFactory</code></h4>
<div class="paragraph">
<p>Spring obtains an R2DBC connection to the database through a <code>ConnectionFactory</code>.
A <code>ConnectionFactory</code> is part of the R2DBC specification and is a common entry-point
for drivers. It lets a container or a framework hide connection pooling
and transaction management issues from the application code. As a developer,
you need not know details about how to connect to the database. That is the
responsibility of the administrator who sets up the <code>ConnectionFactory</code>. You
most likely fill both roles as you develop and test code, but you do not
necessarily have to know how the production data source is configured.</p>
</div>
<div class="paragraph">
<p>When you use Spring&#8217;s R2DBC layer, you can can configure your own with a
connection pool implementation provided by a third party. A popular
implementation is R2DBC Pool (<code>r2dbc-pool</code>). Implementations in the Spring
distribution are meant only for testing purposes and do not provide pooling.</p>
</div>
<div class="paragraph">
<p>To configure a <code>ConnectionFactory</code>:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Obtain a connection with <code>ConnectionFactory</code> as you typically obtain an R2DBC <code>ConnectionFactory</code>.</p>
</li>
<li>
<p>Provide an R2DBC URL
(See the documentation for your driver for the correct value).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The following example shows how to configure a <code>ConnectionFactory</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">ConnectionFactory factory = ConnectionFactories.get("r2dbc:h2:mem:///test?options=DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val factory = ConnectionFactories.get("r2dbc:h2:mem:///test?options=DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE");</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="r2dbc-ConnectionFactoryUtils"><a class="anchor" href="#r2dbc-ConnectionFactoryUtils"></a>5.1.2. Using <code>ConnectionFactoryUtils</code></h4>
<div class="paragraph">
<p>The <code>ConnectionFactoryUtils</code> class is a convenient and powerful helper class
that provides <code>static</code> methods to obtain connections from <code>ConnectionFactory</code>
and close connections (if necessary).</p>
</div>
<div class="paragraph">
<p>It supports subscriber <code>Context</code>-bound connections with, for example
<code>R2dbcTransactionManager</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="r2dbc-SingleConnectionFactory"><a class="anchor" href="#r2dbc-SingleConnectionFactory"></a>5.1.3. Using <code>SingleConnectionFactory</code></h4>
<div class="paragraph">
<p>The <code>SingleConnectionFactory</code> class is an implementation of <code>DelegatingConnectionFactory</code>
interface that wraps a single <code>Connection</code> that is not closed after each use.</p>
</div>
<div class="paragraph">
<p>If any client code calls <code>close</code> on the assumption of a pooled connection (as when using
persistence tools), you should set the <code>suppressClose</code> property to <code>true</code>. This setting
returns a close-suppressing proxy that wraps the physical connection. Note that you can
no longer cast this to a native <code>Connection</code> or a similar object.</p>
</div>
<div class="paragraph">
<p><code>SingleConnectionFactory</code> is primarily a test class and may be used for specific requirements
such as pipelining if your R2DBC driver permits for such use.
In contrast to a pooled <code>ConnectionFactory</code>, it reuses the same connection all the time, avoiding
excessive creation of physical connections.</p>
</div>
</div>
<div class="sect3">
<h4 id="r2dbc-TransactionAwareConnectionFactoryProxy"><a class="anchor" href="#r2dbc-TransactionAwareConnectionFactoryProxy"></a>5.1.4. Using <code>TransactionAwareConnectionFactoryProxy</code></h4>
<div class="paragraph">
<p><code>TransactionAwareConnectionFactoryProxy</code> is a proxy for a target <code>ConnectionFactory</code>.
The proxy wraps that target <code>ConnectionFactory</code> to add awareness of Spring-managed transactions.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Using this class is required if you use a R2DBC client that is not integrated otherwise
with Spring&#8217;s R2DBC support. In this case, you can still use this client and, at
the same time, have this client participating in Spring managed transactions. It is generally
preferable to integrate a R2DBC client with proper access to <code>ConnectionFactoryUtils</code>
for resource management.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>See the <a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/r2dbc/connection/TransactionAwareConnectionFactoryProxy.html"><code>TransactionAwareConnectionFactoryProxy</code></a>
javadoc for more details.</p>
</div>
</div>
<div class="sect3">
<h4 id="r2dbc-R2dbcTransactionManager"><a class="anchor" href="#r2dbc-R2dbcTransactionManager"></a>5.1.5. Using <code>R2dbcTransactionManager</code></h4>
<div class="paragraph">
<p>The <code>R2dbcTransactionManager</code> class is a <code>ReactiveTransactionManager</code> implementation for
single R2DBC datasources. It binds an R2DBC connection from the specified connection factory
to the subscriber <code>Context</code>, potentially allowing for one subscriber connection for each
connection factory.</p>
</div>
<div class="paragraph">
<p>Application code is required to retrieve the R2DBC connection through
<code>ConnectionFactoryUtils.getConnection(ConnectionFactory)</code>, instead of R2DBC&#8217;s standard
<code>ConnectionFactory.create()</code>.</p>
</div>
<div class="paragraph">
<p>All framework classes (such as <code>DatabaseClient</code>) use this strategy implicitly.
If not used with this transaction manager, the lookup strategy behaves exactly like the common one.
Thus, it can be used in any case.</p>
</div>
<div class="paragraph">
<p>The <code>R2dbcTransactionManager</code> class supports custom isolation levels that get applied to the connection.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="orm"><a class="anchor" href="#orm"></a>6. Object Relational Mapping (ORM) Data Access</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section covers data access when you use Object Relational Mapping (ORM).</p>
</div>
<div class="sect2">
<h3 id="orm-introduction"><a class="anchor" href="#orm-introduction"></a>6.1. Introduction to ORM with Spring</h3>
<div class="paragraph">
<p>The Spring Framework supports integration with the Java Persistence API (JPA) and
supports native Hibernate for resource management, data access object (DAO) implementations,
and transaction strategies. For example, for Hibernate, there is first-class support with
several convenient IoC features that address many typical Hibernate integration issues.
You can configure all of the supported features for OR (object relational) mapping
tools through Dependency Injection. They can participate in Spring&#8217;s resource and
transaction management, and they comply with Spring&#8217;s generic transaction and DAO
exception hierarchies. The recommended integration style is to code DAOs against plain
Hibernate or JPA APIs.</p>
</div>
<div class="paragraph">
<p>Spring adds significant enhancements to the ORM layer of your choice when you create
data access applications. You can leverage as much of the integration support as you
wish, and you should compare this integration effort with the cost and risk of building
a similar infrastructure in-house. You can use much of the ORM support as you would a
library, regardless of technology, because everything is designed as a set of reusable
JavaBeans. ORM in a Spring IoC container facilitates configuration and deployment. Thus,
most examples in this section show configuration inside a Spring container.</p>
</div>
<div class="paragraph">
<p>The benefits of using the Spring Framework to create your ORM DAOs include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Easier testing.</strong> Spring&#8217;s IoC approach makes it easy to swap the implementations
and configuration locations of Hibernate <code>SessionFactory</code> instances, JDBC <code>DataSource</code>
instances, transaction managers, and mapped object implementations (if needed). This
in turn makes it much easier to test each piece of persistence-related code in
isolation.</p>
</li>
<li>
<p><strong>Common data access exceptions.</strong> Spring can wrap exceptions from your ORM tool,
converting them from proprietary (potentially checked) exceptions to a common runtime
<code>DataAccessException</code> hierarchy. This feature lets you handle most persistence
exceptions, which are non-recoverable, only in the appropriate layers, without
annoying boilerplate catches, throws, and exception declarations. You can still trap
and handle exceptions as necessary. Remember that JDBC exceptions (including
DB-specific dialects) are also converted to the same hierarchy, meaning that you can
perform some operations with JDBC within a consistent programming model.</p>
</li>
<li>
<p><strong>General resource management.</strong> Spring application contexts can handle the location
and configuration of Hibernate <code>SessionFactory</code> instances, JPA <code>EntityManagerFactory</code>
instances, JDBC <code>DataSource</code> instances, and other related resources. This makes these
values easy to manage and change. Spring offers efficient, easy, and safe handling of
persistence resources. For example, related code that uses Hibernate generally needs to
use the same Hibernate <code>Session</code> to ensure efficiency and proper transaction handling.
Spring makes it easy to create and bind a <code>Session</code> to the current thread transparently,
by exposing a current <code>Session</code> through the Hibernate <code>SessionFactory</code>. Thus, Spring
solves many chronic problems of typical Hibernate usage, for any local or JTA
transaction environment.</p>
</li>
<li>
<p><strong>Integrated transaction management.</strong> You can wrap your ORM code with a declarative,
aspect-oriented programming (AOP) style method interceptor either through the
<code>@Transactional</code> annotation or by explicitly configuring the transaction AOP advice in
an XML configuration file. In both cases, transaction semantics and exception handling
(rollback and so on) are handled for you. As discussed in <a href="#orm-resource-mngmnt">Resource and Transaction Management</a>,
you can also swap various transaction managers, without affecting your ORM-related code.
For example, you can swap between local transactions and JTA, with the same full services
(such as declarative transactions) available in both scenarios. Additionally,
JDBC-related code can fully integrate transactionally with the code you use to do ORM.
This is useful for data access that is not suitable for ORM (such as batch processing and
BLOB streaming) but that still needs to share common transactions with ORM operations.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
For more comprehensive ORM support, including support for alternative database
technologies such as MongoDB, you might want to check out the
<a href="https://projects.spring.io/spring-data/">Spring Data</a> suite of projects. If you are
a JPA user, the <a href="https://spring.io/guides/gs/accessing-data-jpa/">Getting Started Accessing
Data with JPA</a> guide from <a href="https://spring.io" class="bare">https://spring.io</a> provides a great introduction.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="orm-general"><a class="anchor" href="#orm-general"></a>6.2. General ORM Integration Considerations</h3>
<div class="paragraph">
<p>This section highlights considerations that apply to all ORM technologies.
The <a href="#orm-hibernate">Hibernate</a> section provides more details and also show these features and
configurations in a concrete context.</p>
</div>
<div class="paragraph">
<p>The major goal of Spring&#8217;s ORM integration is clear application layering (with any data
access and transaction technology) and for loose coupling of application objects&#8201;&#8212;&#8201;no
more business service dependencies on the data access or transaction strategy, no more
hard-coded resource lookups, no more hard-to-replace singletons, no more custom service
registries. The goal is to have one simple and consistent approach to wiring up application objects, keeping
them as reusable and free from container dependencies as possible. All the individual
data access features are usable on their own but integrate nicely with Spring&#8217;s
application context concept, providing XML-based configuration and cross-referencing of
plain JavaBean instances that need not be Spring-aware. In a typical Spring application,
many important objects are JavaBeans: data access templates, data access objects,
transaction managers, business services that use the data access objects and transaction
managers, web view resolvers, web controllers that use the business services, and so on.</p>
</div>
<div class="sect3">
<h4 id="orm-resource-mngmnt"><a class="anchor" href="#orm-resource-mngmnt"></a>6.2.1. Resource and Transaction Management</h4>
<div class="paragraph">
<p>Typical business applications are cluttered with repetitive resource management code.
Many projects try to invent their own solutions, sometimes sacrificing proper handling
of failures for programming convenience. Spring advocates simple solutions for proper
resource handling, namely IoC through templating in the case of JDBC and applying AOP
interceptors for the ORM technologies.</p>
</div>
<div class="paragraph">
<p>The infrastructure provides proper resource handling and appropriate conversion of
specific API exceptions to an unchecked infrastructure exception hierarchy. Spring
introduces a DAO exception hierarchy, applicable to any data access strategy. For direct
JDBC, the <code>JdbcTemplate</code> class mentioned in a <a href="#jdbc-JdbcTemplate">previous section</a>
provides connection handling and proper conversion of <code>SQLException</code> to the
<code>DataAccessException</code> hierarchy, including translation of database-specific SQL error
codes to meaningful exception classes. For ORM technologies, see the
<a href="#orm-exception-translation">next section</a> for how to get the same exception
translation benefits.</p>
</div>
<div class="paragraph">
<p>When it comes to transaction management, the <code>JdbcTemplate</code> class hooks in to the Spring
transaction support and supports both JTA and JDBC transactions, through respective
Spring transaction managers. For the supported ORM technologies, Spring offers Hibernate
and JPA support through the Hibernate and JPA transaction managers as well as JTA support.
For details on transaction support, see the <a href="#transaction">Transaction Management</a> chapter.</p>
</div>
</div>
<div class="sect3">
<h4 id="orm-exception-translation"><a class="anchor" href="#orm-exception-translation"></a>6.2.2. Exception Translation</h4>
<div class="paragraph">
<p>When you use Hibernate or JPA in a DAO, you must decide how to handle the persistence
technology&#8217;s native exception classes. The DAO throws a subclass of a <code>HibernateException</code>
or <code>PersistenceException</code>, depending on the technology. These exceptions are all runtime
exceptions and do not have to be declared or caught. You may also have to deal with
<code>IllegalArgumentException</code> and <code>IllegalStateException</code>. This means that callers can only
treat exceptions as being generally fatal, unless they want to depend on the persistence
technology&#8217;s own exception structure. Catching specific causes (such as an optimistic
locking failure) is not possible without tying the caller to the implementation strategy.
This trade-off might be acceptable to applications that are strongly ORM-based or
do not need any special exception treatment (or both). However, Spring lets exception
translation be applied transparently through the <code>@Repository</code> annotation. The following
examples (one for Java configuration and one for XML configuration) show how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Repository
public class ProductDaoImpl implements ProductDao {

    // class body here...

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Repository
class ProductDaoImpl : ProductDao {
    // class body here...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;

    &lt;!-- Exception translation bean post processor --&gt;
    &lt;bean class="org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor"/&gt;

    &lt;bean id="myProductDao" class="product.ProductDaoImpl"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The postprocessor automatically looks for all exception translators (implementations of
the <code>PersistenceExceptionTranslator</code> interface) and advises all beans marked with the
<code>@Repository</code> annotation so that the discovered translators can intercept and apply the
appropriate translation on the thrown exceptions.</p>
</div>
<div class="paragraph">
<p>In summary, you can implement DAOs based on the plain persistence technology&#8217;s API and
annotations while still benefiting from Spring-managed transactions, dependency
injection, and transparent exception conversion (if desired) to Spring&#8217;s custom
exception hierarchies.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="orm-hibernate"><a class="anchor" href="#orm-hibernate"></a>6.3. Hibernate</h3>
<div class="paragraph">
<p>We start with a coverage of <a href="https://hibernate.org/">Hibernate 5</a> in a Spring environment,
using it to demonstrate the approach that Spring takes towards integrating OR mappers.
This section covers many issues in detail and shows different variations of DAO
implementations and transaction demarcation. Most of these patterns can be directly
translated to all other supported ORM tools. The later sections in this chapter then
cover the other ORM technologies and show brief examples.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As of Spring Framework 5.3, Spring requires Hibernate ORM 5.2+ for Spring&#8217;s
<code>HibernateJpaVendorAdapter</code> as well as for a native Hibernate <code>SessionFactory</code> setup.
Is is strongly recommended to go with Hibernate ORM 5.4 for a newly started application.
For use with <code>HibernateJpaVendorAdapter</code>, Hibernate Search needs to be upgraded to 5.11.6.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="orm-session-factory-setup"><a class="anchor" href="#orm-session-factory-setup"></a>6.3.1. <code>SessionFactory</code> Setup in a Spring Container</h4>
<div class="paragraph">
<p>To avoid tying application objects to hard-coded resource lookups, you can define
resources (such as a JDBC <code>DataSource</code> or a Hibernate <code>SessionFactory</code>) as beans in the
Spring container. Application objects that need to access resources receive references
to such predefined instances through bean references, as illustrated in the DAO
definition in the <a href="#orm-hibernate-straight">next section</a>.</p>
</div>
<div class="paragraph">
<p>The following excerpt from an XML application context definition shows how to set up a
JDBC <code>DataSource</code> and a Hibernate <code>SessionFactory</code> on top of it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;

    &lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
        &lt;property name="driverClassName" value="org.hsqldb.jdbcDriver"/&gt;
        &lt;property name="url" value="jdbc:hsqldb:hsql://localhost:9001"/&gt;
        &lt;property name="username" value="sa"/&gt;
        &lt;property name="password" value=""/&gt;
    &lt;/bean&gt;

    &lt;bean id="mySessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean"&gt;
        &lt;property name="dataSource" ref="myDataSource"/&gt;
        &lt;property name="mappingResources"&gt;
            &lt;list&gt;
                &lt;value&gt;product.hbm.xml&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="hibernateProperties"&gt;
            &lt;value&gt;
                hibernate.dialect=org.hibernate.dialect.HSQLDialect
            &lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Switching from a local Jakarta Commons DBCP <code>BasicDataSource</code> to a JNDI-located
<code>DataSource</code> (usually managed by an application server) is only a matter of
configuration, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;
    &lt;jee:jndi-lookup id="myDataSource" jndi-name="java:comp/env/jdbc/myds"/&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also access a JNDI-located <code>SessionFactory</code>, using Spring&#8217;s
<code>JndiObjectFactoryBean</code> / <code>&lt;jee:jndi-lookup&gt;</code> to retrieve and expose it.
However, that is typically not common outside of an EJB context.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Spring also provides a <code>LocalSessionFactoryBuilder</code> variant, seamlessly integrating
with <code>@Bean</code> style configuration and programmatic setup (no <code>FactoryBean</code> involved).</p>
</div>
<div class="paragraph">
<p>Both <code>LocalSessionFactoryBean</code> and <code>LocalSessionFactoryBuilder</code> support background
bootstrapping, with Hibernate initialization running in parallel to the application
bootstrap thread on a given bootstrap executor (such as a <code>SimpleAsyncTaskExecutor</code>).
On <code>LocalSessionFactoryBean</code>, this is available through the <code>bootstrapExecutor</code>
property. On the programmatic <code>LocalSessionFactoryBuilder</code>, there is an overloaded
<code>buildSessionFactory</code> method that takes a bootstrap executor argument.</p>
</div>
<div class="paragraph">
<p>As of Spring Framework 5.1, such a native Hibernate setup can also expose a JPA
<code>EntityManagerFactory</code> for standard JPA interaction next to native Hibernate access.
See <a href="#orm-jpa-hibernate">Native Hibernate Setup for JPA</a> for details.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="orm-hibernate-straight"><a class="anchor" href="#orm-hibernate-straight"></a>6.3.2. Implementing DAOs Based on the Plain Hibernate API</h4>
<div class="paragraph">
<p>Hibernate has a feature called contextual sessions, wherein Hibernate itself manages
one current <code>Session</code> per transaction. This is roughly equivalent to Spring&#8217;s
synchronization of one Hibernate <code>Session</code> per transaction. A corresponding DAO
implementation resembles the following example, based on the plain Hibernate API:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class ProductDaoImpl implements ProductDao {

    private SessionFactory sessionFactory;

    public void setSessionFactory(SessionFactory sessionFactory) {
        this.sessionFactory = sessionFactory;
    }

    public Collection loadProductsByCategory(String category) {
        return this.sessionFactory.getCurrentSession()
                .createQuery("from test.Product product where product.category=?")
                .setParameter(0, category)
                .list();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class ProductDaoImpl(private val sessionFactory: SessionFactory) : ProductDao {

    fun loadProductsByCategory(category: String): Collection&lt;*&gt; {
        return sessionFactory.currentSession
                .createQuery("from test.Product product where product.category=?")
                .setParameter(0, category)
                .list()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This style is similar to that of the Hibernate reference documentation and examples,
except for holding the <code>SessionFactory</code> in an instance variable. We strongly recommend
such an instance-based setup over the old-school <code>static</code> <code>HibernateUtil</code> class from
Hibernate&#8217;s CaveatEmptor sample application. (In general, do not keep any resources in
<code>static</code> variables unless absolutely necessary.)</p>
</div>
<div class="paragraph">
<p>The preceding DAO example follows the dependency injection pattern. It fits nicely into a Spring IoC
container, as it would if coded against Spring&#8217;s <code>HibernateTemplate</code>.
You can also set up such a DAO in plain Java (for example, in unit tests). To do so,
instantiate it and call <code>setSessionFactory(..)</code> with the desired factory reference. As a
Spring bean definition, the DAO would resemble the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;

    &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
        &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The main advantage of this DAO style is that it depends on Hibernate API only. No import
of any Spring class is required. This is appealing from a non-invasiveness
perspective and may feel more natural to Hibernate developers.</p>
</div>
<div class="paragraph">
<p>However, the DAO throws plain <code>HibernateException</code> (which is unchecked, so it does not have
to be declared or caught), which means that callers can treat exceptions only as being
generally fatal&#8201;&#8212;&#8201;unless they want to depend on Hibernate&#8217;s own exception hierarchy.
Catching specific causes (such as an optimistic locking failure) is not possible without
tying the caller to the implementation strategy. This trade off might be acceptable to
applications that are strongly Hibernate-based, do not need any special exception
treatment, or both.</p>
</div>
<div class="paragraph">
<p>Fortunately, Spring&#8217;s <code>LocalSessionFactoryBean</code> supports Hibernate&#8217;s
<code>SessionFactory.getCurrentSession()</code> method for any Spring transaction strategy,
returning the current Spring-managed transactional <code>Session</code>, even with
<code>HibernateTransactionManager</code>. The standard behavior of that method remains
to return the current <code>Session</code> associated with the ongoing JTA transaction, if any.
This behavior applies regardless of whether you use Spring&#8217;s
<code>JtaTransactionManager</code>, EJB container managed transactions (CMTs), or JTA.</p>
</div>
<div class="paragraph">
<p>In summary, you can implement DAOs based on the plain Hibernate API, while still being
able to participate in Spring-managed transactions.</p>
</div>
</div>
<div class="sect3">
<h4 id="orm-hibernate-tx-declarative"><a class="anchor" href="#orm-hibernate-tx-declarative"></a>6.3.3. Declarative Transaction Demarcation</h4>
<div class="paragraph">
<p>We recommend that you use Spring&#8217;s declarative transaction support, which lets you
replace explicit transaction demarcation API calls in your Java code with an AOP
transaction interceptor. You can configure this transaction interceptor in a Spring
container by using either Java annotations or XML. This declarative transaction capability
lets you keep business services free of repetitive transaction demarcation code and
focus on adding business logic, which is the real value of your application.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Before you continue, we are strongly encourage you to read <a href="#transaction-declarative">Declarative Transaction Management</a>
if you have not already done so.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can annotate the service layer with <code>@Transactional</code> annotations and instruct the
Spring container to find these annotations and provide transactional semantics for
these annotated methods. The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class ProductServiceImpl implements ProductService {

    private ProductDao productDao;

    public void setProductDao(ProductDao productDao) {
        this.productDao = productDao;
    }

    @Transactional
    public void increasePriceOfAllProductsInCategory(final String category) {
        List productsToChange = this.productDao.loadProductsByCategory(category);
        // ...
    }

    @Transactional(readOnly = true)
    public List&lt;Product&gt; findAllProducts() {
        return this.productDao.findAllProducts();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class ProductServiceImpl(private val productDao: ProductDao) : ProductService {

    @Transactional
    fun increasePriceOfAllProductsInCategory(category: String) {
        val productsToChange = productDao.loadProductsByCategory(category)
        // ...
    }

    @Transactional(readOnly = true)
    fun findAllProducts() = productDao.findAllProducts()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the container, you need to set up the <code>PlatformTransactionManager</code> implementation
(as a bean) and a <code>&lt;tx:annotation-driven/&gt;</code> entry, opting into <code>@Transactional</code>
processing at runtime. The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        https://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd"&gt;

    &lt;!-- SessionFactory, DataSource, etc. omitted --&gt;

    &lt;bean id="transactionManager"
            class="org.springframework.orm.hibernate5.HibernateTransactionManager"&gt;
        &lt;property name="sessionFactory" ref="sessionFactory"/&gt;
    &lt;/bean&gt;

    &lt;tx:annotation-driven/&gt;

    &lt;bean id="myProductService" class="product.SimpleProductService"&gt;
        &lt;property name="productDao" ref="myProductDao"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="orm-hibernate-tx-programmatic"><a class="anchor" href="#orm-hibernate-tx-programmatic"></a>6.3.4. Programmatic Transaction Demarcation</h4>
<div class="paragraph">
<p>You can demarcate transactions in a higher level of the application, on top of
lower-level data access services that span any number of operations. Nor do restrictions
exist on the implementation of the surrounding business service. It needs only a Spring
<code>PlatformTransactionManager</code>. Again, the latter can come from anywhere, but preferably
as a bean reference through a <code>setTransactionManager(..)</code> method. Also, the
<code>productDAO</code> should be set by a <code>setProductDao(..)</code> method. The following pair of snippets show
a transaction manager and a business service definition in a Spring application context
and an example for a business method implementation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;

    &lt;bean id="myTxManager" class="org.springframework.orm.hibernate5.HibernateTransactionManager"&gt;
        &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
    &lt;/bean&gt;

    &lt;bean id="myProductService" class="product.ProductServiceImpl"&gt;
        &lt;property name="transactionManager" ref="myTxManager"/&gt;
        &lt;property name="productDao" ref="myProductDao"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class ProductServiceImpl implements ProductService {

    private TransactionTemplate transactionTemplate;
    private ProductDao productDao;

    public void setTransactionManager(PlatformTransactionManager transactionManager) {
        this.transactionTemplate = new TransactionTemplate(transactionManager);
    }

    public void setProductDao(ProductDao productDao) {
        this.productDao = productDao;
    }

    public void increasePriceOfAllProductsInCategory(final String category) {
        this.transactionTemplate.execute(new TransactionCallbackWithoutResult() {
            public void doInTransactionWithoutResult(TransactionStatus status) {
                List productsToChange = this.productDao.loadProductsByCategory(category);
                // do the price increase...
            }
        });
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class ProductServiceImpl(transactionManager: PlatformTransactionManager,
                        private val productDao: ProductDao) : ProductService {

    private val transactionTemplate = TransactionTemplate(transactionManager)

    fun increasePriceOfAllProductsInCategory(category: String) {
        transactionTemplate.execute {
            val productsToChange = productDao.loadProductsByCategory(category)
            // do the price increase...
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring&#8217;s <code>TransactionInterceptor</code> lets any checked application exception be thrown
with the callback code, while <code>TransactionTemplate</code> is restricted to unchecked
exceptions within the callback. <code>TransactionTemplate</code> triggers a rollback in case of
an unchecked application exception or if the transaction is marked rollback-only by
the application (by setting <code>TransactionStatus</code>). By default, <code>TransactionInterceptor</code>
behaves the same way but allows configurable rollback policies per method.</p>
</div>
</div>
<div class="sect3">
<h4 id="orm-hibernate-tx-strategies"><a class="anchor" href="#orm-hibernate-tx-strategies"></a>6.3.5. Transaction Management Strategies</h4>
<div class="paragraph">
<p>Both <code>TransactionTemplate</code> and <code>TransactionInterceptor</code> delegate the actual transaction
handling to a <code>PlatformTransactionManager</code> instance (which can be a
<code>HibernateTransactionManager</code> (for a single Hibernate <code>SessionFactory</code>) by using a
<code>ThreadLocal</code> <code>Session</code> under the hood) or a <code>JtaTransactionManager</code> (delegating to the
JTA subsystem of the container) for Hibernate applications. You can even use a custom
<code>PlatformTransactionManager</code> implementation. Switching from native Hibernate transaction
management to JTA (such as when facing distributed transaction requirements for certain
deployments of your application) is only a matter of configuration. You can replace
the Hibernate transaction manager with Spring&#8217;s JTA transaction implementation. Both
transaction demarcation and data access code work without changes, because they
use the generic transaction management APIs.</p>
</div>
<div class="paragraph">
<p>For distributed transactions across multiple Hibernate session factories, you can combine
<code>JtaTransactionManager</code> as a transaction strategy with multiple
<code>LocalSessionFactoryBean</code> definitions. Each DAO then gets one specific <code>SessionFactory</code>
reference passed into its corresponding bean property. If all underlying JDBC data
sources are transactional container ones, a business service can demarcate transactions
across any number of DAOs and any number of session factories without special regard, as
long as it uses <code>JtaTransactionManager</code> as the strategy.</p>
</div>
<div class="paragraph">
<p>Both <code>HibernateTransactionManager</code> and <code>JtaTransactionManager</code> allow for proper
JVM-level cache handling with Hibernate, without container-specific transaction manager
lookup or a JCA connector (if you do not use EJB to initiate transactions).</p>
</div>
<div class="paragraph">
<p><code>HibernateTransactionManager</code> can export the Hibernate JDBC <code>Connection</code> to plain JDBC
access code for a specific <code>DataSource</code>. This ability allows for high-level
transaction demarcation with mixed Hibernate and JDBC data access completely without
JTA, provided you access only one database. <code>HibernateTransactionManager</code> automatically
exposes the Hibernate transaction as a JDBC transaction if you have set up the passed-in
<code>SessionFactory</code> with a <code>DataSource</code> through the <code>dataSource</code> property of the
<code>LocalSessionFactoryBean</code> class. Alternatively, you can specify explicitly the
<code>DataSource</code> for which the transactions are supposed to be exposed through the
<code>dataSource</code> property of the <code>HibernateTransactionManager</code> class.</p>
</div>
</div>
<div class="sect3">
<h4 id="orm-hibernate-resources"><a class="anchor" href="#orm-hibernate-resources"></a>6.3.6. Comparing Container-managed and Locally Defined Resources</h4>
<div class="paragraph">
<p>You can switch between a container-managed JNDI <code>SessionFactory</code> and a locally defined
one without having to change a single line of application code. Whether to keep
resource definitions in the container or locally within the application is mainly a
matter of the transaction strategy that you use. Compared to a Spring-defined local
<code>SessionFactory</code>, a manually registered JNDI <code>SessionFactory</code> does not provide any
benefits. Deploying a <code>SessionFactory</code> through Hibernate&#8217;s JCA connector provides the
added value of participating in the Java EE server&#8217;s management infrastructure, but does
not add actual value beyond that.</p>
</div>
<div class="paragraph">
<p>Spring&#8217;s transaction support is not bound to a container. When configured with any strategy
other than JTA, transaction support also works in a stand-alone or test environment.
Especially in the typical case of single-database transactions, Spring&#8217;s single-resource
local transaction support is a lightweight and powerful alternative to JTA. When you use
local EJB stateless session beans to drive transactions, you depend both on an EJB
container and on JTA, even if you access only a single database and use only stateless
session beans to provide declarative transactions through container-managed
transactions. Direct use of JTA programmatically also requires a Java EE environment.
JTA does not involve only container dependencies in terms of JTA itself and of
JNDI <code>DataSource</code> instances. For non-Spring, JTA-driven Hibernate transactions, you have
to use the Hibernate JCA connector or extra Hibernate transaction code with the
<code>TransactionManagerLookup</code> configured for proper JVM-level caching.</p>
</div>
<div class="paragraph">
<p>Spring-driven transactions can work as well with a locally defined Hibernate
<code>SessionFactory</code> as they do with a local JDBC <code>DataSource</code>, provided they access a
single database. Thus, you need only use Spring&#8217;s JTA transaction strategy when you
have distributed transaction requirements. A JCA connector requires container-specific
deployment steps, and (obviously) JCA support in the first place. This configuration
requires more work than deploying a simple web application with local resource
definitions and Spring-driven transactions. Also, you often need the Enterprise Edition
of your container if you use, for example, WebLogic Express, which does not
provide JCA. A Spring application with local resources and transactions that span one
single database works in any Java EE web container (without JTA, JCA, or EJB), such as
Tomcat, Resin, or even plain Jetty. Additionally, you can easily reuse such a middle
tier in desktop applications or test suites.</p>
</div>
<div class="paragraph">
<p>All things considered, if you do not use EJBs, stick with local <code>SessionFactory</code> setup
and Spring&#8217;s <code>HibernateTransactionManager</code> or <code>JtaTransactionManager</code>. You get all of
the benefits, including proper transactional JVM-level caching and distributed
transactions, without the inconvenience of container deployment. JNDI registration of a
Hibernate <code>SessionFactory</code> through the JCA connector adds value only when used in
conjunction with EJBs.</p>
</div>
</div>
<div class="sect3">
<h4 id="orm-hibernate-invalid-jdbc-access-error"><a class="anchor" href="#orm-hibernate-invalid-jdbc-access-error"></a>6.3.7. Spurious Application Server Warnings with Hibernate</h4>
<div class="paragraph">
<p>In some JTA environments with very strict <code>XADataSource</code> implementations (currently
some WebLogic Server and WebSphere versions), when Hibernate is configured without
regard to the JTA transaction manager for that environment, spurious warnings or
exceptions can show up in the application server log. These warnings or exceptions
indicate that the connection being accessed is no longer valid or JDBC access is no
longer valid, possibly because the transaction is no longer active. As an example,
here is an actual exception from WebLogic:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>java.sql.SQLException: The transaction is no longer active - status: 'Committed'. No
further JDBC access is allowed within this transaction.</pre>
</div>
</div>
<div class="paragraph">
<p>Another common problem is a connection leak after JTA transactions, with Hibernate
sessions (and potentially underlying JDBC connections) not getting closed properly.</p>
</div>
<div class="paragraph">
<p>You can resolve such issues by making Hibernate aware of the JTA transaction manager,
to which it synchronizes (along with Spring). You have two options for doing this:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Pass your Spring <code>JtaTransactionManager</code> bean to your Hibernate setup. The easiest
way is a bean reference into the <code>jtaTransactionManager</code> property for your
<code>LocalSessionFactoryBean</code> bean (see <a href="#transaction-strategies-hibernate">Hibernate Transaction Setup</a>).
Spring then makes the corresponding JTA strategies available to Hibernate.</p>
</li>
<li>
<p>You may also configure Hibernate&#8217;s JTA-related properties explicitly, in particular
"hibernate.transaction.coordinator_class", "hibernate.connection.handling_mode"
and potentially "hibernate.transaction.jta.platform" in your "hibernateProperties"
on <code>LocalSessionFactoryBean</code> (see Hibernate&#8217;s manual for details on those properties).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The remainder of this section describes the sequence of events that occur with and
without Hibernate&#8217;s awareness of the JTA <code>PlatformTransactionManager</code>.</p>
</div>
<div class="paragraph">
<p>When Hibernate is not configured with any awareness of the JTA transaction manager,
the following events occur when a JTA transaction commits:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The JTA transaction commits.</p>
</li>
<li>
<p>Spring&#8217;s <code>JtaTransactionManager</code> is synchronized to the JTA transaction, so it is
called back through an <code>afterCompletion</code> callback by the JTA transaction manager.</p>
</li>
<li>
<p>Among other activities, this synchronization can trigger a callback by Spring to
Hibernate, through Hibernate&#8217;s <code>afterTransactionCompletion</code> callback (used to clear
the Hibernate cache), followed by an explicit <code>close()</code> call on the Hibernate session,
which causes Hibernate to attempt to <code>close()</code> the JDBC Connection.</p>
</li>
<li>
<p>In some environments, this <code>Connection.close()</code> call then triggers the warning or
error, as the application server no longer considers the <code>Connection</code> to be usable,
because the transaction has already been committed.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When Hibernate is configured with awareness of the JTA transaction manager,
the following events occur when a JTA transaction commits:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The JTA transaction is ready to commit.</p>
</li>
<li>
<p>Spring&#8217;s <code>JtaTransactionManager</code> is synchronized to the JTA transaction, so the
transaction is called back through a <code>beforeCompletion</code> callback by the JTA
transaction manager.</p>
</li>
<li>
<p>Spring is aware that Hibernate itself is synchronized to the JTA transaction and
behaves differently than in the previous scenario. In particular, it aligns with
Hibernate&#8217;s transactional resource management.</p>
</li>
<li>
<p>The JTA transaction commits.</p>
</li>
<li>
<p>Hibernate is synchronized to the JTA transaction, so the transaction is called back
through an <code>afterCompletion</code> callback by the JTA transaction manager and can
properly clear its cache.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="orm-jpa"><a class="anchor" href="#orm-jpa"></a>6.4. JPA</h3>
<div class="paragraph">
<p>The Spring JPA, available under the <code>org.springframework.orm.jpa</code> package, offers
comprehensive support for the
<a href="https://www.oracle.com/technetwork/articles/javaee/jpa-137156.html">Java Persistence
API</a> in a manner similar to the integration with Hibernate while being aware of
the underlying implementation in order to provide additional features.</p>
</div>
<div class="sect3">
<h4 id="orm-jpa-setup"><a class="anchor" href="#orm-jpa-setup"></a>6.4.1. Three Options for JPA Setup in a Spring Environment</h4>
<div class="paragraph">
<p>The Spring JPA support offers three ways of setting up the JPA <code>EntityManagerFactory</code>
that is used by the application to obtain an entity manager.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#orm-jpa-setup-lemfb">Using <code>LocalEntityManagerFactoryBean</code></a></p>
</li>
<li>
<p><a href="#orm-jpa-setup-jndi">Obtaining an EntityManagerFactory from JNDI</a></p>
</li>
<li>
<p><a href="#orm-jpa-setup-lcemfb">Using <code>LocalContainerEntityManagerFactoryBean</code></a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="orm-jpa-setup-lemfb"><a class="anchor" href="#orm-jpa-setup-lemfb"></a>Using <code>LocalEntityManagerFactoryBean</code></h5>
<div class="paragraph">
<p>You can use this option only in simple deployment environments such as stand-alone
applications and integration tests.</p>
</div>
<div class="paragraph">
<p>The <code>LocalEntityManagerFactoryBean</code> creates an <code>EntityManagerFactory</code> suitable for
simple deployment environments where the application uses only JPA for data access.
The factory bean uses the JPA <code>PersistenceProvider</code> auto-detection mechanism (according
to JPA&#8217;s Java SE bootstrapping) and, in most cases, requires you to specify only the
persistence unit name. The following XML example configures such a bean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;
    &lt;bean id="myEmf" class="org.springframework.orm.jpa.LocalEntityManagerFactoryBean"&gt;
        &lt;property name="persistenceUnitName" value="myPersistenceUnit"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This form of JPA deployment is the simplest and the most limited. You cannot refer to an
existing JDBC <code>DataSource</code> bean definition, and no support for global transactions
exists. Furthermore, weaving (byte-code transformation) of persistent classes is
provider-specific, often requiring a specific JVM agent to specified on startup. This
option is sufficient only for stand-alone applications and test environments, for which
the JPA specification is designed.</p>
</div>
</div>
<div class="sect4">
<h5 id="orm-jpa-setup-jndi"><a class="anchor" href="#orm-jpa-setup-jndi"></a>Obtaining an EntityManagerFactory from JNDI</h5>
<div class="paragraph">
<p>You can use this option when deploying to a Java EE server. Check your server&#8217;s documentation
on how to deploy a custom JPA provider into your server, allowing for a different
provider than the server&#8217;s default.</p>
</div>
<div class="paragraph">
<p>Obtaining an <code>EntityManagerFactory</code> from JNDI (for example in a Java EE environment),
is a matter of changing the XML configuration, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;
    &lt;jee:jndi-lookup id="myEmf" jndi-name="persistence/myPersistenceUnit"/&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This action assumes standard Java EE bootstrapping. The Java EE server auto-detects
persistence units (in effect, <code>META-INF/persistence.xml</code> files in application jars) and
<code>persistence-unit-ref</code> entries in the Java EE deployment descriptor (for example,
<code>web.xml</code>) and defines environment naming context locations for those persistence units.</p>
</div>
<div class="paragraph">
<p>In such a scenario, the entire persistence unit deployment, including the weaving
(byte-code transformation) of persistent classes, is up to the Java EE server. The JDBC
<code>DataSource</code> is defined through a JNDI location in the <code>META-INF/persistence.xml</code> file.
<code>EntityManager</code> transactions are integrated with the server&#8217;s JTA subsystem. Spring merely
uses the obtained <code>EntityManagerFactory</code>, passing it on to application objects through
dependency injection and managing transactions for the persistence unit (typically
through <code>JtaTransactionManager</code>).</p>
</div>
<div class="paragraph">
<p>If you use multiple persistence units in the same application, the bean names of such
JNDI-retrieved persistence units should match the persistence unit names that the
application uses to refer to them (for example, in <code>@PersistenceUnit</code> and
<code>@PersistenceContext</code> annotations).</p>
</div>
</div>
<div class="sect4">
<h5 id="orm-jpa-setup-lcemfb"><a class="anchor" href="#orm-jpa-setup-lcemfb"></a>Using <code>LocalContainerEntityManagerFactoryBean</code></h5>
<div class="paragraph">
<p>You can use this option for full JPA capabilities in a Spring-based application environment.
This includes web containers such as Tomcat, stand-alone applications, and
integration tests with sophisticated persistence requirements.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you want to specifically configure a Hibernate setup, an immediate alternative
is to set up a native Hibernate <code>LocalSessionFactoryBean</code> instead of a plain JPA
<code>LocalContainerEntityManagerFactoryBean</code>, letting it interact with JPA access code
as well as native Hibernate access code.
See <a href="#orm-jpa-hibernate">Native Hibernate setup for JPA interaction</a> for details.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>LocalContainerEntityManagerFactoryBean</code> gives full control over
<code>EntityManagerFactory</code> configuration and is appropriate for environments where
fine-grained customization is required. The <code>LocalContainerEntityManagerFactoryBean</code>
creates a <code>PersistenceUnitInfo</code> instance based on the <code>persistence.xml</code> file, the
supplied <code>dataSourceLookup</code> strategy, and the specified <code>loadTimeWeaver</code>. It is, thus,
possible to work with custom data sources outside of JNDI and to control the weaving
process. The following example shows a typical bean definition for a
<code>LocalContainerEntityManagerFactoryBean</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;
    &lt;bean id="myEmf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
        &lt;property name="dataSource" ref="someDataSource"/&gt;
        &lt;property name="loadTimeWeaver"&gt;
            &lt;bean class="org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows a typical <code>persistence.xml</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;persistence xmlns="http://java.sun.com/xml/ns/persistence" version="1.0"&gt;
    &lt;persistence-unit name="myUnit" transaction-type="RESOURCE_LOCAL"&gt;
        &lt;mapping-file&gt;META-INF/orm.xml&lt;/mapping-file&gt;
        &lt;exclude-unlisted-classes/&gt;
    &lt;/persistence-unit&gt;
&lt;/persistence&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>&lt;exclude-unlisted-classes/&gt;</code> shortcut indicates that no scanning for
annotated entity classes is supposed to occur. An explicit 'true' value
(<code>&lt;exclude-unlisted-classes&gt;true&lt;/exclude-unlisted-classes/&gt;</code>) also means no scan.
<code>&lt;exclude-unlisted-classes&gt;false&lt;/exclude-unlisted-classes/&gt;</code> does trigger a scan.
However, we recommend omitting the <code>exclude-unlisted-classes</code> element
if you want entity class scanning to occur.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Using the <code>LocalContainerEntityManagerFactoryBean</code> is the most powerful JPA setup
option, allowing for flexible local configuration within the application. It supports
links to an existing JDBC <code>DataSource</code>, supports both local and global transactions, and
so on. However, it also imposes requirements on the runtime environment, such as the
availability of a weaving-capable class loader if the persistence provider demands
byte-code transformation.</p>
</div>
<div class="paragraph">
<p>This option may conflict with the built-in JPA capabilities of a Java EE server. In a
full Java EE environment, consider obtaining your <code>EntityManagerFactory</code> from JNDI.
Alternatively, specify a custom <code>persistenceXmlLocation</code> on your
<code>LocalContainerEntityManagerFactoryBean</code> definition (for example,
META-INF/my-persistence.xml) and include only a descriptor with that name in your
application jar files. Because the Java EE server looks only for default
<code>META-INF/persistence.xml</code> files, it ignores such custom persistence units and, hence,
avoids conflicts with a Spring-driven JPA setup upfront. (This applies to Resin 3.1, for
example.)</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">When is load-time weaving required?</div>
<div class="paragraph">
<p>Not all JPA providers require a JVM agent. Hibernate is an example of one that does not.
If your provider does not require an agent or you have other alternatives, such as
applying enhancements at build time through a custom compiler or an Ant task, you should not use the
load-time weaver.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>LoadTimeWeaver</code> interface is a Spring-provided class that lets JPA
<code>ClassTransformer</code> instances be plugged in a specific manner, depending on whether the
environment is a web container or application server. Hooking <code>ClassTransformers</code>
through an
<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/instrument/package-summary.html">agent</a>
is typically not efficient. The agents work against the entire virtual machine and
inspect every class that is loaded, which is usually undesirable in a production
server environment.</p>
</div>
<div class="paragraph">
<p>Spring provides a number of <code>LoadTimeWeaver</code> implementations for various environments,
letting <code>ClassTransformer</code> instances be applied only for each class loader and not
for each VM.</p>
</div>
<div class="paragraph">
<p>See the <a href="core.html#aop-aj-ltw-spring">Spring configuration</a> in the AOP chapter for
more insight regarding the <code>LoadTimeWeaver</code> implementations and their setup, either
generic or customized to various platforms (such as Tomcat, JBoss and WebSphere).</p>
</div>
<div class="paragraph">
<p>As described in <a href="core.html#aop-aj-ltw-spring">Spring configuration</a>, you can configure
a context-wide <code>LoadTimeWeaver</code> by using the <code>@EnableLoadTimeWeaving</code> annotation of the
<code>context:load-time-weaver</code> XML element. Such a global weaver is automatically picked up
by all JPA <code>LocalContainerEntityManagerFactoryBean</code> instances. The following example
shows the preferred way of setting up a load-time weaver, delivering auto-detection
of the platform (e.g. Tomcat&#8217;s weaving-capable class loader or Spring&#8217;s JVM agent)
and automatic propagation of the weaver to all weaver-aware beans:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;context:load-time-weaver/&gt;
&lt;bean id="emf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
    ...
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, you can, if needed, manually specify a dedicated weaver through the
<code>loadTimeWeaver</code> property, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="emf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
    &lt;property name="loadTimeWeaver"&gt;
        &lt;bean class="org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>No matter how the LTW is configured, by using this technique, JPA applications relying on
instrumentation can run in the target platform (for example, Tomcat) without needing an agent.
This is especially important when the hosting applications rely on different JPA
implementations, because the JPA transformers are applied only at the class-loader level and
are, thus, isolated from each other.</p>
</div>
</div>
<div class="sect4">
<h5 id="orm-jpa-setup-multiple"><a class="anchor" href="#orm-jpa-setup-multiple"></a>Dealing with Multiple Persistence Units</h5>
<div class="paragraph">
<p>For applications that rely on multiple persistence units locations (stored in various
JARS in the classpath, for example), Spring offers the <code>PersistenceUnitManager</code> to act as
a central repository and to avoid the persistence units discovery process, which can be
expensive. The default implementation lets multiple locations be specified. These locations are
parsed and later retrieved through the persistence unit name. (By default, the classpath
is searched for <code>META-INF/persistence.xml</code> files.) The following example configures
multiple locations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="pum" class="org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager"&gt;
    &lt;property name="persistenceXmlLocations"&gt;
        &lt;list&gt;
            &lt;value&gt;org/springframework/orm/jpa/domain/persistence-multi.xml&lt;/value&gt;
            &lt;value&gt;classpath:/my/package/**/custom-persistence.xml&lt;/value&gt;
            &lt;value&gt;classpath*:META-INF/persistence.xml&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="dataSources"&gt;
        &lt;map&gt;
            &lt;entry key="localDataSource" value-ref="local-db"/&gt;
            &lt;entry key="remoteDataSource" value-ref="remote-db"/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
    &lt;!-- if no datasource is specified, use this one --&gt;
    &lt;property name="defaultDataSource" ref="remoteDataSource"/&gt;
&lt;/bean&gt;

&lt;bean id="emf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
    &lt;property name="persistenceUnitManager" ref="pum"/&gt;
    &lt;property name="persistenceUnitName" value="myCustomUnit"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The default implementation allows customization of the <code>PersistenceUnitInfo</code> instances
(before they are fed to the JPA provider) either declaratively (through its properties, which
affect all hosted units) or programmatically (through the
<code>PersistenceUnitPostProcessor</code>, which allows persistence unit selection). If no
<code>PersistenceUnitManager</code> is specified, one is created and used internally by
<code>LocalContainerEntityManagerFactoryBean</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="orm-jpa-setup-background"><a class="anchor" href="#orm-jpa-setup-background"></a>Background Bootstrapping</h5>
<div class="paragraph">
<p><code>LocalContainerEntityManagerFactoryBean</code> supports background bootstrapping through
the <code>bootstrapExecutor</code> property, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="emf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
    &lt;property name="bootstrapExecutor"&gt;
        &lt;bean class="org.springframework.core.task.SimpleAsyncTaskExecutor"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The actual JPA provider bootstrapping is handed off to the specified executor and then,
running in parallel, to the application bootstrap thread. The exposed <code>EntityManagerFactory</code>
proxy can be injected into other application components and is even able to respond to
<code>EntityManagerFactoryInfo</code> configuration inspection. However, once the actual JPA provider
is being accessed by other components (for example, calling <code>createEntityManager</code>), those calls
block until the background bootstrapping has completed. In particular, when you use
Spring Data JPA, make sure to set up deferred bootstrapping for its repositories as well.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="orm-jpa-dao"><a class="anchor" href="#orm-jpa-dao"></a>6.4.2. Implementing DAOs Based on JPA: <code>EntityManagerFactory</code> and <code>EntityManager</code></h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Although <code>EntityManagerFactory</code> instances are thread-safe, <code>EntityManager</code> instances are
not. The injected JPA <code>EntityManager</code> behaves like an <code>EntityManager</code> fetched from an
application server&#8217;s JNDI environment, as defined by the JPA specification. It delegates
all calls to the current transactional <code>EntityManager</code>, if any. Otherwise, it falls back
to a newly created <code>EntityManager</code> per operation, in effect making its usage thread-safe.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>It is possible to write code against the plain JPA without any Spring dependencies, by
using an injected <code>EntityManagerFactory</code> or <code>EntityManager</code>. Spring can understand the
<code>@PersistenceUnit</code> and <code>@PersistenceContext</code> annotations both at the field and the method level
if a <code>PersistenceAnnotationBeanPostProcessor</code> is enabled. The following example shows a plain JPA DAO implementation
that uses the <code>@PersistenceUnit</code> annotation:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class ProductDaoImpl implements ProductDao {

    private EntityManagerFactory emf;

    @PersistenceUnit
    public void setEntityManagerFactory(EntityManagerFactory emf) {
        this.emf = emf;
    }

    public Collection loadProductsByCategory(String category) {
        try (EntityManager em = this.emf.createEntityManager()) {
            Query query = em.createQuery("from Product as p where p.category = ?1");
            query.setParameter(1, category);
            return query.getResultList();
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class ProductDaoImpl : ProductDao {

    private lateinit var emf: EntityManagerFactory

    @PersistenceUnit
    fun setEntityManagerFactory(emf: EntityManagerFactory) {
        this.emf = emf
    }

    fun loadProductsByCategory(category: String): Collection&lt;*&gt; {
        val em = this.emf.createEntityManager()
        val query = em.createQuery("from Product as p where p.category = ?1");
        query.setParameter(1, category);
        return query.resultList;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding DAO has no dependency on Spring and still fits nicely into a Spring
application context. Moreover, the DAO takes advantage of annotations to require the
injection of the default <code>EntityManagerFactory</code>, as the following example bean definition shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;

    &lt;!-- bean post-processor for JPA annotations --&gt;
    &lt;bean class="org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor"/&gt;

    &lt;bean id="myProductDao" class="product.ProductDaoImpl"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>As an alternative to explicitly defining a <code>PersistenceAnnotationBeanPostProcessor</code>,
consider using the Spring <code>context:annotation-config</code> XML element in your application
context configuration. Doing so automatically registers all Spring standard
post-processors for annotation-based configuration, including
<code>CommonAnnotationBeanPostProcessor</code> and so on.</p>
</div>
<div class="paragraph">
<p>Consider the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;

    &lt;!-- post-processors for all standard config annotations --&gt;
    &lt;context:annotation-config/&gt;

    &lt;bean id="myProductDao" class="product.ProductDaoImpl"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The main problem with such a DAO is that it always creates a new <code>EntityManager</code> through
the factory. You can avoid this by requesting a transactional <code>EntityManager</code> (also
called a &#8220;shared EntityManager&#8221; because it is a shared, thread-safe proxy for the actual
transactional EntityManager) to be injected instead of the factory. The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class ProductDaoImpl implements ProductDao {

    @PersistenceContext
    private EntityManager em;

    public Collection loadProductsByCategory(String category) {
        Query query = em.createQuery("from Product as p where p.category = :category");
        query.setParameter("category", category);
        return query.getResultList();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class ProductDaoImpl : ProductDao {

    @PersistenceContext
    private lateinit var em: EntityManager

    fun loadProductsByCategory(category: String): Collection&lt;*&gt; {
        val query = em.createQuery("from Product as p where p.category = :category")
        query.setParameter("category", category)
        return query.resultList
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@PersistenceContext</code> annotation has an optional attribute called <code>type</code>, which defaults to
<code>PersistenceContextType.TRANSACTION</code>. You can use this default to receive a shared
<code>EntityManager</code> proxy. The alternative, <code>PersistenceContextType.EXTENDED</code>, is a completely
different affair. This results in a so-called extended <code>EntityManager</code>, which is not
thread-safe and, hence, must not be used in a concurrently accessed component, such as a
Spring-managed singleton bean. Extended <code>EntityManager</code> instances are only supposed to be used in
stateful components that, for example, reside in a session, with the lifecycle of the
<code>EntityManager</code> not tied to a current transaction but rather being completely up to the
application.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Method- and field-level Injection</div>
<div class="paragraph">
<p>You can apply annotations that indicate dependency injections (such as <code>@PersistenceUnit</code> and
<code>@PersistenceContext</code>) on field or methods inside a class&#8201;&#8212;&#8201;hence the
expressions &#8220;method-level injection&#8221; and &#8220;field-level injection&#8221;. Field-level
annotations are concise and easier to use while method-level annotations allow for further
processing of the injected dependency. In both cases, the member visibility (public,
protected, or private) does not matter.</p>
</div>
<div class="paragraph">
<p>What about class-level annotations?</p>
</div>
<div class="paragraph">
<p>On the Java EE platform, they are used for dependency declaration and not for resource
injection.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>The injected <code>EntityManager</code> is Spring-managed (aware of the ongoing transaction).
Even though the new DAO implementation uses method-level
injection of an <code>EntityManager</code> instead of an <code>EntityManagerFactory</code>, no change is
required in the application context XML, due to annotation usage.</p>
</div>
<div class="paragraph">
<p>The main advantage of this DAO style is that it depends only on the Java Persistence API.
No import of any Spring class is required. Moreover, as the JPA annotations are understood,
the injections are applied automatically by the Spring container. This is appealing from
a non-invasiveness perspective and can feel more natural to JPA developers.</p>
</div>
</div>
<div class="sect3">
<h4 id="orm-jpa-tx"><a class="anchor" href="#orm-jpa-tx"></a>6.4.3. Spring-driven JPA transactions</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
We strongly encourage you to read <a href="#transaction-declarative">Declarative Transaction Management</a>, if you have not
already done so, to get more detailed coverage of Spring&#8217;s declarative transaction support.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The recommended strategy for JPA is local transactions through JPA&#8217;s native transaction
support. Spring&#8217;s <code>JpaTransactionManager</code> provides many capabilities known from local
JDBC transactions (such as transaction-specific isolation levels and resource-level
read-only optimizations) against any regular JDBC connection pool (no XA requirement).</p>
</div>
<div class="paragraph">
<p>Spring JPA also lets a configured <code>JpaTransactionManager</code> expose a JPA transaction
to JDBC access code that accesses the same <code>DataSource</code>, provided that the registered
<code>JpaDialect</code> supports retrieval of the underlying JDBC <code>Connection</code>.
Spring provides dialects for the EclipseLink and Hibernate JPA implementations.
See the <a href="#orm-jpa-dialect">next section</a> for details on the <code>JpaDialect</code> mechanism.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As an immediate alternative, Spring&#8217;s native <code>HibernateTransactionManager</code> is capable
of interacting with JPA access code, adapting to several Hibernate specifics and providing
JDBC interaction. This makes particular sense in combination with <code>LocalSessionFactoryBean</code>
setup. See <a href="#orm-jpa-hibernate">Native Hibernate Setup for JPA Interaction</a> for details.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="orm-jpa-dialect"><a class="anchor" href="#orm-jpa-dialect"></a>6.4.4. Understanding <code>JpaDialect</code> and <code>JpaVendorAdapter</code></h4>
<div class="paragraph">
<p>As an advanced feature, <code>JpaTransactionManager</code> and subclasses of
<code>AbstractEntityManagerFactoryBean</code> allow a custom <code>JpaDialect</code> to be passed into the
<code>jpaDialect</code> bean property. A <code>JpaDialect</code> implementation can enable the following advanced
features supported by Spring, usually in a vendor-specific manner:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Applying specific transaction semantics (such as custom isolation level or transaction
timeout)</p>
</li>
<li>
<p>Retrieving the transactional JDBC <code>Connection</code> (for exposure to JDBC-based DAOs)</p>
</li>
<li>
<p>Advanced translation of <code>PersistenceExceptions</code> to Spring <code>DataAccessExceptions</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This is particularly valuable for special transaction semantics and for advanced
translation of exception. The default implementation (<code>DefaultJpaDialect</code>) does
not provide any special abilities and, if the features listed earlier are required, you have
to specify the appropriate dialect.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
As an even broader provider adaptation facility primarily for Spring&#8217;s full-featured
<code>LocalContainerEntityManagerFactoryBean</code> setup, <code>JpaVendorAdapter</code> combines the
capabilities of <code>JpaDialect</code> with other provider-specific defaults. Specifying a
<code>HibernateJpaVendorAdapter</code> or <code>EclipseLinkJpaVendorAdapter</code> is the most convenient
way of auto-configuring an <code>EntityManagerFactory</code> setup for Hibernate or EclipseLink,
respectively. Note that those provider adapters are primarily designed for use with
Spring-driven transaction management (that is, for use with <code>JpaTransactionManager</code>).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>See the <a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/orm/jpa/JpaDialect.html"><code>JpaDialect</code></a> and
<a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/orm/jpa/JpaVendorAdapter.html"><code>JpaVendorAdapter</code></a> javadoc for
more details of its operations and how they are used within Spring&#8217;s JPA support.</p>
</div>
</div>
<div class="sect3">
<h4 id="orm-jpa-jta"><a class="anchor" href="#orm-jpa-jta"></a>6.4.5. Setting up JPA with JTA Transaction Management</h4>
<div class="paragraph">
<p>As an alternative to <code>JpaTransactionManager</code>, Spring also allows for multi-resource
transaction coordination through JTA, either in a Java EE environment or with a
stand-alone transaction coordinator, such as Atomikos. Aside from choosing Spring&#8217;s
<code>JtaTransactionManager</code> instead of <code>JpaTransactionManager</code>, you need to take few further
steps:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The underlying JDBC connection pools need to be XA-capable and be integrated with
your transaction coordinator. This is usually straightforward in a Java EE environment,
exposing a different kind of <code>DataSource</code> through JNDI. See your application server
documentation for details. Analogously, a standalone transaction coordinator usually
comes with special XA-integrated <code>DataSource</code> variants. Again, check its documentation.</p>
</li>
<li>
<p>The JPA <code>EntityManagerFactory</code> setup needs to be configured for JTA. This is
provider-specific, typically through special properties to be specified as <code>jpaProperties</code>
on <code>LocalContainerEntityManagerFactoryBean</code>. In the case of Hibernate, these properties
are even version-specific. See your Hibernate documentation for details.</p>
</li>
<li>
<p>Spring&#8217;s <code>HibernateJpaVendorAdapter</code> enforces certain Spring-oriented defaults, such
as the connection release mode, <code>on-close</code>, which matches Hibernate&#8217;s own default in
Hibernate 5.0 but not any more in Hibernate 5.1+. For a JTA setup, make sure to declare
your persistence unit transaction type as "JTA". Alternatively, set Hibernate 5.2&#8217;s
<code>hibernate.connection.handling_mode</code> property to
<code>DELAYED_ACQUISITION_AND_RELEASE_AFTER_STATEMENT</code> to restore Hibernate&#8217;s own default.
See <a href="#orm-hibernate-invalid-jdbc-access-error">Spurious Application Server Warnings with Hibernate</a> for related notes.</p>
</li>
<li>
<p>Alternatively, consider obtaining the <code>EntityManagerFactory</code> from your application
server itself (that is, through a JNDI lookup instead of a locally declared
<code>LocalContainerEntityManagerFactoryBean</code>). A server-provided <code>EntityManagerFactory</code>
might require special definitions in your server configuration (making the deployment
less portable) but is set up for the server&#8217;s JTA environment.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="orm-jpa-hibernate"><a class="anchor" href="#orm-jpa-hibernate"></a>6.4.6. Native Hibernate Setup and Native Hibernate Transactions for JPA Interaction</h4>
<div class="paragraph">
<p>A native <code>LocalSessionFactoryBean</code> setup in combination with <code>HibernateTransactionManager</code>
allows for interaction with <code>@PersistenceContext</code> and other JPA access code. A Hibernate
<code>SessionFactory</code> natively implements JPA&#8217;s <code>EntityManagerFactory</code> interface now
and a Hibernate <code>Session</code> handle natively is a JPA <code>EntityManager</code>.
Spring&#8217;s JPA support facilities automatically detect native Hibernate sessions.</p>
</div>
<div class="paragraph">
<p>Such native Hibernate setup can, therefore, serve as a replacement for a standard JPA
<code>LocalContainerEntityManagerFactoryBean</code> and <code>JpaTransactionManager</code> combination
in many scenarios, allowing for interaction with <code>SessionFactory.getCurrentSession()</code>
(and also <code>HibernateTemplate</code>) next to <code>@PersistenceContext EntityManager</code> within
the same local transaction. Such a setup also provides stronger Hibernate integration
and more configuration flexibility, because it is not constrained by JPA bootstrap contracts.</p>
</div>
<div class="paragraph">
<p>You do not need <code>HibernateJpaVendorAdapter</code> configuration in such a scenario,
since Spring&#8217;s native Hibernate setup provides even more features
(for example, custom Hibernate Integrator setup, Hibernate 5.3 bean container integration,
and stronger optimizations for read-only transactions). Last but not least, you can also
express native Hibernate setup through <code>LocalSessionFactoryBuilder</code>,
seamlessly integrating with <code>@Bean</code> style configuration (no <code>FactoryBean</code> involved).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>LocalSessionFactoryBean</code> and <code>LocalSessionFactoryBuilder</code> support background
bootstrapping, just as the JPA <code>LocalContainerEntityManagerFactoryBean</code> does.
See <a href="#orm-jpa-setup-background">Background Bootstrapping</a> for an introduction.</p>
</div>
<div class="paragraph">
<p>On <code>LocalSessionFactoryBean</code>, this is available through the <code>bootstrapExecutor</code>
property. On the programmatic <code>LocalSessionFactoryBuilder</code>, an overloaded
<code>buildSessionFactory</code> method takes a bootstrap executor argument.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="oxm"><a class="anchor" href="#oxm"></a>7. Marshalling XML by Using Object-XML Mappers</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="oxm-introduction"><a class="anchor" href="#oxm-introduction"></a>7.1. Introduction</h3>
<div class="paragraph">
<p>This chapter, describes Spring&#8217;s Object-XML Mapping support. Object-XML
Mapping (O-X mapping for short) is the act of converting an XML document to and from
an object. This conversion process is also known as XML Marshalling, or XML
Serialization. This chapter uses these terms interchangeably.</p>
</div>
<div class="paragraph">
<p>Within the field of O-X mapping, a marshaller is responsible for serializing an
object (graph) to XML. In similar fashion, an unmarshaller deserializes the XML to
an object graph. This XML can take the form of a DOM document, an input or output
stream, or a SAX handler.</p>
</div>
<div class="paragraph">
<p>Some of the benefits of using Spring for your O/X mapping needs are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#oxm-ease-of-configuration">Ease of configuration</a></p>
</li>
<li>
<p><a href="#oxm-consistent-interfaces">Consistent Interfaces</a></p>
</li>
<li>
<p><a href="#oxm-consistent-exception-hierarchy">Consistent Exception Hierarchy</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="oxm-ease-of-configuration"><a class="anchor" href="#oxm-ease-of-configuration"></a>7.1.1. Ease of configuration</h4>
<div class="paragraph">
<p>Spring&#8217;s bean factory makes it easy to configure marshallers, without needing to
construct JAXB context, JiBX binding factories, and so on. You can configure the marshallers
as you would any other bean in your application context. Additionally, XML namespace-based
configuration is available for a number of marshallers, making the configuration even
simpler.</p>
</div>
</div>
<div class="sect3">
<h4 id="oxm-consistent-interfaces"><a class="anchor" href="#oxm-consistent-interfaces"></a>7.1.2. Consistent Interfaces</h4>
<div class="paragraph">
<p>Spring&#8217;s O-X mapping operates through two global interfaces: <a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/oxm/Marshaller.html"><code>Marshaller</code></a> and
<a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/oxm/Unmarshaller.html"><code>Unmarshaller</code></a>. These abstractions let you switch O-X mapping frameworks
with relative ease, with little or no change required on the classes that do the
marshalling. This approach has the additional benefit of making it possible to do XML
marshalling with a mix-and-match approach (for example, some marshalling performed using JAXB
and some by XStream) in a non-intrusive fashion, letting you use the strength of each
technology.</p>
</div>
</div>
<div class="sect3">
<h4 id="oxm-consistent-exception-hierarchy"><a class="anchor" href="#oxm-consistent-exception-hierarchy"></a>7.1.3. Consistent Exception Hierarchy</h4>
<div class="paragraph">
<p>Spring provides a conversion from exceptions from the underlying O-X mapping tool to its
own exception hierarchy with the <code>XmlMappingException</code> as the root exception.
These runtime exceptions wrap the original exception so that no information is lost.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="oxm-marshaller-unmarshaller"><a class="anchor" href="#oxm-marshaller-unmarshaller"></a>7.2. <code>Marshaller</code> and <code>Unmarshaller</code></h3>
<div class="paragraph">
<p>As stated in the <a href="#oxm-introduction">introduction</a>, a marshaller serializes an object
to XML, and an unmarshaller deserializes XML stream to an object. This section describes
the two Spring interfaces used for this purpose.</p>
</div>
<div class="sect3">
<h4 id="oxm-marshaller"><a class="anchor" href="#oxm-marshaller"></a>7.2.1. Understanding <code>Marshaller</code></h4>
<div class="paragraph">
<p>Spring abstracts all marshalling operations behind the
<code>org.springframework.oxm.Marshaller</code> interface, the main method of which follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface Marshaller {

    /**
     * Marshal the object graph with the given root into the provided Result.
     */
    void marshal(Object graph, Result result) throws XmlMappingException, IOException;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Marshaller</code> interface has one main method, which marshals the given object to a
given <code>javax.xml.transform.Result</code>. The result is a tagging interface that basically
represents an XML output abstraction. Concrete implementations wrap various XML
representations, as the following table indicates:</p>
</div>
<table id="oxm-marshller-tbl" class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Result implementation</th>
<th class="tableblock halign-left valign-top">Wraps XML representation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DOMResult</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.w3c.dom.Node</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SAXResult</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.xml.sax.ContentHandler</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StreamResult</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.io.File</code>, <code>java.io.OutputStream</code>, or <code>java.io.Writer</code></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Although the <code>marshal()</code> method accepts a plain object as its first parameter, most
<code>Marshaller</code> implementations cannot handle arbitrary objects. Instead, an object class
must be mapped in a mapping file, be marked with an annotation, be registered with the
marshaller, or have a common base class. Refer to the later sections in this chapter
to determine how your O-X technology manages this.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="oxm-unmarshaller"><a class="anchor" href="#oxm-unmarshaller"></a>7.2.2. Understanding <code>Unmarshaller</code></h4>
<div class="paragraph">
<p>Similar to the <code>Marshaller</code>, we have the <code>org.springframework.oxm.Unmarshaller</code>
interface, which the following listing shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface Unmarshaller {

    /**
     * Unmarshal the given provided Source into an object graph.
     */
    Object unmarshal(Source source) throws XmlMappingException, IOException;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This interface also has one method, which reads from the given
<code>javax.xml.transform.Source</code> (an XML input abstraction) and returns the object read. As
with <code>Result</code>, <code>Source</code> is a tagging interface that has three concrete implementations. Each
wraps a different XML representation, as the following table indicates:</p>
</div>
<table id="oxm-unmarshller-tbl" class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Source implementation</th>
<th class="tableblock halign-left valign-top">Wraps XML representation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DOMSource</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.w3c.dom.Node</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SAXSource</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.xml.sax.InputSource</code>, and <code>org.xml.sax.XMLReader</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StreamSource</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.io.File</code>, <code>java.io.InputStream</code>, or <code>java.io.Reader</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Even though there are two separate marshalling interfaces (<code>Marshaller</code> and
<code>Unmarshaller</code>), all implementations in Spring-WS implement both in one class.
This means that you can wire up one marshaller class and refer to it both as a
marshaller and as an unmarshaller in your <code>applicationContext.xml</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="oxm-xmlmappingexception"><a class="anchor" href="#oxm-xmlmappingexception"></a>7.2.3. Understanding <code>XmlMappingException</code></h4>
<div class="paragraph">
<p>Spring converts exceptions from the underlying O-X mapping tool to its own exception
hierarchy with the <code>XmlMappingException</code> as the root exception.
These runtime exceptions wrap the original exception so that no information will be lost.</p>
</div>
<div class="paragraph">
<p>Additionally, the <code>MarshallingFailureException</code> and <code>UnmarshallingFailureException</code>
provide a distinction between marshalling and unmarshalling operations, even though the
underlying O-X mapping tool does not do so.</p>
</div>
<div class="paragraph">
<p>The O-X Mapping exception hierarchy is shown in the following figure:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/oxm-exceptions.png" alt="oxm exceptions">
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="oxm-usage"><a class="anchor" href="#oxm-usage"></a>7.3. Using <code>Marshaller</code> and <code>Unmarshaller</code></h3>
<div class="paragraph">
<p>You can use Spring&#8217;s OXM for a wide variety of situations. In the following example, we
use it to marshal the settings of a Spring-managed application as an XML file. In the following example, we
use a simple JavaBean to represent the settings:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class Settings {

    private boolean fooEnabled;

    public boolean isFooEnabled() {
        return fooEnabled;
    }

    public void setFooEnabled(boolean fooEnabled) {
        this.fooEnabled = fooEnabled;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class Settings {
    var isFooEnabled: Boolean = false
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The application class uses this bean to store its settings. Besides a main method, the
class has two methods: <code>saveSettings()</code> saves the settings bean to a file named
<code>settings.xml</code>, and <code>loadSettings()</code> loads these settings again. The following <code>main()</code> method
constructs a Spring application context and calls these two methods:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.oxm.Marshaller;
import org.springframework.oxm.Unmarshaller;

public class Application {

    private static final String FILE_NAME = "settings.xml";
    private Settings settings = new Settings();
    private Marshaller marshaller;
    private Unmarshaller unmarshaller;

    public void setMarshaller(Marshaller marshaller) {
        this.marshaller = marshaller;
    }

    public void setUnmarshaller(Unmarshaller unmarshaller) {
        this.unmarshaller = unmarshaller;
    }

    public void saveSettings() throws IOException {
        try (FileOutputStream os = new FileOutputStream(FILE_NAME)) {
            this.marshaller.marshal(settings, new StreamResult(os));
        }
    }

    public void loadSettings() throws IOException {
        try (FileInputStream is = new FileInputStream(FILE_NAME)) {
            this.settings = (Settings) this.unmarshaller.unmarshal(new StreamSource(is));
        }
    }

    public static void main(String[] args) throws IOException {
        ApplicationContext appContext =
                new ClassPathXmlApplicationContext("applicationContext.xml");
        Application application = (Application) appContext.getBean("application");
        application.saveSettings();
        application.loadSettings();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class Application {

    lateinit var marshaller: Marshaller

    lateinit var unmarshaller: Unmarshaller

    fun saveSettings() {
        FileOutputStream(FILE_NAME).use { outputStream -&gt; marshaller.marshal(settings, StreamResult(outputStream)) }
    }

    fun loadSettings() {
        FileInputStream(FILE_NAME).use { inputStream -&gt; settings = unmarshaller.unmarshal(StreamSource(inputStream)) as Settings }
    }
}

private const val FILE_NAME = "settings.xml"

fun main(args: Array&lt;String&gt;) {
    val appContext = ClassPathXmlApplicationContext("applicationContext.xml")
    val application = appContext.getBean("application") as Application
    application.saveSettings()
    application.loadSettings()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Application</code> requires both a <code>marshaller</code> and an <code>unmarshaller</code> property to be set. We
can do so by using the following <code>applicationContext.xml</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;
    &lt;bean id="application" class="Application"&gt;
        &lt;property name="marshaller" ref="xstreamMarshaller" /&gt;
        &lt;property name="unmarshaller" ref="xstreamMarshaller" /&gt;
    &lt;/bean&gt;
    &lt;bean id="xstreamMarshaller" class="org.springframework.oxm.xstream.XStreamMarshaller"/&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This application context uses XStream, but we could have used any of the other marshaller
instances described later in this chapter. Note that, by default, XStream does not require
any further configuration, so the bean definition is rather simple. Also note that the
<code>XStreamMarshaller</code> implements both <code>Marshaller</code> and <code>Unmarshaller</code>, so we can refer to the
<code>xstreamMarshaller</code> bean in both the <code>marshaller</code> and <code>unmarshaller</code> property of the
application.</p>
</div>
<div class="paragraph">
<p>This sample application produces the following <code>settings.xml</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;settings foo-enabled="false"/&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="oxm-schema-based-config"><a class="anchor" href="#oxm-schema-based-config"></a>7.4. XML Configuration Namespace</h3>
<div class="paragraph">
<p>You can configure marshallers more concisely by using tags from the OXM namespace.
To make these tags available, you must first reference the appropriate schema in the
preamble of the XML configuration file. The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:oxm="http://www.springframework.org/schema/oxm" <i class="conum" data-value="1"></i><b>(1)</b>
xsi:schemaLocation="http://www.springframework.org/schema/beans
  https://www.springframework.org/schema/beans/spring-beans.xsd
  http://www.springframework.org/schema/oxm https://www.springframework.org/schema/oxm/spring-oxm.xsd"&gt; <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Reference the <code>oxm</code> schema.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Specify the <code>oxm</code> schema location.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The schema makes the following elements available:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#oxm-jaxb2-xsd"><code>jaxb2-marshaller</code></a></p>
</li>
<li>
<p><a href="#oxm-jibx-xsd"><code>jibx-marshaller</code></a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Each tag is explained in its respective marshaller&#8217;s section. As an example, though,
the configuration of a JAXB2 marshaller might resemble the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;oxm:jaxb2-marshaller id="marshaller" contextPath="org.springframework.ws.samples.airline.schema"/&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="oxm-jaxb"><a class="anchor" href="#oxm-jaxb"></a>7.5. JAXB</h3>
<div class="paragraph">
<p>The JAXB binding compiler translates a W3C XML Schema into one or more Java classes, a
<code>jaxb.properties</code> file, and possibly some resource files. JAXB also offers a way to
generate a schema from annotated Java classes.</p>
</div>
<div class="paragraph">
<p>Spring supports the JAXB 2.0 API as XML marshalling strategies, following the
<code>Marshaller</code> and <code>Unmarshaller</code> interfaces described in <a href="#oxm-marshaller-unmarshaller"><code>Marshaller</code> and <code>Unmarshaller</code></a>.
The corresponding integration classes reside in the <code>org.springframework.oxm.jaxb</code>
package.</p>
</div>
<div class="sect3">
<h4 id="oxm-jaxb2"><a class="anchor" href="#oxm-jaxb2"></a>7.5.1. Using <code>Jaxb2Marshaller</code></h4>
<div class="paragraph">
<p>The <code>Jaxb2Marshaller</code> class implements both of Spring&#8217;s <code>Marshaller</code> and <code>Unmarshaller</code>
interfaces. It requires a context path to operate. You can set the context path by setting the
<code>contextPath</code> property. The context path is a list of colon-separated Java package
names that contain schema derived classes. It also offers a <code>classesToBeBound</code> property,
which allows you to set an array of classes to be supported by the marshaller. Schema
validation is performed by specifying one or more schema resources to the bean, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;
    &lt;bean id="jaxb2Marshaller" class="org.springframework.oxm.jaxb.Jaxb2Marshaller"&gt;
        &lt;property name="classesToBeBound"&gt;
            &lt;list&gt;
                &lt;value&gt;org.springframework.oxm.jaxb.Flight&lt;/value&gt;
                &lt;value&gt;org.springframework.oxm.jaxb.Flights&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="schema" value="classpath:org/springframework/oxm/schema.xsd"/&gt;
    &lt;/bean&gt;

    ...

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="oxm-jaxb2-xsd"><a class="anchor" href="#oxm-jaxb2-xsd"></a>XML Configuration Namespace</h5>
<div class="paragraph">
<p>The <code>jaxb2-marshaller</code> element configures a <code>org.springframework.oxm.jaxb.Jaxb2Marshaller</code>,
as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;oxm:jaxb2-marshaller id="marshaller" contextPath="org.springframework.ws.samples.airline.schema"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, you can provide the list of classes to bind to the marshaller by using the
<code>class-to-be-bound</code> child element:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;oxm:jaxb2-marshaller id="marshaller"&gt;
    &lt;oxm:class-to-be-bound name="org.springframework.ws.samples.airline.schema.Airport"/&gt;
    &lt;oxm:class-to-be-bound name="org.springframework.ws.samples.airline.schema.Flight"/&gt;
    ...
&lt;/oxm:jaxb2-marshaller&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following table describes the available attributes:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Required</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>id</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The ID of the marshaller</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>contextPath</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The JAXB Context path</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="oxm-jibx"><a class="anchor" href="#oxm-jibx"></a>7.6. JiBX</h3>
<div class="paragraph">
<p>The JiBX framework offers a solution similar to that which Hibernate provides for ORM: A
binding definition defines the rules for how your Java objects are converted to or from
XML. After preparing the binding and compiling the classes, a JiBX binding compiler
enhances the class files and adds code to handle converting instances of the classes
from or to XML.</p>
</div>
<div class="paragraph">
<p>For more information on JiBX, see the <a href="http://jibx.sourceforge.net/">JiBX web
site</a>. The Spring integration classes reside in the <code>org.springframework.oxm.jibx</code>
package.</p>
</div>
<div class="sect3">
<h4 id="oxm-jibx-marshaller"><a class="anchor" href="#oxm-jibx-marshaller"></a>7.6.1. Using <code>JibxMarshaller</code></h4>
<div class="paragraph">
<p>The <code>JibxMarshaller</code> class implements both the <code>Marshaller</code> and <code>Unmarshaller</code>
interface. To operate, it requires the name of the class to marshal in, which you can
set using the <code>targetClass</code> property. Optionally, you can set the binding name by setting the
<code>bindingName</code> property. In the following example, we bind the <code>Flights</code> class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;
    &lt;bean id="jibxFlightsMarshaller" class="org.springframework.oxm.jibx.JibxMarshaller"&gt;
        &lt;property name="targetClass"&gt;org.springframework.oxm.jibx.Flights&lt;/property&gt;
    &lt;/bean&gt;
    ...
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A <code>JibxMarshaller</code> is configured for a single class. If you want to marshal multiple
classes, you have to configure multiple <code>JibxMarshaller</code> instances with different <code>targetClass</code>
property values.</p>
</div>
<div class="sect4">
<h5 id="oxm-jibx-xsd"><a class="anchor" href="#oxm-jibx-xsd"></a>XML Configuration Namespace</h5>
<div class="paragraph">
<p>The <code>jibx-marshaller</code> tag configures a <code>org.springframework.oxm.jibx.JibxMarshaller</code>,
as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;oxm:jibx-marshaller id="marshaller" target-class="org.springframework.ws.samples.airline.schema.Flight"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following table describes the available attributes:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Required</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>id</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The ID of the marshaller</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>target-class</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The target class for this marshaller</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bindingName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The binding name used by this marshaller</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="oxm-xstream"><a class="anchor" href="#oxm-xstream"></a>7.7. XStream</h3>
<div class="paragraph">
<p>XStream is a simple library to serialize objects to XML and back again. It does not
require any mapping and generates clean XML.</p>
</div>
<div class="paragraph">
<p>For more information on XStream, see the <a href="https://x-stream.github.io/">XStream
web site</a>. The Spring integration classes reside in the
<code>org.springframework.oxm.xstream</code> package.</p>
</div>
<div class="sect3">
<h4 id="oxm-xstream-marshaller"><a class="anchor" href="#oxm-xstream-marshaller"></a>7.7.1. Using <code>XStreamMarshaller</code></h4>
<div class="paragraph">
<p>The <code>XStreamMarshaller</code> does not require any configuration and can be configured in an
application context directly. To further customize the XML, you can set an alias map,
which consists of string aliases mapped to classes, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;
    &lt;bean id="xstreamMarshaller" class="org.springframework.oxm.xstream.XStreamMarshaller"&gt;
        &lt;property name="aliases"&gt;
            &lt;props&gt;
                &lt;prop key="Flight"&gt;org.springframework.oxm.xstream.Flight&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    ...
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>By default, XStream lets arbitrary classes be unmarshalled, which can lead to
unsafe Java serialization effects. As such, we do not recommend using the
<code>XStreamMarshaller</code> to unmarshal XML from external sources (that is, the Web), as this can
result in security vulnerabilities.</p>
</div>
<div class="paragraph">
<p>If you choose to use the <code>XStreamMarshaller</code> to unmarshal XML from an external source,
set the <code>supportedClasses</code> property on the <code>XStreamMarshaller</code>, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="xstreamMarshaller" class="org.springframework.oxm.xstream.XStreamMarshaller"&gt;
    &lt;property name="supportedClasses" value="org.springframework.oxm.xstream.Flight"/&gt;
    ...
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Doing so ensures that only the registered classes are eligible for unmarshalling.</p>
</div>
<div class="paragraph">
<p>Additionally, you can register
<a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/oxm/xstream/XStreamMarshaller.html#setConverters(com.thoughtworks.xstream.converters.ConverterMatcher&#8230;&#8203;)">custom
converters</a> to make sure that only your supported classes can be unmarshalled. You might
want to add a <code>CatchAllConverter</code> as the last converter in the list, in addition to
converters that explicitly support the domain classes that should be supported. As a
result, default XStream converters with lower priorities and possible security
vulnerabilities do not get invoked.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Note that XStream is an XML serialization library, not a data binding library.
Therefore, it has limited namespace support. As a result, it is rather unsuitable for usage
within Web Services.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="appendix"><a class="anchor" href="#appendix"></a>8. Appendix</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="xsd-schemas"><a class="anchor" href="#xsd-schemas"></a>8.1. XML Schemas</h3>
<div class="paragraph">
<p>This part of the appendix lists XML schemas for data access, including the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#xsd-schemas-tx">The <code>tx</code> Schema</a></p>
</li>
<li>
<p><a href="#xsd-schemas-jdbc">The <code>jdbc</code> Schema</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="xsd-schemas-tx"><a class="anchor" href="#xsd-schemas-tx"></a>8.1.1. The <code>tx</code> Schema</h4>
<div class="paragraph">
<p>The <code>tx</code> tags deal with configuring all of those beans in Spring&#8217;s comprehensive support
for transactions. These tags are covered in the chapter entitled
<a href="#transaction">Transaction Management</a>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
We strongly encourage you to look at the <code>'spring-tx.xsd'</code> file that ships with the
Spring distribution. This file contains the XML Schema for Spring&#8217;s transaction
configuration and covers all of the various elements in the <code>tx</code> namespace, including
attribute defaults and similar information. This file is documented inline, and, thus,
the information is not repeated here in the interests of adhering to the DRY (Don&#8217;t
Repeat Yourself) principle.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the interest of completeness, to use the elements in the <code>tx</code> schema, you need to have
the following preamble at the top of your Spring XML configuration file. The text in the
following snippet references the correct schema so that the tags in the <code>tx</code> namespace
are available to you:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:tx="http://www.springframework.org/schema/tx" <i class="conum" data-value="1"></i><b>(1)</b>
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd <i class="conum" data-value="2"></i><b>(2)</b>
        http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd"&gt;

    &lt;!-- bean definitions here --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Declare usage of the <code>tx</code> namespace.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Specify the location (with other schema locations).</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Often, when you use the elements in the <code>tx</code> namespace, you are also using the
elements from the <code>aop</code> namespace (since the declarative transaction support in Spring is
implemented by using AOP). The preceding XML snippet contains the relevant lines needed
to reference the <code>aop</code> schema so that the elements in the <code>aop</code> namespace are available
to you.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="xsd-schemas-jdbc"><a class="anchor" href="#xsd-schemas-jdbc"></a>8.1.2. The <code>jdbc</code> Schema</h4>
<div class="paragraph">
<p>The <code>jdbc</code> elements let you quickly configure an embedded database or initialize an
existing data source. These elements are documented in
<a href="#jdbc-embedded-database-support">Embedded Database Support</a> and
<a href="#jdbc-initializing-datasource">Initializing a DataSource</a>, respectively.</p>
</div>
<div class="paragraph">
<p>To use the elements in the <code>jdbc</code> schema, you need to have the following preamble at the
top of your Spring XML configuration file. The text in the following snippet references
the correct schema so that the elements in the <code>jdbc</code> namespace are available to you:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:jdbc="http://www.springframework.org/schema/jdbc" <i class="conum" data-value="1"></i><b>(1)</b>
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/jdbc https://www.springframework.org/schema/jdbc/spring-jdbc.xsd"&gt; <i class="conum" data-value="2"></i><b>(2)</b>

    &lt;!-- bean definitions here --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Declare usage of the <code>jdbc</code> namespace.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Specify the location (with other schema locations).</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 5.3.9<br>
Last updated 2021-07-14 06:36:18 UTC
</div>
</div>
<link rel="stylesheet" href="js/highlight/styles/googlecode.min.css">
<script src="js/highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
<script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="js/toc.js"></script>
</body>
</html>