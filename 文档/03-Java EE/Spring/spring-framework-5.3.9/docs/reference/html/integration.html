<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>Integration</title>
<style>
@import 'css/spring.css';

.listingblock .switch {
    border-style: none;
    display: inline-block;
    position: relative;
    bottom: -3px;
}

.listingblock .switch--item {
    padding: 10px;
    background-color: #e6e1dc;
    color: #282c34;
    display: inline-block;
    cursor: pointer;
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
}

.listingblock .switch--item:not(:first-child) {
    border-style: none;
}

.listingblock .switch--item.selected {
    background-color: #282c34;
    color: #e6e1dc;
}

.listingblock pre.highlightjs {
    padding: 0;
}

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
.hidden {
	display: none;
}

.switch {
	border-width: 1px 1px 0 1px;
	border-style: solid;
	border-color: #7a2518;
	display: inline-block;
}

.switch--item {
	padding: 10px;
	background-color: #ffffff;
	color: #7a2518;
	display: inline-block;
	cursor: pointer;
}

.switch--item:not(:first-child) {
	border-width: 0 0 0 1px;
	border-style: solid;
	border-color: #7a2518;
}

.switch--item.selected {
	background-color: #7a2519;
	color: #ffffff;
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
<script type="text/javascript">
function addBlockSwitches() {
	$('.primary').each(function() {
		primary = $(this);
		createSwitchItem(primary, createBlockSwitch(primary)).item.addClass("selected");
		primary.children('.title').remove();
	});
	$('.secondary').each(function(idx, node) {
		secondary = $(node);
		primary = findPrimary(secondary);
		switchItem = createSwitchItem(secondary, primary.children('.switch'));
		switchItem.content.addClass('hidden');
		findPrimary(secondary).append(switchItem.content);
		secondary.remove();
	});
}

function createBlockSwitch(primary) {
	blockSwitch = $('<div class="switch"></div>');
	primary.prepend(blockSwitch);
	return blockSwitch;
}

function findPrimary(secondary) {
	candidate = secondary.prev();
	while (!candidate.is('.primary')) {
		candidate = candidate.prev();
	}
	return candidate;
}

function createSwitchItem(block, blockSwitch) {
	blockName = block.children('.title').text();
	content = block.children('.content').first().append(block.next('.colist'));
	item = $('<div class="switch--item">' + blockName + '</div>');
	blockSwitch.append(item);
	return {'item': item, 'content': content};
}

function globalSwitch() {
	$('.switch--item').each(function() {
		var blockId = blockIdForSwitchItem($(this));
		$(this).off('click');
		$(this).on('click', function() {
			selectedText = $(this).text()
			window.localStorage.setItem(blockId, selectedText);
			$(".switch--item").filter(function() {
				return blockIdForSwitchItem($(this)) === blockId;
			}).filter(function() {
				return $(this).text() === selectedText;
			}).each(function() {
				select($(this))
			});
		});
		if ($(this).text() === window.localStorage.getItem(blockId)) {
			select($(this))
		}
	});
}

function blockIdForSwitchItem(item) {
	idComponents = []
	idComponents.push(item.text().toLowerCase());
	item.siblings(".switch--item").each(function(index, sibling) {
		idComponents.push($(sibling).text().toLowerCase());
	});
	return idComponents.sort().join("-")
}

function select(selected) {
	selected.addClass('selected');
	selected.siblings().removeClass('selected');
	selectedContent = selected.parent().siblings(".content").eq(selected.index())
	selectedContent.removeClass('hidden');
	selectedContent.siblings().addClass('hidden');
}

$(addBlockSwitches);
$(globalSwitch);

</script>

</head>
<body id="spring-integration" class="book toc2 toc-left">
<div id="header">
<h1>Spring Framework Documentation</h1>
<span><strong>5.3.9</strong></span>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This part of the reference documentation covers the Spring Framework&#8217;s integration with
a number technologies.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rest-client-access"><a class="anchor" href="#rest-client-access"></a>1. REST Endpoints</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Spring Framework provides two choices for making calls to REST endpoints:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#rest-resttemplate"><code>RestTemplate</code></a>: The original Spring REST client with a synchronous, template
method API.</p>
</li>
<li>
<p><a href="web-reactive.html#webflux-client">WebClient</a>: a non-blocking, reactive alternative
that supports both synchronous and asynchronous as well as streaming scenarios.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As of 5.0 the <code>RestTemplate</code> is in maintenance mode, with only minor requests for
changes and bugs to be accepted going forward. Please, consider using the
<a href="web-reactive.html#webflux-client">WebClient</a> which offers a more modern API and
supports sync, async, and streaming scenarios.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="rest-resttemplate"><a class="anchor" href="#rest-resttemplate"></a>1.1. <code>RestTemplate</code></h3>
<div class="paragraph">
<p>The <code>RestTemplate</code> provides a higher level API over HTTP client libraries. It makes it
easy to invoke REST endpoints in a single line. It exposes the following groups of
overloaded methods:</p>
</div>
<table id="rest-overview-of-resttemplate-methods-tbl" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. RestTemplate methods</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Method group</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>getForObject</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Retrieves a representation via GET.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>getForEntity</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Retrieves a <code>ResponseEntity</code> (that is, status, headers, and body) by using GET.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>headForHeaders</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Retrieves all headers for a resource by using HEAD.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>postForLocation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Creates a new resource by using POST and returns the <code>Location</code> header from the response.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>postForObject</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Creates a new resource by using POST and returns the representation from the response.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>postForEntity</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Creates a new resource by using POST and returns the representation from the response.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>put</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Creates or updates a resource by using PUT.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>patchForObject</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Updates a resource by using PATCH and returns the representation from the response.
Note that the JDK <code>HttpURLConnection</code> does not support the <code>PATCH</code>, but Apache
HttpComponents and others do.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>delete</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Deletes the resources at the specified URI by using DELETE.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>optionsForAllow</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Retrieves allowed HTTP methods for a resource by using ALLOW.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>exchange</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">More generalized (and less opinionated) version of the preceding methods that provides extra
flexibility when needed. It accepts a <code>RequestEntity</code> (including HTTP method, URL, headers,
and body as input) and returns a <code>ResponseEntity</code>.</p>
<p class="tableblock">These methods allow the use of <code>ParameterizedTypeReference</code> instead of <code>Class</code> to specify
a response type with generics.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>execute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The most generalized way to perform a request, with full control over request
preparation and response extraction through callback interfaces.</p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="rest-resttemplate-create"><a class="anchor" href="#rest-resttemplate-create"></a>1.1.1. Initialization</h4>
<div class="paragraph">
<p>The default constructor uses <code>java.net.HttpURLConnection</code> to perform requests. You can
switch to a different HTTP library with an implementation of <code>ClientHttpRequestFactory</code>.
There is built-in support for the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Apache HttpComponents</p>
</li>
<li>
<p>Netty</p>
</li>
<li>
<p>OkHttp</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example, to switch to Apache HttpComponents, you can use the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">RestTemplate template = new RestTemplate(new HttpComponentsClientHttpRequestFactory());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each <code>ClientHttpRequestFactory</code> exposes configuration options specific to the underlying
HTTP client library&#8201;&#8212;&#8201;for example, for credentials, connection pooling, and other details.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Note that the <code>java.net</code> implementation for HTTP requests can raise an exception when
accessing the status of a response that represents an error (such as 401). If this is an
issue, switch to another HTTP client library.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="rest-resttemplate-uri"><a class="anchor" href="#rest-resttemplate-uri"></a>URIs</h5>
<div class="paragraph">
<p>Many of the <code>RestTemplate</code> methods accept a URI template and URI template variables,
either as a <code>String</code> variable argument, or as <code>Map&lt;String,String&gt;</code>.</p>
</div>
<div class="paragraph">
<p>The following example uses a <code>String</code> variable argument:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">String result = restTemplate.getForObject(
        "https://example.com/hotels/{hotel}/bookings/{booking}", String.class, "42", "21");</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example uses a <code>Map&lt;String, String&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Map&lt;String, String&gt; vars = Collections.singletonMap("hotel", "42");

String result = restTemplate.getForObject(
        "https://example.com/hotels/{hotel}/rooms/{hotel}", String.class, vars);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Keep in mind URI templates are automatically encoded, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">restTemplate.getForObject("https://example.com/hotel list", String.class);

// Results in request to "https://example.com/hotel%20list"</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use the <code>uriTemplateHandler</code> property of <code>RestTemplate</code> to customize how URIs
are encoded. Alternatively, you can prepare a <code>java.net.URI</code> and pass it into one of
the <code>RestTemplate</code> methods that accepts a <code>URI</code>.</p>
</div>
<div class="paragraph">
<p>For more details on working with and encoding URIs, see <a href="web.html#mvc-uri-building">URI Links</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="rest-template-headers"><a class="anchor" href="#rest-template-headers"></a>Headers</h5>
<div class="paragraph">
<p>You can use the <code>exchange()</code> methods to specify request headers, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">String uriTemplate = "https://example.com/hotels/{hotel}";
URI uri = UriComponentsBuilder.fromUriString(uriTemplate).build(42);

RequestEntity&lt;Void&gt; requestEntity = RequestEntity.get(uri)
        .header("MyRequestHeader", "MyValue")
        .build();

ResponseEntity&lt;String&gt; response = template.exchange(requestEntity, String.class);

String responseHeader = response.getHeaders().getFirst("MyResponseHeader");
String body = response.getBody();</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can obtain response headers through many <code>RestTemplate</code> method variants that return
<code>ResponseEntity</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="rest-template-body"><a class="anchor" href="#rest-template-body"></a>1.1.2. Body</h4>
<div class="paragraph">
<p>Objects passed into and returned from <code>RestTemplate</code> methods are converted to and from raw
content with the help of an <code>HttpMessageConverter</code>.</p>
</div>
<div class="paragraph">
<p>On a POST, an input object is serialized to the request body, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>URI location = template.postForLocation("https://example.com/people", person);</pre>
</div>
</div>
<div class="paragraph">
<p>You need not explicitly set the Content-Type header of the request. In most cases,
you can find a compatible message converter based on the source <code>Object</code> type, and the chosen
message converter sets the content type accordingly. If necessary, you can use the
<code>exchange</code> methods to explicitly provide the <code>Content-Type</code> request header, and that, in
turn, influences what message converter is selected.</p>
</div>
<div class="paragraph">
<p>On a GET, the body of the response is deserialized to an output <code>Object</code>, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Person person = restTemplate.getForObject("https://example.com/people/{id}", Person.class, 42);</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Accept</code> header of the request does not need to be explicitly set. In most cases,
a compatible message converter can be found based on the expected response type, which
then helps to populate the <code>Accept</code> header. If necessary, you can use the <code>exchange</code>
methods to provide the <code>Accept</code> header explicitly.</p>
</div>
<div class="paragraph">
<p>By default, <code>RestTemplate</code> registers all built-in
<a href="#rest-message-conversion">message converters</a>, depending on classpath checks that help
to determine what optional conversion libraries are present. You can also set the message
converters to use explicitly.</p>
</div>
</div>
<div class="sect3">
<h4 id="rest-message-conversion"><a class="anchor" href="#rest-message-conversion"></a>1.1.3. Message Conversion</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-codecs">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>The <code>spring-web</code> module contains the <code>HttpMessageConverter</code> contract for reading and
writing the body of HTTP requests and responses through <code>InputStream</code> and <code>OutputStream</code>.
<code>HttpMessageConverter</code> instances are used on the client side (for example, in the <code>RestTemplate</code>) and
on the server side (for example, in Spring MVC REST controllers).</p>
</div>
<div class="paragraph">
<p>Concrete implementations for the main media (MIME) types are provided in the framework
and are, by default, registered with the <code>RestTemplate</code> on the client side and with
<code>RequestMethodHandlerAdapter</code> on the server side (see
<a href="web.html#mvc-config-message-converters">Configuring Message Converters</a>).</p>
</div>
<div class="paragraph">
<p>The implementations of <code>HttpMessageConverter</code> are described in the following sections.
For all converters, a default media type is used, but you can override it by setting the
<code>supportedMediaTypes</code> bean property. The following table describes each implementation:</p>
</div>
<table id="rest-message-converters-tbl" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. HttpMessageConverter Implementations</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">MessageConverter</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StringHttpMessageConverter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An <code>HttpMessageConverter</code> implementation that can read and write <code>String</code> instances from the HTTP
request and response. By default, this converter supports all text media types
(<code>text/*</code>) and writes with a <code>Content-Type</code> of <code>text/plain</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FormHttpMessageConverter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An <code>HttpMessageConverter</code> implementation that can read and write form data from the HTTP
request and response. By default, this converter reads and writes the
<code>application/x-www-form-urlencoded</code> media type. Form data is read from and written into a
<code>MultiValueMap&lt;String, String&gt;</code>. The converter can also write (but not read) multipart
data read from a <code>MultiValueMap&lt;String, Object&gt;</code>. By default, <code>multipart/form-data</code> is
supported. As of Spring Framework 5.2, additional multipart subtypes can be supported for
writing form data. Consult the javadoc for <code>FormHttpMessageConverter</code> for further details.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ByteArrayHttpMessageConverter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An <code>HttpMessageConverter</code> implementation that can read and write byte arrays from the
HTTP request and response. By default, this converter supports all media types (<code>*/*</code>)
and writes with a <code>Content-Type</code> of <code>application/octet-stream</code>. You can override this
by setting the <code>supportedMediaTypes</code> property and overriding <code>getContentType(byte[])</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MarshallingHttpMessageConverter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An <code>HttpMessageConverter</code> implementation that can read and write XML by using Spring&#8217;s
<code>Marshaller</code> and <code>Unmarshaller</code> abstractions from the <code>org.springframework.oxm</code> package.
This converter requires a <code>Marshaller</code> and <code>Unmarshaller</code> before it can be used. You can inject these
through constructor or bean properties. By default, this converter supports
<code>text/xml</code> and <code>application/xml</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MappingJackson2HttpMessageConverter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An <code>HttpMessageConverter</code> implementation that can read and write JSON by using Jackson&#8217;s
<code>ObjectMapper</code>. You can customize JSON mapping as needed through the use of Jackson&#8217;s
provided annotations. When you need further control (for cases where custom JSON
serializers/deserializers need to be provided for specific types), you can inject a custom <code>ObjectMapper</code>
through the <code>ObjectMapper</code> property. By default, this
converter supports <code>application/json</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MappingJackson2XmlHttpMessageConverter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An <code>HttpMessageConverter</code> implementation that can read and write XML by using
<a href="https://github.com/FasterXML/jackson-dataformat-xml">Jackson XML</a> extension&#8217;s
<code>XmlMapper</code>. You can customize XML mapping as needed through the use of JAXB
or Jackson&#8217;s provided annotations. When you need further control (for cases where custom XML
serializers/deserializers need to be provided for specific types), you can inject a custom <code>XmlMapper</code>
through the <code>ObjectMapper</code> property. By default, this
converter supports <code>application/xml</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SourceHttpMessageConverter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An <code>HttpMessageConverter</code> implementation that can read and write
<code>javax.xml.transform.Source</code> from the HTTP request and response. Only <code>DOMSource</code>,
<code>SAXSource</code>, and <code>StreamSource</code> are supported. By default, this converter supports
<code>text/xml</code> and <code>application/xml</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BufferedImageHttpMessageConverter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An <code>HttpMessageConverter</code> implementation that can read and write
<code>java.awt.image.BufferedImage</code> from the HTTP request and response. This converter reads
and writes the media type supported by the Java I/O API.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="rest-template-jsonview"><a class="anchor" href="#rest-template-jsonview"></a>1.1.4. Jackson JSON Views</h4>
<div class="paragraph">
<p>You can specify a <a href="https://www.baeldung.com/jackson-json-view-annotation">Jackson JSON View</a>
to serialize only a subset of the object properties, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">MappingJacksonValue value = new MappingJacksonValue(new User("eric", "7!jd#h23"));
value.setSerializationView(User.WithoutPasswordView.class);

RequestEntity&lt;MappingJacksonValue&gt; requestEntity =
    RequestEntity.post(new URI("https://example.com/user")).body(value);

ResponseEntity&lt;String&gt; response = template.exchange(requestEntity, String.class);</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="rest-template-multipart"><a class="anchor" href="#rest-template-multipart"></a>Multipart</h5>
<div class="paragraph">
<p>To send multipart data, you need to provide a <code>MultiValueMap&lt;String, Object&gt;</code> whose values
may be an <code>Object</code> for part content, a <code>Resource</code> for a file part, or an <code>HttpEntity</code> for
part content with headers. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">MultiValueMap&lt;String, Object&gt; parts = new LinkedMultiValueMap&lt;&gt;();

parts.add("fieldPart", "fieldValue");
parts.add("filePart", new FileSystemResource("...logo.png"));
parts.add("jsonPart", new Person("Jason"));

HttpHeaders headers = new HttpHeaders();
headers.setContentType(MediaType.APPLICATION_XML);
parts.add("xmlPart", new HttpEntity&lt;&gt;(myBean, headers));</code></pre>
</div>
</div>
<div class="paragraph">
<p>In most cases, you do not have to specify the <code>Content-Type</code> for each part. The content
type is determined automatically based on the <code>HttpMessageConverter</code> chosen to serialize
it or, in the case of a <code>Resource</code> based on the file extension. If necessary, you can
explicitly provide the <code>MediaType</code> with an <code>HttpEntity</code> wrapper.</p>
</div>
<div class="paragraph">
<p>Once the <code>MultiValueMap</code> is ready, you can pass it to the <code>RestTemplate</code>, as show below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">MultiValueMap&lt;String, Object&gt; parts = ...;
template.postForObject("https://example.com/upload", parts, Void.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the <code>MultiValueMap</code> contains at least one non-<code>String</code> value, the <code>Content-Type</code> is set
to <code>multipart/form-data</code> by the <code>FormHttpMessageConverter</code>. If the <code>MultiValueMap</code> has
<code>String</code> values the <code>Content-Type</code> is defaulted to <code>application/x-www-form-urlencoded</code>.
If necessary the <code>Content-Type</code> may also be set explicitly.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="rest-async-resttemplate"><a class="anchor" href="#rest-async-resttemplate"></a>1.2. Using <code>AsyncRestTemplate</code> (Deprecated)</h3>
<div class="paragraph">
<p>The <code>AsyncRestTemplate</code> is deprecated. For all use cases where you might consider using
<code>AsyncRestTemplate</code>, use the <a href="web-reactive.html#webflux-client">WebClient</a> instead.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="remoting"><a class="anchor" href="#remoting"></a>2. Remoting and Web Services</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring provides support for remoting with various technologies.
The remoting support eases the development of remote-enabled services, implemented
via Java interfaces and objects as input and output. Currently, Spring supports the
following remoting technologies:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#remoting-web-services">Java Web Services</a>: Spring provides remoting support for web services through JAX-WS.</p>
</li>
<li>
<p><a href="#remoting-amqp">AMQP</a>: Remoting via AMQP as the underlying protocol is supported by the
separate Spring AMQP project.</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
As of Spring Framework 5.3, support for several remoting technologies is now deprecated
for security reasons and broader industry support. Supporting infrastructure will be removed
from Spring Framework for its next major release.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following remoting technologies are now deprecated and will not be replaced:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#remoting-rmi">Remote Method Invocation (RMI)</a>: Through the use of  <code>RmiProxyFactoryBean</code> and
<code>RmiServiceExporter</code>, Spring supports both traditional RMI (with <code>java.rmi.Remote</code>
interfaces and <code>java.rmi.RemoteException</code>) and transparent remoting through RMI
invokers (with any Java interface).</p>
</li>
<li>
<p><a href="#remoting-httpinvoker">Spring HTTP Invoker (Deprecated)</a>: Spring provides a special remoting strategy that allows
for Java serialization though HTTP, supporting any Java interface (as the RMI
invoker does). The corresponding support classes are <code>HttpInvokerProxyFactoryBean</code>
and <code>HttpInvokerServiceExporter</code>.</p>
</li>
<li>
<p><a href="#remoting-caucho-protocols-hessian">Hessian</a>: By using Spring&#8217;s <code>HessianProxyFactoryBean</code> and the
<code>HessianServiceExporter</code>, you can transparently expose your services through the
lightweight binary HTTP-based protocol provided by Caucho.</p>
</li>
<li>
<p><a href="#remoting-jms">JMS (Deprecated)</a>: Remoting via JMS as the underlying protocol is supported through the
<code>JmsInvokerServiceExporter</code> and <code>JmsInvokerProxyFactoryBean</code> classes in the
 <code>spring-jms</code> module.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>While discussing the remoting capabilities of Spring, we use the following domain
model and corresponding services:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class Account implements Serializable{

    private String name;

    public String getName(){
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface AccountService {

    public void insertAccount(Account account);

    public List&lt;Account&gt; getAccounts(String name);
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// the implementation doing nothing at the moment
public class AccountServiceImpl implements AccountService {

    public void insertAccount(Account acc) {
        // do something...
    }

    public List&lt;Account&gt; getAccounts(String name) {
        // do something...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This section starts by exposing the service to a remote client by using RMI and talk a bit
about the drawbacks of using RMI. It then continues with an example that uses Hessian as
the protocol.</p>
</div>
<div class="sect2">
<h3 id="remoting-amqp"><a class="anchor" href="#remoting-amqp"></a>2.1. AMQP</h3>
<div class="paragraph">
<p>Remoting via AMQP as the underlying protocol is supported in the Spring AMQP project.
For further details please visit the <a href="https://docs.spring.io/spring-amqp/docs/current/reference/html/#remoting">Spring Remoting</a>
section of the Spring AMQP reference.</p>
</div>
<div id="remoting-autodection-remote-interfaces" class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Auto-detection is not implemented for remote interfaces</p>
</div>
<div class="paragraph">
<p>The main reason why auto-detection of implemented interfaces does not occur for remote
interfaces is to avoid opening too many doors to remote callers. The target object might
implement internal callback interfaces, such as <code>InitializingBean</code> or <code>DisposableBean</code>
which one would not want to expose to callers.</p>
</div>
<div class="paragraph">
<p>Offering a proxy with all interfaces implemented by the target usually does not matter
in the local case. However, when you export a remote service, you should expose a specific
service interface, with specific operations intended for remote usage. Besides internal
callback interfaces, the target might implement multiple business interfaces, with only
one of them intended for remote exposure. For these reasons, we require such a
service interface to be specified.</p>
</div>
<div class="paragraph">
<p>This is a trade-off between configuration convenience and the risk of accidental
exposure of internal methods. Always specifying a service interface is not too much
effort and puts you on the safe side regarding controlled exposure of specific methods.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="remoting-considerations"><a class="anchor" href="#remoting-considerations"></a>2.2. Considerations when Choosing a Technology</h3>
<div class="paragraph">
<p>Each and every technology presented here has its drawbacks. When choosing a technology,
you should carefully consider your needs, the services you expose, and the objects you
send over the wire.</p>
</div>
<div class="paragraph">
<p>When using RMI, you cannot access the objects through the HTTP protocol,
unless you tunnel the RMI traffic. RMI is a fairly heavy-weight protocol, in that it
supports full-object serialization, which is important when you use a complex data model
that needs serialization over the wire. However, RMI-JRMP is tied to Java clients. It is
a Java-to-Java remoting solution.</p>
</div>
<div class="paragraph">
<p>Spring&#8217;s HTTP invoker is a good choice if you need HTTP-based remoting but also rely on
Java serialization. It shares the basic infrastructure with RMI invokers but uses
HTTP as transport. Note that HTTP invokers are not limited only to Java-to-Java remoting
but also to Spring on both the client and the server side. (The latter also applies to
Spring&#8217;s RMI invoker for non-RMI interfaces.)</p>
</div>
<div class="paragraph">
<p>Hessian might provide significant value when operating in a heterogeneous environment,
because they explicitly allow for non-Java clients. However, non-Java support is still
limited. Known issues include the serialization of Hibernate objects in combination with
lazily-initialized collections. If you have such a data model, consider using RMI or
HTTP invokers instead of Hessian.</p>
</div>
<div class="paragraph">
<p>JMS can be useful for providing clusters of services and letting the JMS broker take
care of load balancing, discovery, and auto-failover. By default, Java serialization is
used for JMS remoting, but the JMS provider could use a different mechanism for
the wire formatting, such as XStream to let servers be implemented in other
technologies.</p>
</div>
<div class="paragraph">
<p>Last but not least, EJB has an advantage over RMI, in that it supports standard
role-based authentication and authorization and remote transaction propagation. It is
possible to get RMI invokers or HTTP invokers to support security context propagation as
well, although this is not provided by core Spring. Spring offers only appropriate hooks
for plugging in third-party or custom solutions.</p>
</div>
</div>
<div class="sect2">
<h3 id="remoting-web-services"><a class="anchor" href="#remoting-web-services"></a>2.3. Java Web Services</h3>
<div class="paragraph">
<p>Spring provides full support for the standard Java web services APIs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Exposing web services using JAX-WS</p>
</li>
<li>
<p>Accessing web services using JAX-WS</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In addition to stock support for JAX-WS in Spring Core, the Spring portfolio also
features <a href="http://www.springframework.org/spring-ws">Spring Web Services</a>, which is a solution for
contract-first, document-driven web services&#8201;&#8212;&#8201;highly recommended for building modern,
future-proof web services.</p>
</div>
<div class="sect3">
<h4 id="remoting-web-services-jaxws-export-servlet"><a class="anchor" href="#remoting-web-services-jaxws-export-servlet"></a>2.3.1. Exposing Servlet-based Web Services by Using JAX-WS</h4>
<div class="paragraph">
<p>Spring provides a convenient base class for JAX-WS servlet endpoint implementations:
<code>SpringBeanAutowiringSupport</code>. To expose our <code>AccountService</code>, we extend Spring&#8217;s
<code>SpringBeanAutowiringSupport</code> class and implement our business logic here, usually
delegating the call to the business layer. We use Spring&#8217;s <code>@Autowired</code>
annotation to express such dependencies on Spring-managed beans. The following example
shows our class that extends <code>SpringBeanAutowiringSupport</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">/**
 * JAX-WS compliant AccountService implementation that simply delegates
 * to the AccountService implementation in the root web application context.
 *
 * This wrapper class is necessary because JAX-WS requires working with dedicated
 * endpoint classes. If an existing service needs to be exported, a wrapper that
 * extends SpringBeanAutowiringSupport for simple Spring bean autowiring (through
 * the @Autowired annotation) is the simplest JAX-WS compliant way.
 *
 * This is the class registered with the server-side JAX-WS implementation.
 * In the case of a Java EE server, this would simply be defined as a servlet
 * in web.xml, with the server detecting that this is a JAX-WS endpoint and reacting
 * accordingly. The servlet name usually needs to match the specified WS service name.
 *
 * The web service engine manages the lifecycle of instances of this class.
 * Spring bean references will just be wired in here.
 */
import org.springframework.web.context.support.SpringBeanAutowiringSupport;

@WebService(serviceName="AccountService")
public class AccountServiceEndpoint extends SpringBeanAutowiringSupport {

    @Autowired
    private AccountService biz;

    @WebMethod
    public void insertAccount(Account acc) {
        biz.insertAccount(acc);
    }

    @WebMethod
    public Account[] getAccounts(String name) {
        return biz.getAccounts(name);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Our <code>AccountServiceEndpoint</code> needs to run in the same web application as the Spring
context to allow for access to Spring&#8217;s facilities. This is the case by default in Java
EE environments, using the standard contract for JAX-WS servlet endpoint deployment.
See the various Java EE web service tutorials for details.</p>
</div>
</div>
<div class="sect3">
<h4 id="remoting-web-services-jaxws-export-standalone"><a class="anchor" href="#remoting-web-services-jaxws-export-standalone"></a>2.3.2. Exporting Standalone Web Services by Using JAX-WS</h4>
<div class="paragraph">
<p>The built-in JAX-WS provider that comes with Oracle&#8217;s JDK supports exposure of web
services by using the built-in HTTP server that is also included in the JDK. Spring&#8217;s
<code>SimpleJaxWsServiceExporter</code> detects all <code>@WebService</code>-annotated beans in the Spring
application context and exports them through the default JAX-WS server (the JDK HTTP
server).</p>
</div>
<div class="paragraph">
<p>In this scenario, the endpoint instances are defined and managed as Spring beans
themselves. They are registered with the JAX-WS engine, but their lifecycle is up to
the Spring application context. This means that you can apply Spring functionality
(such as explicit dependency injection) to the endpoint instances. Annotation-driven
injection through <code>@Autowired</code> works as well. The following example shows how to
define these beans:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean class="org.springframework.remoting.jaxws.SimpleJaxWsServiceExporter"&gt;
    &lt;property name="baseAddress" value="http://localhost:8080/"/&gt;
&lt;/bean&gt;

&lt;bean id="accountServiceEndpoint" class="example.AccountServiceEndpoint"&gt;
    ...
&lt;/bean&gt;

...</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>AccountServiceEndpoint</code> can but does not have to derive from Spring&#8217;s <code>SpringBeanAutowiringSupport</code>,
since the endpoint in this example is a fully Spring-managed bean. This means that
the endpoint implementation can be as follows (without any superclass declared&#8201;&#8212;&#8201;and Spring&#8217;s <code>@Autowired</code> configuration annotation is still honored):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@WebService(serviceName="AccountService")
public class AccountServiceEndpoint {

    @Autowired
    private AccountService biz;

    @WebMethod
    public void insertAccount(Account acc) {
        biz.insertAccount(acc);
    }

    @WebMethod
    public List&lt;Account&gt; getAccounts(String name) {
        return biz.getAccounts(name);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="remoting-web-services-jaxws-export-ri"><a class="anchor" href="#remoting-web-services-jaxws-export-ri"></a>2.3.3. Exporting Web Services by Using JAX-WS RI&#8217;s Spring Support</h4>
<div class="paragraph">
<p>Oracle&#8217;s JAX-WS RI, developed as part of the GlassFish project, ships Spring support
as part of its JAX-WS Commons project. This allows for defining JAX-WS endpoints as
Spring-managed beans, similar to the standalone mode discussed in the
<a href="#remoting-web-services-jaxws-export-standalone">previous section</a>&#8201;&#8212;&#8201;but this time in a Servlet environment.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This is not portable in a Java EE environment. It is mainly intended for non-EE
environments, such as Tomcat, that embed the JAX-WS RI as part of the web application.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The differences from the standard style of exporting servlet-based endpoints are that
the lifecycle of the endpoint instances themselves are managed by Spring and that there
is only one JAX-WS servlet defined in <code>web.xml</code>. With the standard Java EE style (as
shown earlier), you have one servlet definition per service endpoint, with each endpoint
typically delegating to Spring beans (through the use of <code>@Autowired</code>, as shown earlier).</p>
</div>
<div class="paragraph">
<p>See <a href="https://jax-ws-commons.java.net/spring/">https://jax-ws-commons.java.net/spring/</a>
for details on setup and usage style.</p>
</div>
</div>
<div class="sect3">
<h4 id="remoting-web-services-jaxws-access"><a class="anchor" href="#remoting-web-services-jaxws-access"></a>2.3.4. Accessing Web Services by Using JAX-WS</h4>
<div class="paragraph">
<p>Spring provides two factory beans to create JAX-WS web service proxies, namely
<code>LocalJaxWsServiceFactoryBean</code> and <code>JaxWsPortProxyFactoryBean</code>. The former can
return only a JAX-WS service class for us to work with. The latter is the full-fledged
version that can return a proxy that implements our business service interface.
In the following example, we use <code>JaxWsPortProxyFactoryBean</code> to create a proxy for the
<code>AccountService</code> endpoint (again):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="accountWebService" class="org.springframework.remoting.jaxws.JaxWsPortProxyFactoryBean"&gt;
    &lt;property name="serviceInterface" value="example.AccountService"/&gt; <i class="conum" data-value="1"></i><b>(1)</b>
    &lt;property name="wsdlDocumentUrl" value="http://localhost:8888/AccountServiceEndpoint?WSDL"/&gt;
    &lt;property name="namespaceUri" value="https://example/"/&gt;
    &lt;property name="serviceName" value="AccountService"/&gt;
    &lt;property name="portName" value="AccountServiceEndpointPort"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Where <code>serviceInterface</code> is our business interface that the clients use.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>wsdlDocumentUrl</code> is the URL for the WSDL file. Spring needs this at startup time to
create the JAX-WS Service. <code>namespaceUri</code> corresponds to the <code>targetNamespace</code> in the
.wsdl file. <code>serviceName</code> corresponds to the service name in the .wsdl file. <code>portName</code>
corresponds to the port name in the .wsdl file.</p>
</div>
<div class="paragraph">
<p>Accessing the web service is easy, as we have a bean factory for it that exposes it as
an interface called <code>AccountService</code>. The following example shows how we can wire this
up in Spring:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="client" class="example.AccountClientImpl"&gt;
    ...
    &lt;property name="service" ref="accountWebService"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>From the client code, we can access the web service as if it were a normal class,
as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class AccountClientImpl {

    private AccountService service;

    public void setService(AccountService service) {
        this.service = service;
    }

    public void foo() {
        service.insertAccount(...);
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The above is slightly simplified in that JAX-WS requires endpoint interfaces
and implementation classes to be annotated with <code>@WebService</code>, <code>@SOAPBinding</code> etc
annotations. This means that you cannot (easily) use plain Java interfaces and
implementation classes as JAX-WS endpoint artifacts; you need to annotate them
accordingly first. Check the JAX-WS documentation for details on those requirements.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="remoting-rmi"><a class="anchor" href="#remoting-rmi"></a>2.4. RMI (Deprecated)</h3>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
As of Spring Framework 5.3, RMI support is deprecated and will not be replaced.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>By using Spring&#8217;s support for RMI, you can transparently expose your services through the
RMI infrastructure. After having this set up, you basically have a configuration similar
to remote EJBs, except for the fact that there is no standard support for security
context propagation or remote transaction propagation. Spring does provide hooks for
such additional invocation context when you use the RMI invoker, so you can, for example,
plug in security frameworks or custom security credentials.</p>
</div>
<div class="sect3">
<h4 id="remoting-rmi-server"><a class="anchor" href="#remoting-rmi-server"></a>2.4.1. Exporting the Service by Using <code>RmiServiceExporter</code></h4>
<div class="paragraph">
<p>Using the <code>RmiServiceExporter</code>, we can expose the interface of our AccountService object
as RMI object. The interface can be accessed by using <code>RmiProxyFactoryBean</code>, or via
plain RMI in case of a traditional RMI service. The <code>RmiServiceExporter</code> explicitly
supports the exposing of any non-RMI services via RMI invokers.</p>
</div>
<div class="paragraph">
<p>We first have to set up our service in the Spring container.
The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="accountService" class="example.AccountServiceImpl"&gt;
    &lt;!-- any additional properties, maybe a DAO? --&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, we have to expose our service by using <code>RmiServiceExporter</code>.
The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean class="org.springframework.remoting.rmi.RmiServiceExporter"&gt;
    &lt;!-- does not necessarily have to be the same name as the bean to be exported --&gt;
    &lt;property name="serviceName" value="AccountService"/&gt;
    &lt;property name="service" ref="accountService"/&gt;
    &lt;property name="serviceInterface" value="example.AccountService"/&gt;
    &lt;!-- defaults to 1099 --&gt;
    &lt;property name="registryPort" value="1199"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, we override the port for the RMI registry. Often, your application
server also maintains an RMI registry, and it is wise to not interfere with that one.
Furthermore, the service name is used to bind the service. So, in the preceding example, the
service is bound at <code>'rmi://HOST:1199/AccountService'</code>. We use this URL later on to link in
the service at the client side.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>servicePort</code> property has been omitted (it defaults to 0). This means that an
anonymous port is used to communicate with the service.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="remoting-rmi-client"><a class="anchor" href="#remoting-rmi-client"></a>2.4.2. Linking in the Service at the Client</h4>
<div class="paragraph">
<p>Our client is a simple object that uses the <code>AccountService</code> to manage accounts,
as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class SimpleObject {

    private AccountService accountService;

    public void setAccountService(AccountService accountService) {
        this.accountService = accountService;
    }

    // additional methods using the accountService
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To link in the service on the client, we create a separate Spring container,
to contain the following simple object and the service linking configuration bits:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean class="example.SimpleObject"&gt;
    &lt;property name="accountService" ref="accountService"/&gt;
&lt;/bean&gt;

&lt;bean id="accountService" class="org.springframework.remoting.rmi.RmiProxyFactoryBean"&gt;
    &lt;property name="serviceUrl" value="rmi://HOST:1199/AccountService"/&gt;
    &lt;property name="serviceInterface" value="example.AccountService"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>That is all we need to do to support the remote account service on the client. Spring
transparently creates an invoker and remotely enables the account service through the
<code>RmiServiceExporter</code>. At the client, we link it in by using the <code>RmiProxyFactoryBean</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="remoting-caucho-protocols"><a class="anchor" href="#remoting-caucho-protocols"></a>2.5. Using Hessian to Remotely Call Services through HTTP (Deprecated)</h3>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
As of Spring Framework 5.3, Hessian support is deprecated and will not be replaced.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Hessian offers a binary HTTP-based remoting protocol. It is developed by Caucho,
and you can find more information about Hessian itself at <a href="https://www.caucho.com/" class="bare">https://www.caucho.com/</a>.</p>
</div>
<div class="sect3">
<h4 id="remoting-caucho-protocols-hessian"><a class="anchor" href="#remoting-caucho-protocols-hessian"></a>2.5.1. Hessian</h4>
<div class="paragraph">
<p>Hessian communicates through HTTP and does so by using a custom servlet. By using Spring&#8217;s
<code>DispatcherServlet</code> principles (see <a href="webmvc.html#mvc-servlet">webmvc.html</a>), we can wire up such a
servlet to expose your services. First, we have to create a new servlet in our application,
as shown in the following excerpt from <code>web.xml</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;servlet&gt;
    &lt;servlet-name&gt;remoting&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;remoting&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/remoting/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you are familiar with Spring&#8217;s <code>DispatcherServlet</code> principles, you probably
know that now you have to create a Spring container configuration resource named
<code>remoting-servlet.xml</code> (after the name of your servlet) in the <code>WEB-INF</code> directory.
The application context is used in the next section.</p>
</div>
<div class="paragraph">
<p>Alternatively, consider the use of Spring&#8217;s simpler <code>HttpRequestHandlerServlet</code>. Doing so
lets you embed the remote exporter definitions in your root application context (by
default, in <code>WEB-INF/applicationContext.xml</code>), with individual servlet definitions
pointing to specific exporter beans. In this case, each servlet name needs to match the bean name of
its target exporter.</p>
</div>
</div>
<div class="sect3">
<h4 id="remoting-caucho-protocols-hessian-server"><a class="anchor" href="#remoting-caucho-protocols-hessian-server"></a>2.5.2. Exposing Your Beans by Using <code>HessianServiceExporter</code></h4>
<div class="paragraph">
<p>In the newly created application context called <code>remoting-servlet.xml</code>, we create a
<code>HessianServiceExporter</code> to export our services, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="accountService" class="example.AccountServiceImpl"&gt;
    &lt;!-- any additional properties, maybe a DAO? --&gt;
&lt;/bean&gt;

&lt;bean name="/AccountService" class="org.springframework.remoting.caucho.HessianServiceExporter"&gt;
    &lt;property name="service" ref="accountService"/&gt;
    &lt;property name="serviceInterface" value="example.AccountService"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we are ready to link in the service at the client. No explicit handler mapping is
specified (to map request URLs onto services), so we use <code>BeanNameUrlHandlerMapping</code>
used. Hence, the service is exported at the URL indicated through its bean name
within the containing <code>DispatcherServlet</code> instance&#8217;s mapping (as defined earlier):
<code><a href="https://HOST:8080/remoting/AccountService" class="bare">https://HOST:8080/remoting/AccountService</a></code>.</p>
</div>
<div class="paragraph">
<p>Alternatively, you can create a <code>HessianServiceExporter</code> in your root application context (for example,
in <code>WEB-INF/applicationContext.xml</code>), as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean name="accountExporter" class="org.springframework.remoting.caucho.HessianServiceExporter"&gt;
    &lt;property name="service" ref="accountService"/&gt;
    &lt;property name="serviceInterface" value="example.AccountService"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the latter case, you should define a corresponding servlet for this exporter in <code>web.xml</code>,
with the same end result: The exporter gets mapped to the request path at
<code>/remoting/AccountService</code>. Note that the servlet name needs to match the bean name of
the target exporter. The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;servlet&gt;
    &lt;servlet-name&gt;accountExporter&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.context.support.HttpRequestHandlerServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;accountExporter&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/remoting/AccountService&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="remoting-caucho-protocols-hessian-client"><a class="anchor" href="#remoting-caucho-protocols-hessian-client"></a>2.5.3. Linking in the Service on the Client</h4>
<div class="paragraph">
<p>By using the <code>HessianProxyFactoryBean</code>, we can link in the service at the client. The same
principles apply as with the RMI example. We create a separate bean factory or
application context and mention the following beans where the <code>SimpleObject</code> is by using
the <code>AccountService</code> to manage accounts, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean class="example.SimpleObject"&gt;
    &lt;property name="accountService" ref="accountService"/&gt;
&lt;/bean&gt;

&lt;bean id="accountService" class="org.springframework.remoting.caucho.HessianProxyFactoryBean"&gt;
    &lt;property name="serviceUrl" value="https://remotehost:8080/remoting/AccountService"/&gt;
    &lt;property name="serviceInterface" value="example.AccountService"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="remoting-caucho-protocols-security"><a class="anchor" href="#remoting-caucho-protocols-security"></a>2.5.4. Applying HTTP Basic Authentication to a Service Exposed through Hessian</h4>
<div class="paragraph">
<p>One of the advantages of Hessian is that we can easily apply HTTP basic authentication,
because both protocols are HTTP-based. Your normal HTTP server security mechanism can
be applied through using the <code>web.xml</code> security features, for example. Usually,
you need not use per-user security credentials here. Rather, you can use shared credentials that you define
at the <code>HessianProxyFactoryBean</code> level (similar to a JDBC <code>DataSource</code>), as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"&gt;
    &lt;property name="interceptors" ref="authorizationInterceptor"/&gt;
&lt;/bean&gt;

&lt;bean id="authorizationInterceptor"
        class="org.springframework.web.servlet.handler.UserRoleAuthorizationInterceptor"&gt;
    &lt;property name="authorizedRoles" value="administrator,operator"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, we explicitly mention the <code>BeanNameUrlHandlerMapping</code> and set
an interceptor, to let only administrators and operators call the beans mentioned in
this application context.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The preceding example does not show a flexible kind of security infrastructure. For
more options as far as security is concerned, have a look at the Spring Security project
at <a href="https://projects.spring.io/spring-security/" class="bare">https://projects.spring.io/spring-security/</a>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="remoting-httpinvoker"><a class="anchor" href="#remoting-httpinvoker"></a>2.6. Spring HTTP Invoker (Deprecated)</h3>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
As of Spring Framework 5.3, HTTP Invoker support is deprecated and will not be replaced.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As opposed to Hessian, Spring HTTP invokers are both lightweight protocols that use their own slim
serialization mechanisms and use the standard Java serialization
mechanism to expose services through HTTP. This has a huge advantage if your arguments
and return types are complex types that cannot be serialized by using the serialization
mechanisms Hessian uses (see the next section for more considerations when
you choose a remoting technology).</p>
</div>
<div class="paragraph">
<p>Under the hood, Spring uses either the standard facilities provided by the JDK or
Apache <code>HttpComponents</code> to perform HTTP calls. If you need more
advanced and easier-to-use functionality, use the latter. See
<a href="https://hc.apache.org/httpcomponents-client-ga/">hc.apache.org/httpcomponents-client-ga/</a>
for more information.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Be aware of vulnerabilities due to unsafe Java deserialization:
Manipulated input streams can lead to unwanted code execution on the server
during the deserialization step. As a consequence, do not expose HTTP invoker
endpoints to untrusted clients. Rather, expose them only between your own services.
In general, we strongly recommend using any other message format (such as JSON) instead.</p>
</div>
<div class="paragraph">
<p>If you are concerned about security vulnerabilities due to Java serialization,
consider the general-purpose serialization filter mechanism at the core JVM level,
originally developed for JDK 9 but backported to JDK 8, 7 and 6 in the meantime. See
<a href="https://blogs.oracle.com/java-platform-group/entry/incoming_filter_serialization_data_a" class="bare">https://blogs.oracle.com/java-platform-group/entry/incoming_filter_serialization_data_a</a>
and <a href="https://openjdk.java.net/jeps/290" class="bare">https://openjdk.java.net/jeps/290</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="remoting-httpinvoker-server"><a class="anchor" href="#remoting-httpinvoker-server"></a>2.6.1. Exposing the Service Object</h4>
<div class="paragraph">
<p>Setting up the HTTP invoker infrastructure for a service object closely resembles the
way you would do the same by using Hessian. As Hessian support provides
<code>HessianServiceExporter</code>, Spring&#8217;s HttpInvoker support provides
<code>org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter</code>.</p>
</div>
<div class="paragraph">
<p>To expose the <code>AccountService</code> (mentioned earlier) within a Spring Web MVC
<code>DispatcherServlet</code>, the following configuration needs to be in place in the
dispatcher&#8217;s application context, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean name="/AccountService" class="org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter"&gt;
    &lt;property name="service" ref="accountService"/&gt;
    &lt;property name="serviceInterface" value="example.AccountService"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Such an exporter definition is exposed through the <code>DispatcherServlet</code> instance&#8217;s standard
mapping facilities, as explained in <a href="#remoting-caucho-protocols">the section on Hessian</a>.</p>
</div>
<div class="paragraph">
<p>Alternatively, you can create an <code>HttpInvokerServiceExporter</code> in your root application context
(for example, in <code>'WEB-INF/applicationContext.xml'</code>), as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean name="accountExporter" class="org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter"&gt;
    &lt;property name="service" ref="accountService"/&gt;
    &lt;property name="serviceInterface" value="example.AccountService"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In addition, you can define a corresponding servlet for this exporter in <code>web.xml</code>, with the
servlet name matching the bean name of the target exporter, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;servlet&gt;
    &lt;servlet-name&gt;accountExporter&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.context.support.HttpRequestHandlerServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;accountExporter&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/remoting/AccountService&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="remoting-httpinvoker-client"><a class="anchor" href="#remoting-httpinvoker-client"></a>2.6.2. Linking in the Service at the Client</h4>
<div class="paragraph">
<p>Again, linking in the service from the client much resembles the way you would do it
when you use Hessian. By using a proxy, Spring can translate your calls to
HTTP POST requests to the URL that points to the exported service. The following example
shows how to configure this arrangement:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="httpInvokerProxy" class="org.springframework.remoting.httpinvoker.HttpInvokerProxyFactoryBean"&gt;
    &lt;property name="serviceUrl" value="https://remotehost:8080/remoting/AccountService"/&gt;
    &lt;property name="serviceInterface" value="example.AccountService"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>As mentioned earlier, you can choose what HTTP client you want to use. By default, the
<code>HttpInvokerProxy</code> uses the JDK&#8217;s HTTP functionality, but you can also use the Apache
<code>HttpComponents</code> client by setting the <code>httpInvokerRequestExecutor</code> property.
The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;property name="httpInvokerRequestExecutor"&gt;
    &lt;bean class="org.springframework.remoting.httpinvoker.HttpComponentsHttpInvokerRequestExecutor"/&gt;
&lt;/property&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="remoting-jms"><a class="anchor" href="#remoting-jms"></a>2.7. JMS (Deprecated)</h3>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
As of Spring Framework 5.3, JMS remoting support is deprecated and will not be replaced.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can also expose services transparently by using JMS as the underlying communication
protocol. The JMS remoting support in the Spring Framework is pretty basic. It sends
and receives on the <code>same thread</code> and in the same non-transactional <code>Session</code>.
As a result, throughput is implementation-dependent. Note that these single-threaded
and non-transactional constraints apply only to Spring&#8217;s JMS remoting support.
See <a href="#jms">JMS (Java Message Service)</a> for information on Spring&#8217;s rich support for JMS-based messaging.</p>
</div>
<div class="paragraph">
<p>The following interface is used on both the server and the client sides:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package com.foo;

public interface CheckingAccountService {

    public void cancelAccount(Long accountId);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following simple implementation of the preceding interface is used on the server-side:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package com.foo;

public class SimpleCheckingAccountService implements CheckingAccountService {

    public void cancelAccount(Long accountId) {
        System.out.println("Cancelling account [" + accountId + "]");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following configuration file contains the JMS-infrastructure beans that are shared
on both the client and the server:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;bean id="connectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt;
        &lt;property name="brokerURL" value="tcp://ep-t43:61616"/&gt;
    &lt;/bean&gt;

    &lt;bean id="queue" class="org.apache.activemq.command.ActiveMQQueue"&gt;
        &lt;constructor-arg value="mmm"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="remoting-jms-server"><a class="anchor" href="#remoting-jms-server"></a>2.7.1. Server-side Configuration</h4>
<div class="paragraph">
<p>On the server, you need to expose the service object that uses the
<code>JmsInvokerServiceExporter</code>, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;bean id="checkingAccountService"
            class="org.springframework.jms.remoting.JmsInvokerServiceExporter"&gt;
        &lt;property name="serviceInterface" value="com.foo.CheckingAccountService"/&gt;
        &lt;property name="service"&gt;
            &lt;bean class="com.foo.SimpleCheckingAccountService"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean class="org.springframework.jms.listener.SimpleMessageListenerContainer"&gt;
        &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
        &lt;property name="destination" ref="queue"/&gt;
        &lt;property name="concurrentConsumers" value="3"/&gt;
        &lt;property name="messageListener" ref="checkingAccountService"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package com.foo;

import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Server {

    public static void main(String[] args) throws Exception {
        new ClassPathXmlApplicationContext("com/foo/server.xml", "com/foo/jms.xml");
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="remoting-jms-client"><a class="anchor" href="#remoting-jms-client"></a>2.7.2. Client-side Configuration</h4>
<div class="paragraph">
<p>The client merely needs to create a client-side proxy that implements the agreed-upon
interface (<code>CheckingAccountService</code>).</p>
</div>
<div class="paragraph">
<p>The following example defines beans that you can inject into other client-side objects
(and the proxy takes care of forwarding the call to the server-side object via JMS):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;bean id="checkingAccountService"
            class="org.springframework.jms.remoting.JmsInvokerProxyFactoryBean"&gt;
        &lt;property name="serviceInterface" value="com.foo.CheckingAccountService"/&gt;
        &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
        &lt;property name="queue" ref="queue"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package com.foo;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Client {

    public static void main(String[] args) throws Exception {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("com/foo/client.xml", "com/foo/jms.xml");
        CheckingAccountService service = (CheckingAccountService) ctx.getBean("checkingAccountService");
        service.cancelAccount(new Long(10));
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ejb"><a class="anchor" href="#ejb"></a>3. Enterprise JavaBeans (EJB) Integration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As a lightweight container, Spring is often considered an EJB replacement. We do believe
that for many, if not most, applications and use cases, Spring, as a container, combined
with its rich supporting functionality in the area of transactions, ORM and JDBC access,
is a better choice than implementing equivalent functionality through an EJB container
and EJBs.</p>
</div>
<div class="paragraph">
<p>However, it is important to note that using Spring does not prevent you from using EJBs.
In fact, Spring makes it much easier to access EJBs and implement EJBs and functionality
within them. Additionally, using Spring to access services provided by EJBs allows the
implementation of those services to later transparently be switched between local EJB,
remote EJB, or POJO (plain old Java object) variants, without the client code having to
be changed.</p>
</div>
<div class="paragraph">
<p>In this chapter, we look at how Spring can help you access and implement EJBs. Spring
provides particular value when accessing stateless session beans (SLSBs), so we begin
by discussing this topic.</p>
</div>
<div class="sect2">
<h3 id="ejb-access"><a class="anchor" href="#ejb-access"></a>3.1. Accessing EJBs</h3>
<div class="paragraph">
<p>This section covers how to access EJBs.</p>
</div>
<div class="sect3">
<h4 id="ejb-access-concepts"><a class="anchor" href="#ejb-access-concepts"></a>3.1.1. Concepts</h4>
<div class="paragraph">
<p>To invoke a method on a local or remote stateless session bean, client code must
normally perform a JNDI lookup to obtain the (local or remote) EJB Home object and then use
a <code>create</code> method call on that object to obtain the actual (local or remote) EJB object.
One or more methods are then invoked on the EJB.</p>
</div>
<div class="paragraph">
<p>To avoid repeated low-level code, many EJB applications use the Service Locator and
Business Delegate patterns. These are better than spraying JNDI lookups throughout
client code, but their usual implementations have significant disadvantages:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Typically, code that uses EJBs depends on Service Locator or Business Delegate singletons,
making it hard to test.</p>
</li>
<li>
<p>In the case of the Service Locator pattern used without a Business Delegate,
application code still ends up having to invoke the <code>create()</code> method on an EJB home
and deal with the resulting exceptions. Thus, it remains tied to the EJB API and the
complexity of the EJB programming model.</p>
</li>
<li>
<p>Implementing the Business Delegate pattern typically results in significant code
duplication, where we have to write numerous methods that call the same method
on the EJB.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Spring approach is to allow the creation and use of proxy objects (normally
configured inside a Spring container), which act as codeless business delegates. You need
not write another Service Locator, another JNDI lookup, or duplicate methods in
a hand-coded Business Delegate unless you actually add real value in such code.</p>
</div>
</div>
<div class="sect3">
<h4 id="ejb-access-local"><a class="anchor" href="#ejb-access-local"></a>3.1.2. Accessing Local SLSBs</h4>
<div class="paragraph">
<p>Assume that we have a web controller that needs to use a local EJB. We follow best
practice and use the EJB Business Methods Interface pattern, so that the EJB&#8217;s local
interface extends a non-EJB-specific business methods interface. We call this
business methods interface <code>MyComponent</code>. The following example shows such an interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface MyComponent {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>One of the main reasons to use the Business Methods Interface pattern is to ensure that
synchronization between method signatures in local interface and bean implementation
class is automatic. Another reason is that it later makes it much easier for us to
switch to a POJO (plain old Java object) implementation of the service if it makes sense
to do so. We also need to implement the local home interface and provide an
implementation class that implements <code>SessionBean</code> and the <code>MyComponent</code> business
methods interface. Now, the only Java coding we need to do to hook up our web tier
controller to the EJB implementation is to expose a setter method of type <code>MyComponent</code>
on the controller. This saves the reference as an instance variable in the
controller. The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">private MyComponent myComponent;

public void setMyComponent(MyComponent myComponent) {
    this.myComponent = myComponent;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can subsequently use this instance variable in any business method in the controller.
Now, assuming we obtain our controller object out of a Spring container, we can
(in the same context) configure a <code>LocalStatelessSessionProxyFactoryBean</code> instance,
which is the EJB proxy object. We configure the proxy and set the
<code>myComponent</code> property of the controller with the following configuration entry:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="myComponent"
        class="org.springframework.ejb.access.LocalStatelessSessionProxyFactoryBean"&gt;
    &lt;property name="jndiName" value="ejb/myBean"/&gt;
    &lt;property name="businessInterface" value="com.mycom.MyComponent"/&gt;
&lt;/bean&gt;

&lt;bean id="myController" class="com.mycom.myController"&gt;
    &lt;property name="myComponent" ref="myComponent"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A lot of work happens behind the scenes, courtesy of the Spring AOP framework,
although you are not forced to work with AOP concepts to enjoy the results. The
<code>myComponent</code> bean definition creates a proxy for the EJB, which implements the business
method interface. The EJB local home is cached on startup, so there is only a single JNDI
lookup. Each time the EJB is invoked, the proxy invokes the <code>classname</code> method on the
local EJB and invokes the	corresponding business method on the EJB.</p>
</div>
<div class="paragraph">
<p>The <code>myController</code> bean definition sets the <code>myComponent</code> property of the controller
class to the EJB proxy.</p>
</div>
<div class="paragraph">
<p>Alternatively (and preferably in case of many such proxy definitions), consider using
the <code>&lt;jee:local-slsb&gt;</code> configuration element in Spring&#8217;s &#8220;jee&#8221; namespace.
The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;jee:local-slsb id="myComponent" jndi-name="ejb/myBean"
        business-interface="com.mycom.MyComponent"/&gt;

&lt;bean id="myController" class="com.mycom.myController"&gt;
    &lt;property name="myComponent" ref="myComponent"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This EJB access mechanism delivers huge simplification of application code. The web tier
code (or other EJB client code) has no dependence on the use of EJB. To
replace this EJB reference with a POJO or a mock object or other test stub, we could
change the <code>myComponent</code> bean definition without changing a line of Java code.
Additionally, we have not had to write a single line of JNDI lookup or other EJB plumbing
code as part of our application.</p>
</div>
<div class="paragraph">
<p>Benchmarks and experience in real applications indicate that the performance overhead of
this approach (which involves reflective invocation of the target EJB) is minimal and
is undetectable in typical use. Remember that we do not want to make
fine-grained calls to EJBs anyway, as there is a cost associated with the EJB
infrastructure in the application server.</p>
</div>
<div class="paragraph">
<p>There is one caveat with regards to the JNDI lookup. In a bean container, this class is
normally best used as a singleton (there is no reason to make it a prototype).
However, if that bean container pre-instantiates singletons (as do the various XML
<code>ApplicationContext</code> variants), you can have a problem if the bean container is loaded
before the EJB container loads the target EJB. That is because the JNDI lookup is
performed in the <code>init()</code> method of this class and then cached, but the EJB has not
been bound at the target location yet. The solution is to not pre-instantiate this
factory object but to let it be created on first use. In the XML containers, you can control this
by using the <code>lazy-init</code> attribute.</p>
</div>
<div class="paragraph">
<p>Although not of interest to the majority of Spring users, those doing
programmatic AOP work with EJBs may want to look at <code>LocalSlsbInvokerInterceptor</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="ejb-access-remote"><a class="anchor" href="#ejb-access-remote"></a>3.1.3. Accessing Remote SLSBs</h4>
<div class="paragraph">
<p>Accessing remote EJBs is essentially identical to accessing local EJBs, except that the
<code>SimpleRemoteStatelessSessionProxyFactoryBean</code> or <code>&lt;jee:remote-slsb&gt;</code> configuration
element is used. Of course, with or without Spring, remote invocation semantics apply: A
call to a method on an object in another VM in another computer does sometimes have to
be treated differently in terms of usage scenarios and failure handling.</p>
</div>
<div class="paragraph">
<p>Spring&#8217;s EJB client support adds one more advantage over the non-Spring approach.
Normally, it is problematic for EJB client code to be easily switched back and forth
between calling EJBs locally or remotely. This is because the remote interface methods
must declare that they throw <code>RemoteException</code>, and client code must deal with this,
while the local interface methods need not. Client code written for local EJBs that needs
to be moved to remote EJBs typically has to be modified to add handling for the remote
exceptions, and client code written for remote EJBs that needs to be moved to local
EJBs can either stay the same but do a lot of unnecessary handling of remote
exceptions or be modified to remove that code. With the Spring remote EJB
proxy, you can instead not declare any thrown <code>RemoteException</code> in your Business Method
Interface and implementing EJB code, have a remote interface that is identical (except
that it does throw <code>RemoteException</code>), and rely on the proxy to dynamically treat the two
interfaces as if they were the same. That is, client code does not have to deal with the
checked <code>RemoteException</code> class. Any actual <code>RemoteException</code> that is thrown during the
EJB invocation is re-thrown as the non-checked <code>RemoteAccessException</code> class, which
is a subclass of <code>RuntimeException</code>. You can then switch the target service at will
between a local EJB or remote EJB (or even plain Java object) implementation, without
the client code knowing or caring. Of course, this is optional: Nothing
stops you from declaring <code>RemoteException</code> in your business interface.</p>
</div>
</div>
<div class="sect3">
<h4 id="ejb-access-ejb2-ejb3"><a class="anchor" href="#ejb-access-ejb2-ejb3"></a>3.1.4. Accessing EJB 2.x SLSBs Versus EJB 3 SLSBs</h4>
<div class="paragraph">
<p>Accessing EJB 2.x Session Beans and EJB 3 Session Beans through Spring is largely
transparent. Spring&#8217;s EJB accessors, including the <code>&lt;jee:local-slsb&gt;</code> and
<code>&lt;jee:remote-slsb&gt;</code> facilities, transparently adapt to the actual component at runtime.
They handle a home interface if found (EJB 2.x style) or perform straight component
invocations if no home interface is available (EJB 3 style).</p>
</div>
<div class="paragraph">
<p>Note: For EJB 3 Session Beans, you can effectively use a <code>JndiObjectFactoryBean</code> /
<code>&lt;jee:jndi-lookup&gt;</code> as well, since fully usable component references are exposed for
plain JNDI lookups there. Defining explicit <code>&lt;jee:local-slsb&gt;</code> or <code>&lt;jee:remote-slsb&gt;</code>
lookups provides consistent and more explicit EJB access configuration.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jms"><a class="anchor" href="#jms"></a>4. JMS (Java Message Service)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring provides a JMS integration framework that simplifies the use of the JMS API in much
the same way as Spring&#8217;s integration does for the JDBC API.</p>
</div>
<div class="paragraph">
<p>JMS can be roughly divided into two areas of functionality, namely the production and
consumption of messages. The <code>JmsTemplate</code> class is used for message production and
synchronous message reception. For asynchronous reception similar to Java EE&#8217;s
message-driven bean style, Spring provides a number of message-listener containers that
you can use to create Message-Driven POJOs (MDPs). Spring also provides a declarative way
to create message listeners.</p>
</div>
<div class="paragraph">
<p>The <code>org.springframework.jms.core</code> package provides the core functionality for using
JMS. It contains JMS template classes that simplify the use of the JMS by handling the
creation and release of resources, much like the <code>JdbcTemplate</code> does for JDBC. The
design principle common to Spring template classes is to provide helper methods to
perform common operations and, for more sophisticated usage, delegate the essence of the
processing task to user-implemented callback interfaces. The JMS template follows the
same design. The classes offer various convenience methods for sending messages,
consuming messages synchronously, and exposing the JMS session and message producer to
the user.</p>
</div>
<div class="paragraph">
<p>The <code>org.springframework.jms.support</code> package provides <code>JMSException</code> translation
functionality. The translation converts the checked <code>JMSException</code> hierarchy to a
mirrored hierarchy of unchecked exceptions. If any provider-specific
subclasses of the checked <code>javax.jms.JMSException</code> exist, this exception is wrapped in the
unchecked <code>UncategorizedJmsException</code>.</p>
</div>
<div class="paragraph">
<p>The <code>org.springframework.jms.support.converter</code> package provides a <code>MessageConverter</code>
abstraction to convert between Java objects and JMS messages.</p>
</div>
<div class="paragraph">
<p>The <code>org.springframework.jms.support.destination</code> package provides various strategies
for managing JMS destinations, such as providing a service locator for destinations
stored in JNDI.</p>
</div>
<div class="paragraph">
<p>The <code>org.springframework.jms.annotation</code> package provides the necessary infrastructure
to support annotation-driven listener endpoints by using <code>@JmsListener</code>.</p>
</div>
<div class="paragraph">
<p>The <code>org.springframework.jms.config</code> package provides the parser implementation for the
<code>jms</code> namespace as well as the java config support to configure listener containers and
create listener endpoints.</p>
</div>
<div class="paragraph">
<p>Finally, the <code>org.springframework.jms.connection</code> package provides an implementation of
the <code>ConnectionFactory</code> suitable for use in standalone applications. It also contains an
implementation of Spring&#8217;s <code>PlatformTransactionManager</code> for JMS (the cunningly named
<code>JmsTransactionManager</code>). This allows for seamless integration of JMS as a transactional
resource into Spring&#8217;s transaction management mechanisms.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>As of Spring Framework 5, Spring&#8217;s JMS package fully supports JMS 2.0 and requires the
JMS 2.0 API to be present at runtime. We recommend the use of a JMS 2.0 compatible provider.</p>
</div>
<div class="paragraph">
<p>If you happen to use an older message broker in your system, you may try upgrading to a
JMS 2.0 compatible driver for your existing broker generation. Alternatively, you may also
try to run against a JMS 1.1 based driver, simply putting the JMS 2.0 API jar on the
classpath but only using JMS 1.1 compatible API against your driver. Spring&#8217;s JMS support
adheres to JMS 1.1 conventions by default, so with corresponding configuration it does
support such a scenario. However, please consider this for transition scenarios only.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="jms-using"><a class="anchor" href="#jms-using"></a>4.1. Using Spring JMS</h3>
<div class="paragraph">
<p>This section describes how to use Spring&#8217;s JMS components.</p>
</div>
<div class="sect3">
<h4 id="jms-jmstemplate"><a class="anchor" href="#jms-jmstemplate"></a>4.1.1. Using <code>JmsTemplate</code></h4>
<div class="paragraph">
<p>The <code>JmsTemplate</code> class is the central class in the JMS core package. It simplifies the
use of JMS, since it handles the creation and release of resources when sending or
synchronously receiving messages.</p>
</div>
<div class="paragraph">
<p>Code that uses the <code>JmsTemplate</code> needs only to implement callback interfaces that give them
a clearly defined high-level contract. The <code>MessageCreator</code> callback interface creates a
message when given a <code>Session</code> provided by the calling code in <code>JmsTemplate</code>. To
allow for more complex usage of the JMS API, <code>SessionCallback</code> provides the
JMS session, and <code>ProducerCallback</code> exposes a <code>Session</code> and
<code>MessageProducer</code> pair.</p>
</div>
<div class="paragraph">
<p>The JMS API exposes two types of send methods, one that takes delivery mode, priority,
and time-to-live as Quality of Service (QOS) parameters and one that takes no QOS
parameters and uses default values. Since <code>JmsTemplate</code> has many send methods,
setting the QOS parameters have been exposed as bean properties to
avoid duplication in the number of send methods. Similarly, the timeout value for
synchronous receive calls is set by using the <code>setReceiveTimeout</code> property.</p>
</div>
<div class="paragraph">
<p>Some JMS providers allow the setting of default QOS values administratively through the
configuration of the <code>ConnectionFactory</code>. This has the effect that a call to a
<code>MessageProducer</code> instance&#8217;s <code>send</code> method (<code>send(Destination destination, Message message)</code>)
uses different QOS default values than those specified in the JMS specification. In order
to provide consistent management of QOS values, the <code>JmsTemplate</code> must, therefore, be
specifically enabled to use its own QOS values by setting the boolean property
<code>isExplicitQosEnabled</code> to <code>true</code>.</p>
</div>
<div class="paragraph">
<p>For convenience, <code>JmsTemplate</code> also exposes a basic request-reply operation that allows
for sending a message and waiting for a reply on a temporary queue that is created as part of
the operation.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Instances of the <code>JmsTemplate</code> class are thread-safe, once configured. This is
important, because it means that you can configure a single instance of a <code>JmsTemplate</code>
and then safely inject this shared reference into multiple collaborators. To be
clear, the <code>JmsTemplate</code> is stateful, in that it maintains a reference to a
<code>ConnectionFactory</code>, but this state is not conversational state.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As of Spring Framework 4.1, <code>JmsMessagingTemplate</code> is built on top of <code>JmsTemplate</code>
and provides an integration with the messaging abstraction&#8201;&#8212;&#8201;that is,
<code>org.springframework.messaging.Message</code>. This lets you create the message to
send in a generic manner.</p>
</div>
</div>
<div class="sect3">
<h4 id="jms-connections"><a class="anchor" href="#jms-connections"></a>4.1.2. Connections</h4>
<div class="paragraph">
<p>The <code>JmsTemplate</code> requires a reference to a <code>ConnectionFactory</code>. The <code>ConnectionFactory</code>
is part of the JMS specification and serves as the entry point for working with JMS. It
is used by the client application as a factory to create connections with the JMS
provider and encapsulates various configuration parameters, many of which are
vendor-specific, such as SSL configuration options.</p>
</div>
<div class="paragraph">
<p>When using JMS inside an EJB, the vendor provides implementations of the JMS interfaces
so that they can participate in declarative transaction management and perform pooling
of connections and sessions. In order to use this implementation, Java EE containers
typically require that you declare a JMS connection factory as a <code>resource-ref</code> inside
the EJB or servlet deployment descriptors. To ensure the use of these features with the
<code>JmsTemplate</code> inside an EJB, the client application should ensure that it references the
managed implementation of the <code>ConnectionFactory</code>.</p>
</div>
<div class="sect4">
<h5 id="jms-caching-resources"><a class="anchor" href="#jms-caching-resources"></a>Caching Messaging Resources</h5>
<div class="paragraph">
<p>The standard API involves creating many intermediate objects. To send a message, the
following 'API' walk is performed:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ConnectionFactory-&gt;Connection-&gt;Session-&gt;MessageProducer-&gt;send</pre>
</div>
</div>
<div class="paragraph">
<p>Between the <code>ConnectionFactory</code> and the <code>Send</code> operation, three intermediate
objects are created and destroyed. To optimize the resource usage and increase
performance, Spring provides two implementations of <code>ConnectionFactory</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="jms-connection-factory"><a class="anchor" href="#jms-connection-factory"></a>Using <code>SingleConnectionFactory</code></h5>
<div class="paragraph">
<p>Spring provides an implementation of the <code>ConnectionFactory</code> interface,
<code>SingleConnectionFactory</code>, that returns the same <code>Connection</code> on all
<code>createConnection()</code> calls and ignores calls to <code>close()</code>. This is useful for testing and
standalone environments so that the same connection can be used for multiple
<code>JmsTemplate</code> calls that may span any number of transactions. <code>SingleConnectionFactory</code>
takes a reference to a standard <code>ConnectionFactory</code> that would typically come from JNDI.</p>
</div>
</div>
<div class="sect4">
<h5 id="jdbc-connection-factory-caching"><a class="anchor" href="#jdbc-connection-factory-caching"></a>Using <code>CachingConnectionFactory</code></h5>
<div class="paragraph">
<p>The <code>CachingConnectionFactory</code> extends the functionality of <code>SingleConnectionFactory</code>
and adds the caching of <code>Session</code>, <code>MessageProducer</code>, and <code>MessageConsumer</code> instances. The initial
cache size is set to <code>1</code>. You can use the <code>sessionCacheSize</code> property to increase the number of
cached sessions. Note that the number of actual cached sessions is more than that
number, as sessions are cached based on their acknowledgment mode, so there can be up to
four cached session instances (one for each
acknowledgment mode) when <code>sessionCacheSize</code> is set to one . <code>MessageProducer</code> and <code>MessageConsumer</code> instances are cached within their
owning session and also take into account the unique properties of the producers and
consumers when caching. MessageProducers are cached based on their destination.
MessageConsumers are cached based on a key composed of the destination, selector,
noLocal delivery flag, and the durable subscription name (if creating durable consumers).</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jms-destinations"><a class="anchor" href="#jms-destinations"></a>4.1.3. Destination Management</h4>
<div class="paragraph">
<p>Destinations, as <code>ConnectionFactory</code> instances, are JMS administered objects that you can store
and retrieved in JNDI. When configuring a Spring application context, you can use the
JNDI <code>JndiObjectFactoryBean</code> factory class or <code>&lt;jee:jndi-lookup&gt;</code> to perform dependency
injection on your object&#8217;s references to JMS destinations. However, this strategy
is often cumbersome if there are a large number of destinations in the application or if there
are advanced destination management features unique to the JMS provider. Examples of
such advanced destination management include the creation of dynamic destinations or
support for a hierarchical namespace of destinations. The <code>JmsTemplate</code> delegates the
resolution of a destination name to a JMS destination object that implements the
<code>DestinationResolver</code> interface. <code>DynamicDestinationResolver</code> is the default
implementation used by <code>JmsTemplate</code> and accommodates resolving dynamic destinations. A
<code>JndiDestinationResolver</code> is also provided to act as a service locator for
destinations contained in JNDI and optionally falls back to the behavior contained in
<code>DynamicDestinationResolver</code>.</p>
</div>
<div class="paragraph">
<p>Quite often, the destinations used in a JMS application are only known at runtime and,
therefore, cannot be administratively created when the application is deployed. This is
often because there is shared application logic between interacting system components
that create destinations at runtime according to a well-known naming convention. Even
though the creation of dynamic destinations is not part of the JMS specification, most
vendors have provided this functionality. Dynamic destinations are created with a user-defined name,
which differentiates them from temporary destinations, and are often
not registered in JNDI. The API used to create dynamic destinations varies from provider
to provider since the properties associated with the destination are vendor-specific.
However, a simple implementation choice that is sometimes made by vendors is to
disregard the warnings in the JMS specification and to use the method <code>TopicSession</code>
<code>createTopic(String topicName)</code> or the <code>QueueSession</code> <code>createQueue(String
queueName)</code> method to create a new destination with default destination properties. Depending
on the vendor implementation, <code>DynamicDestinationResolver</code> can then also create a
physical destination instead of only resolving one.</p>
</div>
<div class="paragraph">
<p>The boolean property <code>pubSubDomain</code> is used to configure the <code>JmsTemplate</code> with
knowledge of what JMS domain is being used. By default, the value of this property is
false, indicating that the point-to-point domain, <code>Queues</code>, is to be used. This property
(used by <code>JmsTemplate</code>) determines the behavior of dynamic destination resolution through
implementations of the <code>DestinationResolver</code> interface.</p>
</div>
<div class="paragraph">
<p>You can also configure the <code>JmsTemplate</code> with a default destination through the
property <code>defaultDestination</code>. The default destination is with send and receive
operations that do not refer to a specific destination.</p>
</div>
</div>
<div class="sect3">
<h4 id="jms-mdp"><a class="anchor" href="#jms-mdp"></a>4.1.4. Message Listener Containers</h4>
<div class="paragraph">
<p>One of the most common uses of JMS messages in the EJB world is to drive message-driven
beans (MDBs). Spring offers a solution to create message-driven POJOs (MDPs) in a way
that does not tie a user to an EJB container. (See <a href="#jms-receiving-async">Asynchronous reception: Message-Driven POJOs</a> for detailed
coverage of Spring&#8217;s MDP support.) Since Spring Framework 4.1, endpoint methods can be
annotated with <code>@JmsListener</code>&#8201;&#8212;&#8201;see <a href="#jms-annotated">Annotation-driven Listener Endpoints</a> for more details.</p>
</div>
<div class="paragraph">
<p>A message listener container is used to receive messages from a JMS message queue and
drive the <code>MessageListener</code> that is injected into it. The listener container is
responsible for all threading of message reception and dispatches into the listener for
processing. A message listener container is the intermediary between an MDP and a
messaging provider and takes care of registering to receive messages, participating in
transactions, resource acquisition and release, exception conversion, and so on. This
lets you write the (possibly complex) business logic
associated with receiving a message (and possibly respond to it), and delegates
boilerplate JMS infrastructure concerns to the framework.</p>
</div>
<div class="paragraph">
<p>There are two standard JMS message listener containers packaged with Spring, each with
its specialized feature set.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#jms-mdp-simple"><code>SimpleMessageListenerContainer</code></a></p>
</li>
<li>
<p><a href="#jms-mdp-default"><code>DefaultMessageListenerContainer</code></a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="jms-mdp-simple"><a class="anchor" href="#jms-mdp-simple"></a>Using <code>SimpleMessageListenerContainer</code></h5>
<div class="paragraph">
<p>This message listener container is the simpler of the two standard flavors. It creates
a fixed number of JMS sessions and consumers at startup, registers the listener by using
the standard JMS <code>MessageConsumer.setMessageListener()</code> method, and leaves it up the JMS
provider to perform listener callbacks. This variant does not allow for dynamic adaption
to runtime demands or for participation in externally managed transactions.
Compatibility-wise, it stays very close to the spirit of the standalone JMS
specification, but is generally not compatible with Java EE&#8217;s JMS restrictions.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
While <code>SimpleMessageListenerContainer</code> does not allow for participation in externally
managed transactions, it does support native JMS transactions. To enable this feature,
you can switch the <code>sessionTransacted</code> flag to <code>true</code> or, in the XML namespace, set the
<code>acknowledge</code> attribute to <code>transacted</code>. Exceptions thrown from your listener then lead
to a rollback, with the message getting redelivered. Alternatively, consider using
<code>CLIENT_ACKNOWLEDGE</code> mode, which provides redelivery in case of an exception as well but
does not use transacted <code>Session</code> instances and, therefore, does not include any other
<code>Session</code> operations (such as sending response messages) in the transaction protocol.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The default <code>AUTO_ACKNOWLEDGE</code> mode does not provide proper reliability guarantees.
Messages can get lost when listener execution fails (since the provider automatically
acknowledges each message after listener invocation, with no exceptions to be propagated to
the provider) or when the listener container shuts down (you can configure this by setting
the <code>acceptMessagesWhileStopping</code> flag). Make sure to use transacted sessions in case of
reliability needs (for example, for reliable queue handling and durable topic subscriptions).
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="jms-mdp-default"><a class="anchor" href="#jms-mdp-default"></a>Using <code>DefaultMessageListenerContainer</code></h5>
<div class="paragraph">
<p>This message listener container is used in most cases. In contrast to
<code>SimpleMessageListenerContainer</code>, this container variant allows for dynamic adaptation
to runtime demands and is able to participate in externally managed transactions.
Each received message is registered with an XA transaction when configured with a
<code>JtaTransactionManager</code>. As a result, processing may take advantage of XA transaction
semantics. This listener container strikes a good balance between low requirements on
the JMS provider, advanced functionality (such as participation in externally managed
transactions), and compatibility with Java EE environments.</p>
</div>
<div class="paragraph">
<p>You can customize the cache level of the container. Note that, when no caching is enabled,
a new connection and a new session is created for each message reception. Combining this
with a non-durable subscription with high loads may lead to message loss. Make sure to
use a proper cache level in such a case.</p>
</div>
<div class="paragraph">
<p>This container also has recoverable capabilities when the broker goes down. By default,
a simple <code>BackOff</code> implementation retries every five seconds. You can specify
a custom <code>BackOff</code> implementation for more fine-grained recovery options. See
api-spring-framework/util/backoff/ExponentialBackOff.html[<code>ExponentialBackOff</code>] for an example.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Like its sibling (<a href="#jms-mdp-simple"><code>SimpleMessageListenerContainer</code></a>),
<code>DefaultMessageListenerContainer</code> supports native JMS transactions and allows for
customizing the acknowledgment mode. If feasible for your scenario, This is strongly
recommended over externally managed transactions&#8201;&#8212;&#8201;that is, if you can live with
occasional duplicate messages in case of the JVM dying. Custom duplicate message
detection steps in your business logic can cover such situations&#8201;&#8212;&#8201;for example,
in the form of a business entity existence check or a protocol table check.
Any such arrangements are significantly more efficient than the alternative:
wrapping your entire processing with an XA transaction (through configuring your
<code>DefaultMessageListenerContainer</code> with an <code>JtaTransactionManager</code>) to cover the
reception of the JMS message as well as the execution of the business logic in your
message listener (including database operations etc).
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The default <code>AUTO_ACKNOWLEDGE</code> mode does not provide proper reliability guarantees.
Messages can get lost when listener execution fails (since the provider automatically
acknowledges each message after listener invocation, with no exceptions to be propagated to
the provider) or when the listener container shuts down (you can configure this by setting
the <code>acceptMessagesWhileStopping</code> flag). Make sure to use transacted sessions in case of
reliability needs (for example, for reliable queue handling and durable topic subscriptions).
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jms-tx"><a class="anchor" href="#jms-tx"></a>4.1.5. Transaction Management</h4>
<div class="paragraph">
<p>Spring provides a <code>JmsTransactionManager</code> that manages transactions for a single JMS
<code>ConnectionFactory</code>. This lets JMS applications leverage the managed-transaction
features of Spring, as described in
<a href="data-access.html#transaction">Transaction Management section of the Data Access chapter</a>.
The <code>JmsTransactionManager</code> performs local resource transactions, binding a JMS
Connection/Session pair from the specified <code>ConnectionFactory</code> to the thread.
<code>JmsTemplate</code> automatically detects such transactional resources and operates
on them accordingly.</p>
</div>
<div class="paragraph">
<p>In a Java EE environment, the <code>ConnectionFactory</code> pools Connection and Session instances,
so those resources are efficiently reused across transactions. In a standalone environment,
using Spring&#8217;s <code>SingleConnectionFactory</code> result in a shared JMS <code>Connection</code>, with
each transaction having its own independent <code>Session</code>. Alternatively, consider the use
of a provider-specific pooling adapter, such as ActiveMQ&#8217;s <code>PooledConnectionFactory</code>
class.</p>
</div>
<div class="paragraph">
<p>You can also use <code>JmsTemplate</code> with the <code>JtaTransactionManager</code> and an XA-capable JMS
<code>ConnectionFactory</code> to perform distributed transactions. Note that this requires the
use of a JTA transaction manager as well as a properly XA-configured ConnectionFactory.
(Check your Java EE server&#8217;s or JMS provider&#8217;s documentation.)</p>
</div>
<div class="paragraph">
<p>Reusing code across a managed and unmanaged transactional environment can be confusing
when using the JMS API to create a <code>Session</code> from a <code>Connection</code>. This is because the
JMS API has only one factory method to create a <code>Session</code>, and it requires values for the
transaction and acknowledgment modes. In a managed environment, setting these values is
the responsibility of the environment&#8217;s transactional infrastructure, so these values
are ignored by the vendor&#8217;s wrapper to the JMS Connection. When you use the <code>JmsTemplate</code>
in an unmanaged environment, you can specify these values through the use of the
properties <code>sessionTransacted</code> and <code>sessionAcknowledgeMode</code>. When you use a
<code>PlatformTransactionManager</code> with <code>JmsTemplate</code>, the template is always given a
transactional JMS <code>Session</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jms-sending"><a class="anchor" href="#jms-sending"></a>4.2. Sending a Message</h3>
<div class="paragraph">
<p>The <code>JmsTemplate</code> contains many convenience methods to send a message. Send
methods specify the destination by using a <code>javax.jms.Destination</code> object, and others
specify the destination by using a <code>String</code> in a JNDI lookup. The <code>send</code> method
that takes no destination argument uses the default destination.</p>
</div>
<div class="paragraph">
<p>The following example uses the <code>MessageCreator</code> callback to create a text message from the
supplied <code>Session</code> object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import javax.jms.ConnectionFactory;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.Queue;
import javax.jms.Session;

import org.springframework.jms.core.MessageCreator;
import org.springframework.jms.core.JmsTemplate;

public class JmsQueueSender {

    private JmsTemplate jmsTemplate;
    private Queue queue;

    public void setConnectionFactory(ConnectionFactory cf) {
        this.jmsTemplate = new JmsTemplate(cf);
    }

    public void setQueue(Queue queue) {
        this.queue = queue;
    }

    public void simpleSend() {
        this.jmsTemplate.send(this.queue, new MessageCreator() {
            public Message createMessage(Session session) throws JMSException {
                return session.createTextMessage("hello queue world");
            }
        });
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the <code>JmsTemplate</code> is constructed by passing a reference to a
<code>ConnectionFactory</code>. As an alternative, a zero-argument constructor and
<code>connectionFactory</code> is provided and can be used for constructing the instance in
JavaBean style (using a <code>BeanFactory</code> or plain Java code). Alternatively, consider
deriving from Spring&#8217;s <code>JmsGatewaySupport</code> convenience base class, which provides
pre-built bean properties for JMS configuration.</p>
</div>
<div class="paragraph">
<p>The <code>send(String destinationName, MessageCreator creator)</code> method lets you send a
message by using the string name of the destination. If these names are registered in JNDI,
you should set the <code>destinationResolver</code> property of the template to an instance of
<code>JndiDestinationResolver</code>.</p>
</div>
<div class="paragraph">
<p>If you created the <code>JmsTemplate</code> and specified a default destination, the
<code>send(MessageCreator c)</code> sends a message to that destination.</p>
</div>
<div class="sect3">
<h4 id="jms-msg-conversion"><a class="anchor" href="#jms-msg-conversion"></a>4.2.1. Using Message Converters</h4>
<div class="paragraph">
<p>To facilitate the sending of domain model objects, the <code>JmsTemplate</code> has
various send methods that take a Java object as an argument for a message&#8217;s data
content. The overloaded methods <code>convertAndSend()</code> and <code>receiveAndConvert()</code> methods in
<code>JmsTemplate</code> delegate the conversion process to an instance of the <code>MessageConverter</code>
interface. This interface defines a simple contract to convert between Java objects and
JMS messages. The default implementation (<code>SimpleMessageConverter</code>) supports conversion
between <code>String</code> and <code>TextMessage</code>, <code>byte[]</code> and <code>BytesMesssage</code>, and <code>java.util.Map</code>
and <code>MapMessage</code>. By using the converter, you and your application code can focus on the
business object that is being sent or received through JMS and not be concerned with the
details of how it is represented as a JMS message.</p>
</div>
<div class="paragraph">
<p>The sandbox currently includes a <code>MapMessageConverter</code>, which uses reflection to convert
between a JavaBean and a <code>MapMessage</code>. Other popular implementation choices you might
implement yourself are converters that use an existing XML marshalling package (such as
JAXB or XStream) to create a <code>TextMessage</code> that represents the object.</p>
</div>
<div class="paragraph">
<p>To accommodate the setting of a message&#8217;s properties, headers, and body that can not be
generically encapsulated inside a converter class, the <code>MessagePostProcessor</code> interface
gives you access to the message after it has been converted but before it is sent. The
following example shows how to modify a message header and a property after a
<code>java.util.Map</code> is converted to a message:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public void sendWithConversion() {
    Map map = new HashMap();
    map.put("Name", "Mark");
    map.put("Age", new Integer(47));
    jmsTemplate.convertAndSend("testQueue", map, new MessagePostProcessor() {
        public Message postProcessMessage(Message message) throws JMSException {
            message.setIntProperty("AccountID", 1234);
            message.setJMSCorrelationID("123-00001");
            return message;
        }
    });
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This results in a message of the following form:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>MapMessage={
    Header={
        ... standard headers ...
        CorrelationID={123-00001}
    }
    Properties={
        AccountID={Integer:1234}
    }
    Fields={
        Name={String:Mark}
        Age={Integer:47}
    }
}</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jms-callbacks"><a class="anchor" href="#jms-callbacks"></a>4.2.2. Using <code>SessionCallback</code> and <code>ProducerCallback</code></h4>
<div class="paragraph">
<p>While the send operations cover many common usage scenarios, you might sometimes
want to perform multiple operations on a JMS <code>Session</code> or <code>MessageProducer</code>. The
<code>SessionCallback</code> and <code>ProducerCallback</code> expose the JMS <code>Session</code> and <code>Session</code> /
<code>MessageProducer</code> pair, respectively. The <code>execute()</code> methods on <code>JmsTemplate</code> run
these callback methods.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jms-receiving"><a class="anchor" href="#jms-receiving"></a>4.3. Receiving a Message</h3>
<div class="paragraph">
<p>This describes how to receive messages with JMS in Spring.</p>
</div>
<div class="sect3">
<h4 id="jms-receiving-sync"><a class="anchor" href="#jms-receiving-sync"></a>4.3.1. Synchronous Reception</h4>
<div class="paragraph">
<p>While JMS is typically associated with asynchronous processing, you can
consume messages synchronously. The overloaded <code>receive(..)</code> methods provide this
functionality. During a synchronous receive, the calling thread blocks until a message
becomes available. This can be a dangerous operation, since the calling thread can
potentially be blocked indefinitely. The <code>receiveTimeout</code> property specifies how long
the receiver should wait before giving up waiting for a message.</p>
</div>
</div>
<div class="sect3">
<h4 id="jms-receiving-async"><a class="anchor" href="#jms-receiving-async"></a>4.3.2. Asynchronous reception: Message-Driven POJOs</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring also supports annotated-listener endpoints through the use of the <code>@JmsListener</code>
annotation and provides an open infrastructure to register endpoints programmatically.
This is, by far, the most convenient way to setup an asynchronous receiver.
See <a href="#jms-annotated-support">Enable Listener Endpoint Annotations</a> for more details.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In a fashion similar to a Message-Driven Bean (MDB) in the EJB world, the Message-Driven
POJO (MDP) acts as a receiver for JMS messages. The one restriction (but see
<a href="#jms-receiving-async-message-listener-adapter">Using <code>MessageListenerAdapter</code></a>) on an MDP is that it must implement
the <code>javax.jms.MessageListener</code> interface. Note that, if your POJO receives messages
on multiple threads, it is important to ensure that your implementation is thread-safe.</p>
</div>
<div class="paragraph">
<p>The following example shows a simple implementation of an MDP:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageListener;
import javax.jms.TextMessage;

public class ExampleListener implements MessageListener {

    public void onMessage(Message message) {
        if (message instanceof TextMessage) {
            try {
                System.out.println(((TextMessage) message).getText());
            }
            catch (JMSException ex) {
                throw new RuntimeException(ex);
            }
        }
        else {
            throw new IllegalArgumentException("Message must be of type TextMessage");
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once you have implemented your <code>MessageListener</code>, it is time to create a message listener
container.</p>
</div>
<div class="paragraph">
<p>The following example shows how to define and configure one of the message listener
containers that ships with Spring (in this case, <code>DefaultMessageListenerContainer</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;!-- this is the Message Driven POJO (MDP) --&gt;
&lt;bean id="messageListener" class="jmsexample.ExampleListener"/&gt;

&lt;!-- and this is the message listener container --&gt;
&lt;bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt;
    &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
    &lt;property name="destination" ref="destination"/&gt;
    &lt;property name="messageListener" ref="messageListener"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the Spring javadoc of the various message listener containers (all of which implement
<a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/jms/listener/MessageListenerContainer.html">MessageListenerContainer</a>)
for a full description of the features supported by each implementation.</p>
</div>
</div>
<div class="sect3">
<h4 id="jms-receiving-async-session-aware-message-listener"><a class="anchor" href="#jms-receiving-async-session-aware-message-listener"></a>4.3.3. Using the <code>SessionAwareMessageListener</code> Interface</h4>
<div class="paragraph">
<p>The <code>SessionAwareMessageListener</code> interface is a Spring-specific interface that provides
a similar contract to the JMS <code>MessageListener</code> interface but also gives the message-handling
method access to the JMS <code>Session</code> from which the <code>Message</code> was received.
The following listing shows the definition of the <code>SessionAwareMessageListener</code> interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package org.springframework.jms.listener;

public interface SessionAwareMessageListener {

    void onMessage(Message message, Session session) throws JMSException;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can choose to have your MDPs implement this interface (in preference to the standard
JMS <code>MessageListener</code> interface) if you want your MDPs to be able to respond to any
received messages (by using the <code>Session</code> supplied in the <code>onMessage(Message, Session)</code>
method). All of the message listener container implementations that ship with Spring
have support for MDPs that implement either the <code>MessageListener</code> or
<code>SessionAwareMessageListener</code> interface. Classes that implement the
<code>SessionAwareMessageListener</code> come with the caveat that they are then tied to Spring
through the interface. The choice of whether or not to use it is left entirely up to you
as an application developer or architect.</p>
</div>
<div class="paragraph">
<p>Note that the <code>onMessage(..)</code> method of the <code>SessionAwareMessageListener</code>
interface throws <code>JMSException</code>. In contrast to the standard JMS <code>MessageListener</code>
interface, when using the <code>SessionAwareMessageListener</code> interface, it is the
responsibility of the client code to handle any thrown exceptions.</p>
</div>
</div>
<div class="sect3">
<h4 id="jms-receiving-async-message-listener-adapter"><a class="anchor" href="#jms-receiving-async-message-listener-adapter"></a>4.3.4. Using <code>MessageListenerAdapter</code></h4>
<div class="paragraph">
<p>The <code>MessageListenerAdapter</code> class is the final component in Spring&#8217;s asynchronous
messaging support. In a nutshell, it lets you expose almost any class as an MDP
(though there are some constraints).</p>
</div>
<div class="paragraph">
<p>Consider the following interface definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface MessageDelegate {

    void handleMessage(String message);

    void handleMessage(Map message);

    void handleMessage(byte[] message);

    void handleMessage(Serializable message);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that, although the interface extends neither the <code>MessageListener</code> nor the
<code>SessionAwareMessageListener</code> interface, you can still use it as an MDP by using the
<code>MessageListenerAdapter</code> class. Notice also how the various message handling methods are
strongly typed according to the contents of the various <code>Message</code> types that they can
receive and handle.</p>
</div>
<div class="paragraph">
<p>Now consider the following implementation of the <code>MessageDelegate</code> interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class DefaultMessageDelegate implements MessageDelegate {
    // implementation elided for clarity...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In particular, note how the preceding implementation of the <code>MessageDelegate</code> interface (the
<code>DefaultMessageDelegate</code> class) has no JMS dependencies at all. It truly is a
POJO that we can make into an MDP through the following configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;!-- this is the Message Driven POJO (MDP) --&gt;
&lt;bean id="messageListener" class="org.springframework.jms.listener.adapter.MessageListenerAdapter"&gt;
    &lt;constructor-arg&gt;
        &lt;bean class="jmsexample.DefaultMessageDelegate"/&gt;
    &lt;/constructor-arg&gt;
&lt;/bean&gt;

&lt;!-- and this is the message listener container... --&gt;
&lt;bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt;
    &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
    &lt;property name="destination" ref="destination"/&gt;
    &lt;property name="messageListener" ref="messageListener"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The next example shows another MDP that can handle only receiving JMS
<code>TextMessage</code> messages. Notice how the message handling method is actually called
<code>receive</code> (the name of the message handling method in a <code>MessageListenerAdapter</code>
defaults to <code>handleMessage</code>), but it is configurable (as you can see later in this section). Notice
also how the <code>receive(..)</code> method is strongly typed to receive and respond only to JMS
<code>TextMessage</code> messages.
The following listing shows the definition of the <code>TextMessageDelegate</code> interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface TextMessageDelegate {

    void receive(TextMessage message);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following listing shows a class that implements the <code>TextMessageDelegate</code> interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class DefaultTextMessageDelegate implements TextMessageDelegate {
    // implementation elided for clarity...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The configuration of the attendant <code>MessageListenerAdapter</code> would then be as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="messageListener" class="org.springframework.jms.listener.adapter.MessageListenerAdapter"&gt;
    &lt;constructor-arg&gt;
        &lt;bean class="jmsexample.DefaultTextMessageDelegate"/&gt;
    &lt;/constructor-arg&gt;
    &lt;property name="defaultListenerMethod" value="receive"/&gt;
    &lt;!-- we don't want automatic message context extraction --&gt;
    &lt;property name="messageConverter"&gt;
        &lt;null/&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that, if the <code>messageListener</code> receives a JMS <code>Message</code> of a type
other than <code>TextMessage</code>, an <code>IllegalStateException</code> is thrown (and subsequently
swallowed). Another of the capabilities of the <code>MessageListenerAdapter</code> class is the
ability to automatically send back a response <code>Message</code> if a handler method returns a
non-void value. Consider the following interface and class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface ResponsiveTextMessageDelegate {

    // notice the return type...
    String receive(TextMessage message);
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class DefaultResponsiveTextMessageDelegate implements ResponsiveTextMessageDelegate {
    // implementation elided for clarity...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you use the <code>DefaultResponsiveTextMessageDelegate</code> in conjunction with a
<code>MessageListenerAdapter</code>, any non-null value that is returned from the execution of
the <code>'receive(..)'</code> method is (in the default configuration) converted into a
<code>TextMessage</code>. The resulting <code>TextMessage</code> is then sent to the <code>Destination</code> (if
one exists) defined in the JMS <code>Reply-To</code> property of the original <code>Message</code> or the
default <code>Destination</code> set on the <code>MessageListenerAdapter</code> (if one has been configured).
If no <code>Destination</code> is found, an <code>InvalidDestinationException</code> is thrown
(note that this exception is not swallowed and propagates up the
call stack).</p>
</div>
</div>
<div class="sect3">
<h4 id="jms-tx-participation"><a class="anchor" href="#jms-tx-participation"></a>4.3.5. Processing Messages Within Transactions</h4>
<div class="paragraph">
<p>Invoking a message listener within a transaction requires only reconfiguration of the
listener container.</p>
</div>
<div class="paragraph">
<p>You can activate local resource transactions through the <code>sessionTransacted</code> flag
on the listener container definition. Each message listener invocation then operates
within an active JMS transaction, with message reception rolled back in case of listener
execution failure. Sending a response message (through <code>SessionAwareMessageListener</code>) is
part of the same local transaction, but any other resource operations (such as
database access) operate independently. This usually requires duplicate message
detection in the listener implementation, to cover the case where database processing
has committed but message processing failed to commit.</p>
</div>
<div class="paragraph">
<p>Consider the following bean definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt;
    &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
    &lt;property name="destination" ref="destination"/&gt;
    &lt;property name="messageListener" ref="messageListener"/&gt;
    &lt;property name="sessionTransacted" value="true"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>To participate in an externally managed transaction, you need to configure a
transaction manager and use a listener container that supports externally managed
transactions (typically, <code>DefaultMessageListenerContainer</code>).</p>
</div>
<div class="paragraph">
<p>To configure a message listener container for XA transaction participation, you want
to configure a <code>JtaTransactionManager</code> (which, by default, delegates to the Java EE
server&#8217;s transaction subsystem). Note that the underlying JMS <code>ConnectionFactory</code> needs to
be XA-capable and properly registered with your JTA transaction coordinator. (Check your
Java EE server&#8217;s configuration of JNDI resources.) This lets message reception as well
as (for example) database access be part of the same transaction (with unified commit
semantics, at the expense of XA transaction log overhead).</p>
</div>
<div class="paragraph">
<p>The following bean definition creates a transaction manager:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="transactionManager" class="org.springframework.transaction.jta.JtaTransactionManager"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then we need to add it to our earlier container configuration. The container
takes care of the rest. The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt;
    &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
    &lt;property name="destination" ref="destination"/&gt;
    &lt;property name="messageListener" ref="messageListener"/&gt;
    &lt;property name="transactionManager" ref="transactionManager"/&gt; <i class="conum" data-value="1"></i><b>(1)</b>
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Our transaction manager.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jms-jca-message-endpoint-manager"><a class="anchor" href="#jms-jca-message-endpoint-manager"></a>4.4. Support for JCA Message Endpoints</h3>
<div class="paragraph">
<p>Beginning with version 2.5, Spring also provides support for a JCA-based
<code>MessageListener</code> container. The <code>JmsMessageEndpointManager</code> tries to
automatically determine the <code>ActivationSpec</code> class name from the provider&#8217;s
<code>ResourceAdapter</code> class name. Therefore, it is typically possible to provide
Spring&#8217;s generic <code>JmsActivationSpecConfig</code>, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean class="org.springframework.jms.listener.endpoint.JmsMessageEndpointManager"&gt;
    &lt;property name="resourceAdapter" ref="resourceAdapter"/&gt;
    &lt;property name="activationSpecConfig"&gt;
        &lt;bean class="org.springframework.jms.listener.endpoint.JmsActivationSpecConfig"&gt;
            &lt;property name="destinationName" value="myQueue"/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name="messageListener" ref="myMessageListener"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, you can set up a <code>JmsMessageEndpointManager</code> with a given
<code>ActivationSpec</code> object. The <code>ActivationSpec</code> object may also come from a JNDI lookup
(using <code>&lt;jee:jndi-lookup&gt;</code>). The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean class="org.springframework.jms.listener.endpoint.JmsMessageEndpointManager"&gt;
    &lt;property name="resourceAdapter" ref="resourceAdapter"/&gt;
    &lt;property name="activationSpec"&gt;
        &lt;bean class="org.apache.activemq.ra.ActiveMQActivationSpec"&gt;
            &lt;property name="destination" value="myQueue"/&gt;
            &lt;property name="destinationType" value="javax.jms.Queue"/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name="messageListener" ref="myMessageListener"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using Spring&#8217;s <code>ResourceAdapterFactoryBean</code>, you can configure the target <code>ResourceAdapter</code>
locally, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="resourceAdapter" class="org.springframework.jca.support.ResourceAdapterFactoryBean"&gt;
    &lt;property name="resourceAdapter"&gt;
        &lt;bean class="org.apache.activemq.ra.ActiveMQResourceAdapter"&gt;
            &lt;property name="serverUrl" value="tcp://localhost:61616"/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name="workManager"&gt;
        &lt;bean class="org.springframework.jca.work.SimpleTaskWorkManager"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The specified <code>WorkManager</code> can also point to an environment-specific thread pool&#8201;&#8212;&#8201;typically through a <code>SimpleTaskWorkManager</code> instance&#8217;s <code>asyncTaskExecutor</code> property. Consider
defining a shared thread pool for all your <code>ResourceAdapter</code> instances if you happen to
use multiple adapters.</p>
</div>
<div class="paragraph">
<p>In some environments (such as WebLogic 9 or above), you can instead obtain the entire <code>ResourceAdapter</code> object
from JNDI (by using <code>&lt;jee:jndi-lookup&gt;</code>). The Spring-based message
listeners can then interact with the server-hosted <code>ResourceAdapter</code>, which also use the
server&#8217;s built-in <code>WorkManager</code>.</p>
</div>
<div class="paragraph">
<p>See the javadoc for <a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/jms/listener/endpoint/JmsMessageEndpointManager.html"><code>JmsMessageEndpointManager</code></a>,
<a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/jms/listener/endpoint/JmsActivationSpecConfig.html"><code>JmsActivationSpecConfig</code></a>,
and <a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/jca/support/ResourceAdapterFactoryBean.html"><code>ResourceAdapterFactoryBean</code></a>
for more details.</p>
</div>
<div class="paragraph">
<p>Spring also provides a generic JCA message endpoint manager that is not tied to JMS:
<code>org.springframework.jca.endpoint.GenericMessageEndpointManager</code>. This component allows
for using any message listener type (such as a JMS <code>MessageListener</code>) and any
provider-specific <code>ActivationSpec</code> object. See your JCA provider&#8217;s documentation to
find out about the actual capabilities of your connector, and see the
<a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/jca/endpoint/GenericMessageEndpointManager.html"><code>GenericMessageEndpointManager</code></a>
javadoc for the Spring-specific configuration details.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
JCA-based message endpoint management is very analogous to EJB 2.1 Message-Driven Beans.
It uses the same underlying resource provider contract. As with EJB 2.1 MDBs, you can use any
message listener interface supported by your JCA provider in the Spring context as well.
Spring nevertheless provides explicit &#8220;convenience&#8221; support for JMS, because JMS is the
most common endpoint API used with the JCA endpoint management contract.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="jms-annotated"><a class="anchor" href="#jms-annotated"></a>4.5. Annotation-driven Listener Endpoints</h3>
<div class="paragraph">
<p>The easiest way to receive a message asynchronously is to use the annotated listener
endpoint infrastructure. In a nutshell, it lets you expose a method of a managed
bean as a JMS listener endpoint. The following example shows how to use it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Component
public class MyService {

    @JmsListener(destination = "myDestination")
    public void processOrder(String data) { ... }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The idea of the preceding example is that, whenever a message is available on the
<code>javax.jms.Destination</code> <code>myDestination</code>, the <code>processOrder</code> method is invoked
accordingly (in this case, with the content of the JMS message, similar to
what the <a href="#jms-receiving-async-message-listener-adapter"><code>MessageListenerAdapter</code></a>
provides).</p>
</div>
<div class="paragraph">
<p>The annotated endpoint infrastructure creates a message listener container
behind the scenes for each annotated method, by using a <code>JmsListenerContainerFactory</code>.
Such a container is not registered against the application context but can be easily
located for management purposes by using the <code>JmsListenerEndpointRegistry</code> bean.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>@JmsListener</code> is a repeatable annotation on Java 8, so you can associate
several JMS destinations with the same method by adding additional <code>@JmsListener</code>
declarations to it.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="jms-annotated-support"><a class="anchor" href="#jms-annotated-support"></a>4.5.1. Enable Listener Endpoint Annotations</h4>
<div class="paragraph">
<p>To enable support for <code>@JmsListener</code> annotations, you can add <code>@EnableJms</code> to one of
your <code>@Configuration</code> classes, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
@EnableJms
public class AppConfig {

    @Bean
    public DefaultJmsListenerContainerFactory jmsListenerContainerFactory() {
        DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();
        factory.setConnectionFactory(connectionFactory());
        factory.setDestinationResolver(destinationResolver());
        factory.setSessionTransacted(true);
        factory.setConcurrency("3-10");
        return factory;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default, the infrastructure looks for a bean named <code>jmsListenerContainerFactory</code>
as the source for the factory to use to create message listener containers. In this
case (and ignoring the JMS infrastructure setup), you can invoke the <code>processOrder</code>
method with a core poll size of three threads and a maximum pool size of ten threads.</p>
</div>
<div class="paragraph">
<p>You can customize the listener container factory to use for each annotation or you can
configure an explicit default by implementing the <code>JmsListenerConfigurer</code> interface.
The default is required only if at least one endpoint is registered without a specific
container factory. See the javadoc of classes that implement
<a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/jms/annotation/JmsListenerConfigurer.html"><code>JmsListenerConfigurer</code></a>
for details and examples.</p>
</div>
<div class="paragraph">
<p>If you prefer <a href="#jms-namespace">XML configuration</a>, you can use the <code>&lt;jms:annotation-driven&gt;</code>
element, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;jms:annotation-driven/&gt;

&lt;bean id="jmsListenerContainerFactory"
        class="org.springframework.jms.config.DefaultJmsListenerContainerFactory"&gt;
    &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
    &lt;property name="destinationResolver" ref="destinationResolver"/&gt;
    &lt;property name="sessionTransacted" value="true"/&gt;
    &lt;property name="concurrency" value="3-10"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jms-annotated-programmatic-registration"><a class="anchor" href="#jms-annotated-programmatic-registration"></a>4.5.2. Programmatic Endpoint Registration</h4>
<div class="paragraph">
<p><code>JmsListenerEndpoint</code> provides a model of a JMS endpoint and is responsible for configuring
the container for that model. The infrastructure lets you programmatically configure endpoints
in addition to the ones that are detected by the <code>JmsListener</code> annotation.
The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
@EnableJms
public class AppConfig implements JmsListenerConfigurer {

    @Override
    public void configureJmsListeners(JmsListenerEndpointRegistrar registrar) {
        SimpleJmsListenerEndpoint endpoint = new SimpleJmsListenerEndpoint();
        endpoint.setId("myJmsEndpoint");
        endpoint.setDestination("anotherQueue");
        endpoint.setMessageListener(message -&gt; {
            // processing
        });
        registrar.registerEndpoint(endpoint);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, we used <code>SimpleJmsListenerEndpoint</code>, which provides the actual
<code>MessageListener</code> to invoke. However, you could also build your own endpoint variant
to describe a custom invocation mechanism.</p>
</div>
<div class="paragraph">
<p>Note that you could skip the use of <code>@JmsListener</code> altogether
and programmatically register only your endpoints through <code>JmsListenerConfigurer</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="jms-annotated-method-signature"><a class="anchor" href="#jms-annotated-method-signature"></a>4.5.3. Annotated Endpoint Method Signature</h4>
<div class="paragraph">
<p>So far, we have been injecting a simple <code>String</code> in our endpoint, but it can actually
have a very flexible method signature. In the following example, we rewrite it to inject the <code>Order</code> with
a custom header:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Component
public class MyService {

    @JmsListener(destination = "myDestination")
    public void processOrder(Order order, @Header("order_type") String orderType) {
        ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The main elements you can inject in JMS listener endpoints are as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The raw <code>javax.jms.Message</code> or any of its subclasses (provided that it
matches the incoming message type).</p>
</li>
<li>
<p>The <code>javax.jms.Session</code> for optional access to the native JMS API (for example, for sending
a custom reply).</p>
</li>
<li>
<p>The <code>org.springframework.messaging.Message</code> that represents the incoming JMS message.
Note that this message holds both the custom and the standard headers (as defined
by <code>JmsHeaders</code>).</p>
</li>
<li>
<p><code>@Header</code>-annotated method arguments to extract a specific header value, including
standard JMS headers.</p>
</li>
<li>
<p>A <code>@Headers</code>-annotated argument that must also be assignable to <code>java.util.Map</code> for
getting access to all headers.</p>
</li>
<li>
<p>A non-annotated element that is not one of the supported types (<code>Message</code> or
<code>Session</code>) is considered to be the payload. You can make that explicit by annotating
the parameter with <code>@Payload</code>. You can also turn on validation by adding an extra
<code>@Valid</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The ability to inject Spring&#8217;s <code>Message</code> abstraction is particularly useful to benefit
from all the information stored in the transport-specific message without relying on
transport-specific API. The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@JmsListener(destination = "myDestination")
public void processOrder(Message&lt;Order&gt; order) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Handling of method arguments is provided by <code>DefaultMessageHandlerMethodFactory</code>, which you can
further customize to support additional method arguments. You can customize the conversion and validation
support there as well.</p>
</div>
<div class="paragraph">
<p>For instance, if we want to make sure our <code>Order</code> is valid before processing it, we can
annotate the payload with <code>@Valid</code> and configure the necessary validator, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
@EnableJms
public class AppConfig implements JmsListenerConfigurer {

    @Override
    public void configureJmsListeners(JmsListenerEndpointRegistrar registrar) {
        registrar.setMessageHandlerMethodFactory(myJmsHandlerMethodFactory());
    }

    @Bean
    public DefaultMessageHandlerMethodFactory myHandlerMethodFactory() {
        DefaultMessageHandlerMethodFactory factory = new DefaultMessageHandlerMethodFactory();
        factory.setValidator(myValidator());
        return factory;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jms-annotated-response"><a class="anchor" href="#jms-annotated-response"></a>4.5.4. Response Management</h4>
<div class="paragraph">
<p>The existing support in <a href="#jms-receiving-async-message-listener-adapter"><code>MessageListenerAdapter</code></a>
already lets your method have a non-<code>void</code> return type. When that is the case, the result of
the invocation is encapsulated in a <code>javax.jms.Message</code>, sent either in the destination specified
in the <code>JMSReplyTo</code> header of the original message or in the default destination configured on
the listener. You can now set that default destination by using the <code>@SendTo</code> annotation of the
messaging abstraction.</p>
</div>
<div class="paragraph">
<p>Assuming that our <code>processOrder</code> method should now return an <code>OrderStatus</code>, we can write it
to automatically send a response, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@JmsListener(destination = "myDestination")
@SendTo("status")
public OrderStatus processOrder(Order order) {
    // order processing
    return status;
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If you have several <code>@JmsListener</code>-annotated methods, you can also place the <code>@SendTo</code>
annotation at the class level to share a default reply destination.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you need to set additional headers in a transport-independent manner, you can return a
<code>Message</code> instead, with a method similar to the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@JmsListener(destination = "myDestination")
@SendTo("status")
public Message&lt;OrderStatus&gt; processOrder(Order order) {
    // order processing
    return MessageBuilder
            .withPayload(status)
            .setHeader("code", 1234)
            .build();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you need to compute the response destination at runtime, you can encapsulate your response
in a <code>JmsResponse</code> instance that also provides the destination to use at runtime. We can rewrite the previous
example as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@JmsListener(destination = "myDestination")
public JmsResponse&lt;Message&lt;OrderStatus&gt;&gt; processOrder(Order order) {
    // order processing
    Message&lt;OrderStatus&gt; response = MessageBuilder
            .withPayload(status)
            .setHeader("code", 1234)
            .build();
    return JmsResponse.forQueue(response, "status");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, if you need to specify some QoS values for the response such as the priority or
the time to live, you can configure the <code>JmsListenerContainerFactory</code> accordingly,
as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
@EnableJms
public class AppConfig {

    @Bean
    public DefaultJmsListenerContainerFactory jmsListenerContainerFactory() {
        DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();
        factory.setConnectionFactory(connectionFactory());
        QosSettings replyQosSettings = new QosSettings();
        replyQosSettings.setPriority(2);
        replyQosSettings.setTimeToLive(10000);
        factory.setReplyQosSettings(replyQosSettings);
        return factory;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jms-namespace"><a class="anchor" href="#jms-namespace"></a>4.6. JMS Namespace Support</h3>
<div class="paragraph">
<p>Spring provides an XML namespace for simplifying JMS configuration. To use the JMS
namespace elements, you need to reference the JMS schema, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:jms="http://www.springframework.org/schema/jms" <i class="conum" data-value="1"></i><b>(1)</b>
        xsi:schemaLocation="
            http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/jms https://www.springframework.org/schema/jms/spring-jms.xsd"&gt;

    &lt;!-- bean definitions here --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Referencing the JMS schema.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The namespace consists of three top-level elements: <code>&lt;annotation-driven/&gt;</code>, <code>&lt;listener-container/&gt;</code>
and <code>&lt;jca-listener-container/&gt;</code>. <code>&lt;annotation-driven/&gt;</code> enables the use of <a href="#jms-annotated">annotation-driven listener endpoints</a>. <code>&lt;listener-container/&gt;</code> and <code>&lt;jca-listener-container/&gt;</code>
define shared listener container configuration and can contain <code>&lt;listener/&gt;</code> child elements.
The following example shows a basic configuration for two listeners:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;jms:listener-container&gt;

    &lt;jms:listener destination="queue.orders" ref="orderService" method="placeOrder"/&gt;

    &lt;jms:listener destination="queue.confirmations" ref="confirmationLogger" method="log"/&gt;

&lt;/jms:listener-container&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding example is equivalent to creating two distinct listener container bean
definitions and two distinct <code>MessageListenerAdapter</code> bean definitions, as shown
in <a href="#jms-receiving-async-message-listener-adapter">Using <code>MessageListenerAdapter</code></a>. In addition to the attributes shown
in the preceding example, the <code>listener</code> element can contain several optional ones.
The following table describes all of the available attributes:</p>
</div>
<table id="jms-namespace-listener-tbl" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 3. Attributes of the JMS &lt;listener&gt; element</caption>
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 85.7143%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>id</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A bean name for the hosting listener container. If not specified, a bean name is
  automatically generated.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>destination</code> (required)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The destination name for this listener, resolved through the <code>DestinationResolver</code>
  strategy.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ref</code> (required)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The bean name of the handler object.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>method</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The name of the handler method to invoke. If the <code>ref</code> attribute points to a <code>MessageListener</code>
  or Spring <code>SessionAwareMessageListener</code>, you can omit this attribute.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>response-destination</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The name of the default response destination to which to send response messages. This is
  applied in case of a request message that does not carry a <code>JMSReplyTo</code> field. The
  type of this destination is determined by the listener-container&#8217;s
  <code>response-destination-type</code> attribute. Note that this applies only to a listener method with a
  return value, for which each result object is converted into a response message.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>subscription</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The name of the durable subscription, if any.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>selector</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An optional message selector for this listener.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>concurrency</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The number of concurrent sessions or consumers to start for this listener. This value can either be
  a simple number indicating the maximum number (for example, <code>5</code>) or a range indicating the lower
  as well as the upper limit (for example, <code>3-5</code>). Note that a specified minimum is only a hint
  and might be ignored at runtime. The default is the value provided by the container.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The <code>&lt;listener-container/&gt;</code> element also accepts several optional attributes. This
allows for customization of the various strategies (for example, <code>taskExecutor</code> and
<code>destinationResolver</code>) as well as basic JMS settings and resource references. By using
these attributes, you can define highly-customized listener containers while
still benefiting from the convenience of the namespace.</p>
</div>
<div class="paragraph">
<p>You can automatically expose such settings as a <code>JmsListenerContainerFactory</code> by
specifying the <code>id</code> of the bean to expose through the <code>factory-id</code> attribute,
as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;jms:listener-container connection-factory="myConnectionFactory"
        task-executor="myTaskExecutor"
        destination-resolver="myDestinationResolver"
        transaction-manager="myTransactionManager"
        concurrency="10"&gt;

    &lt;jms:listener destination="queue.orders" ref="orderService" method="placeOrder"/&gt;

    &lt;jms:listener destination="queue.confirmations" ref="confirmationLogger" method="log"/&gt;

&lt;/jms:listener-container&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following table describes all available attributes. See the class-level javadoc
of the <a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/jms/listener/AbstractMessageListenerContainer.html"><code>AbstractMessageListenerContainer</code></a>
and its concrete subclasses for more details on the individual properties. The javadoc
also provides a discussion of transaction choices and message redelivery scenarios.</p>
</div>
<table id="jms-namespace-listener-container-tbl" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 4. Attributes of the JMS &lt;listener-container&gt; element</caption>
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 85.7143%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>container-type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The type of this listener container. The available options are <code>default</code>, <code>simple</code>,
  <code>default102</code>, or <code>simple102</code> (the default option is <code>default</code>).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>container-class</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A custom listener container implementation class as a fully qualified class name.
  The default is Spring&#8217;s standard <code>DefaultMessageListenerContainer</code> or
  <code>SimpleMessageListenerContainer</code>, according to the <code>container-type</code> attribute.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>factory-id</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Exposes the settings defined by this element as a <code>JmsListenerContainerFactory</code>
  with the specified <code>id</code> so that they can be reused with other endpoints.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>connection-factory</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A reference to the JMS <code>ConnectionFactory</code> bean (the default bean name is
  <code>connectionFactory</code>).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>task-executor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A reference to the Spring <code>TaskExecutor</code> for the JMS listener invokers.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>destination-resolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A reference to the <code>DestinationResolver</code> strategy for resolving JMS <code>Destination</code> instances.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>message-converter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A reference to the <code>MessageConverter</code> strategy for converting JMS Messages to listener
  method arguments. The default is a <code>SimpleMessageConverter</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>error-handler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A reference to an <code>ErrorHandler</code> strategy for handling any uncaught exceptions that
  may occur during the execution of the <code>MessageListener</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>destination-type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The JMS destination type for this listener: <code>queue</code>, <code>topic</code>, <code>durableTopic</code>, <code>sharedTopic</code>,
  or <code>sharedDurableTopic</code>. This potentially enables the <code>pubSubDomain</code>, <code>subscriptionDurable</code>
  and <code>subscriptionShared</code> properties of the container. The default is <code>queue</code> (which disables
  those three properties).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>response-destination-type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The JMS destination type for responses: <code>queue</code> or <code>topic</code>. The default is the value of the
  <code>destination-type</code> attribute.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>client-id</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The JMS client ID for this listener container. You must specify it when you use
  durable subscriptions.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cache</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The cache level for JMS resources: <code>none</code>, <code>connection</code>, <code>session</code>, <code>consumer</code>, or
  <code>auto</code>. By default (<code>auto</code>), the cache level is effectively <code>consumer</code>, unless
  an external transaction manager has been specified&#8201;&#8212;&#8201;in which case, the effective
  default will be <code>none</code> (assuming Java EE-style transaction management, where the given
  ConnectionFactory is an XA-aware pool).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>acknowledge</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The native JMS acknowledge mode: <code>auto</code>, <code>client</code>, <code>dups-ok</code>, or <code>transacted</code>. A value
  of <code>transacted</code> activates a locally transacted <code>Session</code>. As an alternative, you can specify
  the <code>transaction-manager</code> attribute, described later in table. The default is <code>auto</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>transaction-manager</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A reference to an external <code>PlatformTransactionManager</code> (typically an XA-based
  transaction coordinator, such as Spring&#8217;s <code>JtaTransactionManager</code>). If not specified,
  native acknowledging is used (see the <code>acknowledge</code> attribute).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>concurrency</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The number of concurrent sessions or consumers to start for each listener. It can either be
  a simple number indicating the maximum number (for example, <code>5</code>) or a range indicating the
  lower as well as the upper limit (for example, <code>3-5</code>). Note that a specified minimum is just a
  hint and might be ignored at runtime. The default is <code>1</code>. You should keep concurrency limited to <code>1</code> in
  case of a topic listener or if queue ordering is important. Consider raising it for
  general queues.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>prefetch</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The maximum number of messages to load into a single session. Note that raising this
  number might lead to starvation of concurrent consumers.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>receive-timeout</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The timeout (in milliseconds) to use for receive calls. The default is <code>1000</code> (one
  second). <code>-1</code> indicates no timeout.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>back-off</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specifies the <code>BackOff</code> instance to use to compute the interval between recovery
  attempts. If the <code>BackOffExecution</code> implementation returns <code>BackOffExecution#STOP</code>,
  the listener container does not further try to recover. The <code>recovery-interval</code>
  value is ignored when this property is set. The default is a <code>FixedBackOff</code> with
  an interval of 5000 milliseconds (that is, five seconds).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>recovery-interval</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specifies the interval between recovery attempts, in milliseconds. It offers a convenient
  way to create a <code>FixedBackOff</code> with the specified interval. For more recovery
  options, consider specifying a <code>BackOff</code> instance instead. The default is 5000 milliseconds
  (that is, five seconds).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>phase</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The lifecycle phase within which this container should start and stop. The lower the
  value, the earlier this container starts and the later it stops. The default is
  <code>Integer.MAX_VALUE</code>, meaning that the container starts as late as possible and stops as
  soon as possible.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Configuring a JCA-based listener container with the <code>jms</code> schema support is very similar,
as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;jms:jca-listener-container resource-adapter="myResourceAdapter"
        destination-resolver="myDestinationResolver"
        transaction-manager="myTransactionManager"
        concurrency="10"&gt;

    &lt;jms:listener destination="queue.orders" ref="myMessageListener"/&gt;

&lt;/jms:jca-listener-container&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following table describes the available configuration options for the JCA variant:</p>
</div>
<table id="jms-namespace-jca-listener-container-tbl" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 5. Attributes of the JMS &lt;jca-listener-container/&gt; element</caption>
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 85.7143%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>factory-id</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Exposes the settings defined by this element as a <code>JmsListenerContainerFactory</code>
  with the specified <code>id</code> so that they can be reused with other endpoints.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>resource-adapter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A reference to the JCA <code>ResourceAdapter</code> bean (the default bean name is
  <code>resourceAdapter</code>).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>activation-spec-factory</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A reference to the <code>JmsActivationSpecFactory</code>. The default is to autodetect the JMS
  provider and its <code>ActivationSpec</code> class (see <a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/jms/listener/endpoint/DefaultJmsActivationSpecFactory.html"><code>DefaultJmsActivationSpecFactory</code></a>).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>destination-resolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A reference to the <code>DestinationResolver</code> strategy for resolving JMS <code>Destinations</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>message-converter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A reference to the <code>MessageConverter</code> strategy for converting JMS Messages to listener
  method arguments. The default is <code>SimpleMessageConverter</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>destination-type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The JMS destination type for this listener: <code>queue</code>, <code>topic</code>, <code>durableTopic</code>, <code>sharedTopic</code>.
  or <code>sharedDurableTopic</code>. This potentially enables the <code>pubSubDomain</code>, <code>subscriptionDurable</code>,
  and <code>subscriptionShared</code> properties of the container. The default is <code>queue</code> (which disables
  those three properties).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>response-destination-type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The JMS destination type for responses: <code>queue</code> or <code>topic</code>. The default is the value of the
  <code>destination-type</code> attribute.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>client-id</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The JMS client ID for this listener container. It needs to be specified when using
  durable subscriptions.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>acknowledge</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The native JMS acknowledge mode: <code>auto</code>, <code>client</code>, <code>dups-ok</code>, or <code>transacted</code>. A value
  of <code>transacted</code> activates a locally transacted <code>Session</code>. As an alternative, you can specify
  the <code>transaction-manager</code> attribute described later. The default is <code>auto</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>transaction-manager</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A reference to a Spring <code>JtaTransactionManager</code> or a
  <code>javax.transaction.TransactionManager</code> for kicking off an XA transaction for each
  incoming message. If not specified, native acknowledging is used (see the
  <code>acknowledge</code> attribute).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>concurrency</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The number of concurrent sessions or consumers to start for each listener. It can either be
  a simple number indicating the maximum number (for example <code>5</code>) or a range indicating the
  lower as well as the upper limit (for example, <code>3-5</code>). Note that a specified minimum is only a
  hint and is typically ignored at runtime when you use a JCA listener container.
  The default is 1.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>prefetch</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The maximum number of messages to load into a single session. Note that raising this
  number might lead to starvation of concurrent consumers.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jmx"><a class="anchor" href="#jmx"></a>5. JMX</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The JMX (Java Management Extensions) support in Spring provides features that let you
easily and transparently integrate your Spring application into a JMX infrastructure.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">JMX?</div>
<div class="paragraph">
<p>This chapter is not an introduction to JMX. It does not try to explain why you might want
to use JMX. If you are new to JMX, see <a href="#jmx-resources">Further Resources</a> at the end of this chapter.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Specifically, Spring&#8217;s JMX support provides four core features:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The automatic registration of any Spring bean as a JMX MBean.</p>
</li>
<li>
<p>A flexible mechanism for controlling the management interface of your beans.</p>
</li>
<li>
<p>The declarative exposure of MBeans over remote, JSR-160 connectors.</p>
</li>
<li>
<p>The simple proxying of both local and remote MBean resources.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These features are designed to work without coupling your application components to
either Spring or JMX interfaces and classes. Indeed, for the most part, your application
classes need not be aware of either Spring or JMX in order to take advantage of the
Spring JMX features.</p>
</div>
<div class="sect2">
<h3 id="jmx-exporting"><a class="anchor" href="#jmx-exporting"></a>5.1. Exporting Your Beans to JMX</h3>
<div class="paragraph">
<p>The core class in Spring&#8217;s JMX framework is the <code>MBeanExporter</code>. This class is
responsible for taking your Spring beans and registering them with a JMX <code>MBeanServer</code>.
For example, consider the following class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package org.springframework.jmx;

public class JmxTestBean implements IJmxTestBean {

    private String name;
    private int age;
    private boolean isSuperman;

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public int add(int x, int y) {
        return x + y;
    }

    public void dontExposeMe() {
        throw new RuntimeException();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To expose the properties and methods of this bean as attributes and operations of an
MBean, you can configure an instance of the <code>MBeanExporter</code> class in your
configuration file and pass in the bean, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;
    &lt;!-- this bean must not be lazily initialized if the exporting is to happen --&gt;
    &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter" lazy-init="false"&gt;
        &lt;property name="beans"&gt;
            &lt;map&gt;
                &lt;entry key="bean:name=testBean1" value-ref="testBean"/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
        &lt;property name="name" value="TEST"/&gt;
        &lt;property name="age" value="100"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The pertinent bean definition from the preceding configuration snippet is the <code>exporter</code>
bean. The <code>beans</code> property tells the <code>MBeanExporter</code> exactly which of your beans must be
exported to the JMX <code>MBeanServer</code>. In the default configuration, the key of each entry
in the <code>beans</code> <code>Map</code> is used as the <code>ObjectName</code> for the bean referenced by the
corresponding entry value. You can change this behavior, as described in <a href="#jmx-naming">Controlling  <code>ObjectName</code> Instances for Your Beans</a>.</p>
</div>
<div class="paragraph">
<p>With this configuration, the <code>testBean</code> bean is exposed as an MBean under the
<code>ObjectName</code> <code>bean:name=testBean1</code>. By default, all <code>public</code> properties of the bean
are exposed as attributes and all <code>public</code> methods (except those inherited from the
<code>Object</code> class) are exposed as operations.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>MBeanExporter</code> is a <code>Lifecycle</code> bean (see <a href="core.html#beans-factory-lifecycle-processor">Startup and Shutdown Callbacks</a>). By default, MBeans are exported as late as possible during
the application lifecycle. You can configure the <code>phase</code> at which
the export happens or disable automatic registration by setting the <code>autoStartup</code> flag.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="jmx-exporting-mbeanserver"><a class="anchor" href="#jmx-exporting-mbeanserver"></a>5.1.1. Creating an MBeanServer</h4>
<div class="paragraph">
<p>The configuration shown in the <a href="#jmx-exporting">preceding section</a> assumes that the
application is running in an environment that has one (and only one) <code>MBeanServer</code>
already running. In this case, Spring tries to locate the running <code>MBeanServer</code> and
register your beans with that server (if any). This behavior is useful when your
application runs inside a container (such as Tomcat or IBM WebSphere) that has its
own <code>MBeanServer</code>.</p>
</div>
<div class="paragraph">
<p>However, this approach is of no use in a standalone environment or when running inside
a container that does not provide an <code>MBeanServer</code>. To address this, you can create an
<code>MBeanServer</code> instance declaratively by adding an instance of the
<code>org.springframework.jmx.support.MBeanServerFactoryBean</code> class to your configuration.
You can also ensure that a specific <code>MBeanServer</code> is used by setting the value of the
<code>MBeanExporter</code> instance&#8217;s <code>server</code> property to the <code>MBeanServer</code> value returned by an
<code>MBeanServerFactoryBean</code>, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;

    &lt;bean id="mbeanServer" class="org.springframework.jmx.support.MBeanServerFactoryBean"/&gt;

    &lt;!--
    this bean needs to be eagerly pre-instantiated in order for the exporting to occur;
    this means that it must not be marked as lazily initialized
    --&gt;
    &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
        &lt;property name="beans"&gt;
            &lt;map&gt;
                &lt;entry key="bean:name=testBean1" value-ref="testBean"/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;property name="server" ref="mbeanServer"/&gt;
    &lt;/bean&gt;

    &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
        &lt;property name="name" value="TEST"/&gt;
        &lt;property name="age" value="100"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, an instance of <code>MBeanServer</code> is created by the <code>MBeanServerFactoryBean</code> and is
supplied to the <code>MBeanExporter</code> through the <code>server</code> property. When you supply your own
<code>MBeanServer</code> instance, the <code>MBeanExporter</code> does not try to locate a running
<code>MBeanServer</code> and uses the supplied <code>MBeanServer</code> instance. For this to work
correctly, you must have a JMX implementation on your classpath.</p>
</div>
</div>
<div class="sect3">
<h4 id="jmx-mbean-server"><a class="anchor" href="#jmx-mbean-server"></a>5.1.2. Reusing an Existing <code>MBeanServer</code></h4>
<div class="paragraph">
<p>If no server is specified, the <code>MBeanExporter</code> tries to automatically detect a running
<code>MBeanServer</code>. This works in most environments, where only one <code>MBeanServer</code> instance is
used. However, when multiple instances exist, the exporter might pick the wrong server.
In such cases, you should use the <code>MBeanServer</code> <code>agentId</code> to indicate which instance to
be used, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;
    &lt;bean id="mbeanServer" class="org.springframework.jmx.support.MBeanServerFactoryBean"&gt;
        &lt;!-- indicate to first look for a server --&gt;
        &lt;property name="locateExistingServerIfPossible" value="true"/&gt;
        &lt;!-- search for the MBeanServer instance with the given agentId --&gt;
        &lt;property name="agentId" value="MBeanServer_instance_agentId&gt;"/&gt;
    &lt;/bean&gt;
    &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
        &lt;property name="server" ref="mbeanServer"/&gt;
        ...
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>For platforms or cases where the existing <code>MBeanServer</code> has a dynamic (or unknown)
<code>agentId</code> that is retrieved through lookup methods, you should use
<a href="core.html#beans-factory-class-static-factory-method">factory-method</a>,
as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;
    &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
        &lt;property name="server"&gt;
            &lt;!-- Custom MBeanServerLocator --&gt;
            &lt;bean class="platform.package.MBeanServerLocator" factory-method="locateMBeanServer"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;!-- other beans here --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jmx-exporting-lazy"><a class="anchor" href="#jmx-exporting-lazy"></a>5.1.3. Lazily Initialized MBeans</h4>
<div class="paragraph">
<p>If you configure a bean with an <code>MBeanExporter</code> that is also configured for lazy
initialization, the <code>MBeanExporter</code> does not break this contract and avoids
instantiating the bean. Instead, it registers a proxy with the <code>MBeanServer</code> and
defers obtaining the bean from the container until the first invocation on the proxy
occurs.</p>
</div>
</div>
<div class="sect3">
<h4 id="jmx-exporting-auto"><a class="anchor" href="#jmx-exporting-auto"></a>5.1.4. Automatic Registration of MBeans</h4>
<div class="paragraph">
<p>Any beans that are exported through the <code>MBeanExporter</code> and are already valid MBeans are
registered as-is with the <code>MBeanServer</code> without further intervention from Spring. You can cause MBeans
to be automatically detected by the <code>MBeanExporter</code> by setting the <code>autodetect</code>
property to <code>true</code>, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
    &lt;property name="autodetect" value="true"/&gt;
&lt;/bean&gt;

&lt;bean name="spring:mbean=true" class="org.springframework.jmx.export.TestDynamicMBean"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the bean called <code>spring:mbean=true</code> is already a valid JMX MBean
and is automatically registered by Spring. By default, a bean that is autodetected for JMX
registration has its bean name used as the <code>ObjectName</code>. You can override this behavior,
as detailed in <a href="#jmx-naming">Controlling  <code>ObjectName</code> Instances for Your Beans</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="jmx-exporting-registration-behavior"><a class="anchor" href="#jmx-exporting-registration-behavior"></a>5.1.5. Controlling the Registration Behavior</h4>
<div class="paragraph">
<p>Consider the scenario where a Spring <code>MBeanExporter</code> attempts to register an <code>MBean</code>
with an <code>MBeanServer</code> by using the <code>ObjectName</code> <code>bean:name=testBean1</code>. If an <code>MBean</code>
instance has already been registered under that same <code>ObjectName</code>, the default behavior
is to fail (and throw an <code>InstanceAlreadyExistsException</code>).</p>
</div>
<div class="paragraph">
<p>You can control exactly what happens when an <code>MBean</code> is
registered with an <code>MBeanServer</code>. Spring&#8217;s JMX support allows for three different
registration behaviors to control the registration behavior when the registration
process finds that an <code>MBean</code> has already been registered under the same <code>ObjectName</code>.
The following table summarizes these registration behaviors:</p>
</div>
<table id="jmx-registration-behaviors" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 6. Registration Behaviors</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 80%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Registration behavior</th>
<th class="tableblock halign-left valign-top">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FAIL_ON_EXISTING</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This is the default registration behavior. If an <code>MBean</code> instance has already been
  registered under the same <code>ObjectName</code>, the <code>MBean</code> that is being registered is not
  registered, and an <code>InstanceAlreadyExistsException</code> is thrown. The existing
  <code>MBean</code> is unaffected.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IGNORE_EXISTING</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If an <code>MBean</code> instance has already been registered under the same <code>ObjectName</code>, the
  <code>MBean</code> that is being registered is not registered. The existing <code>MBean</code> is
  unaffected, and no <code>Exception</code> is thrown. This is useful in settings where
  multiple applications want to share a common <code>MBean</code> in a shared <code>MBeanServer</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>REPLACE_EXISTING</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If an <code>MBean</code> instance has already been registered under the same <code>ObjectName</code>, the
  existing <code>MBean</code> that was previously registered is unregistered, and the new
  <code>MBean</code> is registered in its place (the new <code>MBean</code> effectively replaces the
  previous instance).</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The values in the preceding table are defined as enums on the <code>RegistrationPolicy</code> class.
If you want to change the default registration behavior, you need to set the value of the
<code>registrationPolicy</code> property on your <code>MBeanExporter</code> definition to one of those
values.</p>
</div>
<div class="paragraph">
<p>The following example shows how to change from the default registration
behavior to the <code>REPLACE_EXISTING</code> behavior:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;

    &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
        &lt;property name="beans"&gt;
            &lt;map&gt;
                &lt;entry key="bean:name=testBean1" value-ref="testBean"/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;property name="registrationPolicy" value="REPLACE_EXISTING"/&gt;
    &lt;/bean&gt;

    &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
        &lt;property name="name" value="TEST"/&gt;
        &lt;property name="age" value="100"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jmx-interface"><a class="anchor" href="#jmx-interface"></a>5.2. Controlling the Management Interface of Your Beans</h3>
<div class="paragraph">
<p>In the example in the <a href="#jmx-exporting-registration-behavior">preceding section</a>,
you had little control over the management interface of your bean. All of the <code>public</code>
properties and methods of each exported bean were exposed as JMX attributes and
operations, respectively. To exercise finer-grained control over exactly which
properties and methods of your exported beans are actually exposed as JMX attributes
and operations, Spring JMX provides a comprehensive and extensible mechanism for
controlling the management interfaces of your beans.</p>
</div>
<div class="sect3">
<h4 id="jmx-interface-assembler"><a class="anchor" href="#jmx-interface-assembler"></a>5.2.1. Using the <code>MBeanInfoAssembler</code> Interface</h4>
<div class="paragraph">
<p>Behind the scenes, the <code>MBeanExporter</code> delegates to an implementation of the
<code>org.springframework.jmx.export.assembler.MBeanInfoAssembler</code> interface, which is
responsible for defining the management interface of each bean that is exposed.
The default implementation,
<code>org.springframework.jmx.export.assembler.SimpleReflectiveMBeanInfoAssembler</code>,
defines a management interface that exposes all public properties and methods
(as you saw in the examples in the preceding sections). Spring provides two
additional implementations of the <code>MBeanInfoAssembler</code> interface that let you
control the generated management interface by using either source-level metadata
or any arbitrary interface.</p>
</div>
</div>
<div class="sect3">
<h4 id="jmx-interface-metadata"><a class="anchor" href="#jmx-interface-metadata"></a>5.2.2. Using Source-level Metadata: Java Annotations</h4>
<div class="paragraph">
<p>By using the <code>MetadataMBeanInfoAssembler</code>, you can define the management interfaces
for your beans by using source-level metadata. The reading of metadata is encapsulated
by the <code>org.springframework.jmx.export.metadata.JmxAttributeSource</code> interface.
Spring JMX provides a default implementation that uses Java annotations, namely
<code>org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource</code>.
You must configure the <code>MetadataMBeanInfoAssembler</code> with an implementation instance of
the <code>JmxAttributeSource</code> interface for it to function correctly (there is no default).</p>
</div>
<div class="paragraph">
<p>To mark a bean for export to JMX, you should annotate the bean class with the
<code>ManagedResource</code> annotation. You must mark each method you wish to expose as an operation
with the <code>ManagedOperation</code> annotation and mark each property you wish to expose
with the <code>ManagedAttribute</code> annotation. When marking properties, you can omit
either the annotation of the getter or the setter to create a write-only or read-only
attribute, respectively.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A <code>ManagedResource</code>-annotated bean must be public, as must the methods exposing
an operation or an attribute.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows the annotated version of the <code>JmxTestBean</code> class that we
used in <a href="#jmx-exporting-mbeanserver">Creating an MBeanServer</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package org.springframework.jmx;

import org.springframework.jmx.export.annotation.ManagedResource;
import org.springframework.jmx.export.annotation.ManagedOperation;
import org.springframework.jmx.export.annotation.ManagedAttribute;

@ManagedResource(
        objectName="bean:name=testBean4",
        description="My Managed Bean",
        log=true,
        logFile="jmx.log",
        currencyTimeLimit=15,
        persistPolicy="OnUpdate",
        persistPeriod=200,
        persistLocation="foo",
        persistName="bar")
public class AnnotationTestBean implements IJmxTestBean {

    private String name;
    private int age;

    @ManagedAttribute(description="The Age Attribute", currencyTimeLimit=15)
    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @ManagedAttribute(description="The Name Attribute",
            currencyTimeLimit=20,
            defaultValue="bar",
            persistPolicy="OnUpdate")
    public void setName(String name) {
        this.name = name;
    }

    @ManagedAttribute(defaultValue="foo", persistPeriod=300)
    public String getName() {
        return name;
    }

    @ManagedOperation(description="Add two numbers")
    @ManagedOperationParameters({
        @ManagedOperationParameter(name = "x", description = "The first number"),
        @ManagedOperationParameter(name = "y", description = "The second number")})
    public int add(int x, int y) {
        return x + y;
    }

    public void dontExposeMe() {
        throw new RuntimeException();
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, you can see that the <code>JmxTestBean</code> class is marked with the
<code>ManagedResource</code> annotation and that this <code>ManagedResource</code> annotation is configured
with a set of properties. These properties can be used to configure various aspects
of the MBean that is generated by the <code>MBeanExporter</code> and are explained in greater
detail later in <a href="#jmx-interface-metadata-types">Source-level Metadata Types</a>.</p>
</div>
<div class="paragraph">
<p>Both the <code>age</code> and <code>name</code> properties are annotated with the <code>ManagedAttribute</code>
annotation, but, in the case of the <code>age</code> property, only the getter is marked.
This causes both of these properties to be included in the management interface
as attributes, but the <code>age</code> attribute is read-only.</p>
</div>
<div class="paragraph">
<p>Finally, the <code>add(int, int)</code> method is marked with the <code>ManagedOperation</code> attribute,
whereas the <code>dontExposeMe()</code> method is not. This causes the management interface to
contain only one operation (<code>add(int, int)</code>) when you use the <code>MetadataMBeanInfoAssembler</code>.</p>
</div>
<div class="paragraph">
<p>The following configuration shows how you can configure the <code>MBeanExporter</code> to use the
<code>MetadataMBeanInfoAssembler</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;
    &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
        &lt;property name="assembler" ref="assembler"/&gt;
        &lt;property name="namingStrategy" ref="namingStrategy"/&gt;
        &lt;property name="autodetect" value="true"/&gt;
    &lt;/bean&gt;

    &lt;bean id="jmxAttributeSource"
            class="org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource"/&gt;

    &lt;!-- will create management interface using annotation metadata --&gt;
    &lt;bean id="assembler"
            class="org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler"&gt;
        &lt;property name="attributeSource" ref="jmxAttributeSource"/&gt;
    &lt;/bean&gt;

    &lt;!-- will pick up the ObjectName from the annotation --&gt;
    &lt;bean id="namingStrategy"
            class="org.springframework.jmx.export.naming.MetadataNamingStrategy"&gt;
        &lt;property name="attributeSource" ref="jmxAttributeSource"/&gt;
    &lt;/bean&gt;

    &lt;bean id="testBean" class="org.springframework.jmx.AnnotationTestBean"&gt;
        &lt;property name="name" value="TEST"/&gt;
        &lt;property name="age" value="100"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, an <code>MetadataMBeanInfoAssembler</code> bean has been configured with an
instance of the <code>AnnotationJmxAttributeSource</code> class and passed to the <code>MBeanExporter</code>
through the assembler property. This is all that is required to take advantage of
metadata-driven management interfaces for your Spring-exposed MBeans.</p>
</div>
</div>
<div class="sect3">
<h4 id="jmx-interface-metadata-types"><a class="anchor" href="#jmx-interface-metadata-types"></a>5.2.3. Source-level Metadata Types</h4>
<div class="paragraph">
<p>The following table describes the source-level metadata types that are available for use in Spring JMX:</p>
</div>
<table id="jmx-metadata-types" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 7. Source-level metadata types</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Purpose</th>
<th class="tableblock halign-left valign-top">Annotation</th>
<th class="tableblock halign-left valign-top">Annotation Type</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mark all instances of a <code>Class</code> as JMX managed resources.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ManagedResource</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Class</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mark a method as a JMX operation.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ManagedOperation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Method</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mark a getter or setter as one half of a JMX attribute.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ManagedAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Method (only getters and setters)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Define descriptions for operation parameters.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ManagedOperationParameter</code> and <code>@ManagedOperationParameters</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Method</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The following table describes the configuration parameters that are available for use on these source-level
metadata types:</p>
</div>
<table id="jmx-metadata-parameters" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 8. Source-level metadata parameters</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 60%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Parameter</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Applies to</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ObjectName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Used by <code>MetadataNamingStrategy</code> to determine the <code>ObjectName</code> of a managed resource.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ManagedResource</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>description</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sets the friendly description of the resource, attribute or operation.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ManagedResource</code>, <code>ManagedAttribute</code>, <code>ManagedOperation</code>, or <code>ManagedOperationParameter</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>currencyTimeLimit</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sets the value of the <code>currencyTimeLimit</code> descriptor field.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ManagedResource</code> or <code>ManagedAttribute</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>defaultValue</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sets the value of the <code>defaultValue</code> descriptor field.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ManagedAttribute</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>log</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sets the value of the <code>log</code> descriptor field.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ManagedResource</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logFile</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sets the value of the <code>logFile</code> descriptor field.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ManagedResource</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>persistPolicy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sets the value of the <code>persistPolicy</code> descriptor field.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ManagedResource</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>persistPeriod</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sets the value of the <code>persistPeriod</code> descriptor field.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ManagedResource</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>persistLocation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sets the value of the <code>persistLocation</code> descriptor field.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ManagedResource</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>persistName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sets the value of the <code>persistName</code> descriptor field.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ManagedResource</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sets the display name of an operation parameter.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ManagedOperationParameter</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>index</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sets the index of an operation parameter.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ManagedOperationParameter</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="jmx-interface-autodetect"><a class="anchor" href="#jmx-interface-autodetect"></a>5.2.4. Using the <code>AutodetectCapableMBeanInfoAssembler</code> Interface</h4>
<div class="paragraph">
<p>To simplify configuration even further, Spring includes the
<code>AutodetectCapableMBeanInfoAssembler</code> interface, which extends the <code>MBeanInfoAssembler</code>
interface to add support for autodetection of MBean resources. If you configure the
<code>MBeanExporter</code> with an instance of <code>AutodetectCapableMBeanInfoAssembler</code>, it is
allowed to &#8220;vote&#8221; on the inclusion of beans for exposure to JMX.</p>
</div>
<div class="paragraph">
<p>The only implementation of the <code>AutodetectCapableMBeanInfo</code> interface is
the <code>MetadataMBeanInfoAssembler</code>, which votes to include any bean that is marked
with the <code>ManagedResource</code> attribute. The default approach in this case is to use the
bean name as the <code>ObjectName</code>, which results in a configuration similar to the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;

    &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
        &lt;!-- notice how no 'beans' are explicitly configured here --&gt;
        &lt;property name="autodetect" value="true"/&gt;
        &lt;property name="assembler" ref="assembler"/&gt;
    &lt;/bean&gt;

    &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
        &lt;property name="name" value="TEST"/&gt;
        &lt;property name="age" value="100"/&gt;
    &lt;/bean&gt;

    &lt;bean id="assembler" class="org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler"&gt;
        &lt;property name="attributeSource"&gt;
            &lt;bean class="org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that, in the preceding configuration, no beans are passed to the <code>MBeanExporter</code>.
However, the <code>JmxTestBean</code> is still registered, since it is marked with the <code>ManagedResource</code>
attribute and the <code>MetadataMBeanInfoAssembler</code> detects this and votes to include it.
The only problem with this approach is that the name of the <code>JmxTestBean</code> now has business
meaning. You can address this issue by changing the default behavior for <code>ObjectName</code>
creation as defined in <a href="#jmx-naming">Controlling  <code>ObjectName</code> Instances for Your Beans</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="jmx-interface-java"><a class="anchor" href="#jmx-interface-java"></a>5.2.5. Defining Management Interfaces by Using Java Interfaces</h4>
<div class="paragraph">
<p>In addition to the <code>MetadataMBeanInfoAssembler</code>, Spring also includes the
<code>InterfaceBasedMBeanInfoAssembler</code>, which lets you constrain the methods and
properties that are exposed based on the set of methods defined in a collection of
interfaces.</p>
</div>
<div class="paragraph">
<p>Although the standard mechanism for exposing MBeans is to use interfaces and a simple
naming scheme, <code>InterfaceBasedMBeanInfoAssembler</code> extends this functionality by
removing the need for naming conventions, letting you use more than one interface
and removing the need for your beans to implement the MBean interfaces.</p>
</div>
<div class="paragraph">
<p>Consider the following interface, which is used to define a management interface for the
<code>JmxTestBean</code> class that we showed earlier:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface IJmxTestBean {

    public int add(int x, int y);

    public long myOperation();

    public int getAge();

    public void setAge(int age);

    public void setName(String name);

    public String getName();

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This interface defines the methods and properties that are exposed as operations and
attributes on the JMX MBean. The following code shows how to configure Spring JMX to use
this interface as the definition for the management interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;

    &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
        &lt;property name="beans"&gt;
            &lt;map&gt;
                &lt;entry key="bean:name=testBean5" value-ref="testBean"/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;property name="assembler"&gt;
            &lt;bean class="org.springframework.jmx.export.assembler.InterfaceBasedMBeanInfoAssembler"&gt;
                &lt;property name="managedInterfaces"&gt;
                    &lt;value&gt;org.springframework.jmx.IJmxTestBean&lt;/value&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
        &lt;property name="name" value="TEST"/&gt;
        &lt;property name="age" value="100"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the <code>InterfaceBasedMBeanInfoAssembler</code> is configured to use the
<code>IJmxTestBean</code> interface when constructing the management interface for any bean. It is
important to understand that beans processed by the <code>InterfaceBasedMBeanInfoAssembler</code>
are not required to implement the interface used to generate the JMX management
interface.</p>
</div>
<div class="paragraph">
<p>In the preceding case, the <code>IJmxTestBean</code> interface is used to construct all management
interfaces for all beans. In many cases, this is not the desired behavior, and you may
want to use different interfaces for different beans. In this case, you can pass
<code>InterfaceBasedMBeanInfoAssembler</code> a <code>Properties</code> instance through the <code>interfaceMappings</code>
property, where the key of each entry is the bean name and the value of each entry is a
comma-separated list of interface names to use for that bean.</p>
</div>
<div class="paragraph">
<p>If no management interface is specified through either the <code>managedInterfaces</code> or
<code>interfaceMappings</code> properties, the <code>InterfaceBasedMBeanInfoAssembler</code> reflects
on the bean and uses all of the interfaces implemented by that bean to create the
management interface.</p>
</div>
</div>
<div class="sect3">
<h4 id="jmx-interface-methodnames"><a class="anchor" href="#jmx-interface-methodnames"></a>5.2.6. Using <code>MethodNameBasedMBeanInfoAssembler</code></h4>
<div class="paragraph">
<p><code>MethodNameBasedMBeanInfoAssembler</code> lets you specify a list of method names
that are exposed to JMX as attributes and operations. The following code shows a sample
configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
    &lt;property name="beans"&gt;
        &lt;map&gt;
            &lt;entry key="bean:name=testBean5" value-ref="testBean"/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
    &lt;property name="assembler"&gt;
        &lt;bean class="org.springframework.jmx.export.assembler.MethodNameBasedMBeanInfoAssembler"&gt;
            &lt;property name="managedMethods"&gt;
                &lt;value&gt;add,myOperation,getName,setName,getAge&lt;/value&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, you can see that the <code>add</code> and <code>myOperation</code> methods are exposed as JMX
operations, and <code>getName()</code>, <code>setName(String)</code>, and <code>getAge()</code> are exposed as the
appropriate half of a JMX attribute. In the preceding code, the method mappings apply to
beans that are exposed to JMX. To control method exposure on a bean-by-bean basis, you can use
the <code>methodMappings</code> property of <code>MethodNameMBeanInfoAssembler</code> to map bean names to
lists of method names.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jmx-naming"><a class="anchor" href="#jmx-naming"></a>5.3. Controlling  <code>ObjectName</code> Instances for Your Beans</h3>
<div class="paragraph">
<p>Behind the scenes, the <code>MBeanExporter</code> delegates to an implementation of the
<code>ObjectNamingStrategy</code> to obtain an <code>ObjectName</code> instance for each of the beans it registers.
By default, the default implementation, <code>KeyNamingStrategy</code> uses the key of the
<code>beans</code> <code>Map</code> as the <code>ObjectName</code>. In addition, the <code>KeyNamingStrategy</code> can map the key
of the <code>beans</code> <code>Map</code> to an entry in a <code>Properties</code> file (or files) to resolve the
<code>ObjectName</code>. In addition to the <code>KeyNamingStrategy</code>, Spring provides two additional
<code>ObjectNamingStrategy</code> implementations: the <code>IdentityNamingStrategy</code> (which builds an
<code>ObjectName</code> based on the JVM identity of the bean) and the <code>MetadataNamingStrategy</code> (which
uses source-level metadata to obtain the <code>ObjectName</code>).</p>
</div>
<div class="sect3">
<h4 id="jmx-naming-properties"><a class="anchor" href="#jmx-naming-properties"></a>5.3.1. Reading <code>ObjectName</code> Instances from Properties</h4>
<div class="paragraph">
<p>You can configure your own <code>KeyNamingStrategy</code> instance and configure it to read
<code>ObjectName</code> instances from a <code>Properties</code> instance rather than use a bean key. The
<code>KeyNamingStrategy</code> tries to locate an entry in the <code>Properties</code> with a key
that corresponds to the bean key. If no entry is found or if the <code>Properties</code> instance is
<code>null</code>, the bean key itself is used.</p>
</div>
<div class="paragraph">
<p>The following code shows a sample configuration for the <code>KeyNamingStrategy</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;

    &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
        &lt;property name="beans"&gt;
            &lt;map&gt;
                &lt;entry key="testBean" value-ref="testBean"/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;property name="namingStrategy" ref="namingStrategy"/&gt;
    &lt;/bean&gt;

    &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
        &lt;property name="name" value="TEST"/&gt;
        &lt;property name="age" value="100"/&gt;
    &lt;/bean&gt;

    &lt;bean id="namingStrategy" class="org.springframework.jmx.export.naming.KeyNamingStrategy"&gt;
        &lt;property name="mappings"&gt;
            &lt;props&gt;
                &lt;prop key="testBean"&gt;bean:name=testBean1&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
        &lt;property name="mappingLocations"&gt;
            &lt;value&gt;names1.properties,names2.properties&lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding example configures an instance of <code>KeyNamingStrategy</code> with a <code>Properties</code> instance that
is merged from the <code>Properties</code> instance defined by the mapping property and the
properties files located in the paths defined by the mappings property. In this
configuration, the <code>testBean</code> bean is given an <code>ObjectName</code> of <code>bean:name=testBean1</code>,
since this is the entry in the <code>Properties</code> instance that has a key corresponding to the
bean key.</p>
</div>
<div class="paragraph">
<p>If no entry in the <code>Properties</code> instance can be found, the bean key name is used as
the <code>ObjectName</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="jmx-naming-metadata"><a class="anchor" href="#jmx-naming-metadata"></a>5.3.2. Using <code>MetadataNamingStrategy</code></h4>
<div class="paragraph">
<p><code>MetadataNamingStrategy</code> uses the <code>objectName</code> property of the <code>ManagedResource</code>
attribute on each bean to create the <code>ObjectName</code>. The following code shows the
configuration for the <code>MetadataNamingStrategy</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;

    &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
        &lt;property name="beans"&gt;
            &lt;map&gt;
                &lt;entry key="testBean" value-ref="testBean"/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;property name="namingStrategy" ref="namingStrategy"/&gt;
    &lt;/bean&gt;

    &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
        &lt;property name="name" value="TEST"/&gt;
        &lt;property name="age" value="100"/&gt;
    &lt;/bean&gt;

    &lt;bean id="namingStrategy" class="org.springframework.jmx.export.naming.MetadataNamingStrategy"&gt;
        &lt;property name="attributeSource" ref="attributeSource"/&gt;
    &lt;/bean&gt;

    &lt;bean id="attributeSource"
            class="org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If no <code>objectName</code> has been provided for the <code>ManagedResource</code> attribute, an
<code>ObjectName</code> is created with the following
format: <em>[fully-qualified-package-name]:type=[short-classname],name=[bean-name]</em>. For
example, the generated <code>ObjectName</code> for the following bean would be
<code>com.example:type=MyClass,name=myBean</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="myBean" class="com.example.MyClass"/&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jmx-context-mbeanexport"><a class="anchor" href="#jmx-context-mbeanexport"></a>5.3.3. Configuring Annotation-based MBean Export</h4>
<div class="paragraph">
<p>If you prefer to use <a href="#jmx-interface-metadata">the annotation-based approach</a> to define
your management interfaces, a convenience subclass of <code>MBeanExporter</code> is available:
<code>AnnotationMBeanExporter</code>. When defining an instance of this subclass, you no longer need the
<code>namingStrategy</code>, <code>assembler</code>, and <code>attributeSource</code> configuration,
since it always uses standard Java annotation-based metadata (autodetection is
always enabled as well). In fact, rather than defining an <code>MBeanExporter</code> bean, an even
simpler syntax is supported by the <code>@EnableMBeanExport</code> <code>@Configuration</code> annotation,
as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
@EnableMBeanExport
public class AppConfig {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you prefer XML-based configuration, the <code>&lt;context:mbean-export/&gt;</code> element serves the
same purpose and is shown in the following listing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;context:mbean-export/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If necessary, you can provide a reference to a particular MBean <code>server</code>, and the
<code>defaultDomain</code> attribute (a property of <code>AnnotationMBeanExporter</code>) accepts an alternate
value for the generated MBean <code>ObjectName</code> domains. This is used in place of the
fully qualified package name as described in the previous section on
<a href="#jmx-naming-metadata">MetadataNamingStrategy</a>, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@EnableMBeanExport(server="myMBeanServer", defaultDomain="myDomain")
@Configuration
ContextConfiguration {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows the XML equivalent of the preceding annotation-based example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;context:mbean-export server="myMBeanServer" default-domain="myDomain"/&gt;</code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Do not use interface-based AOP proxies in combination with autodetection of JMX
annotations in your bean classes. Interface-based proxies &#8220;hide&#8221; the target class, which
also hides the JMX-managed resource annotations. Hence, you should use target-class proxies in that
case (through setting the 'proxy-target-class' flag on <code>&lt;aop:config/&gt;</code>,
<code>&lt;tx:annotation-driven/&gt;</code> and so on). Otherwise, your JMX beans might be silently ignored at
startup.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jmx-jsr160"><a class="anchor" href="#jmx-jsr160"></a>5.4. Using JSR-160 Connectors</h3>
<div class="paragraph">
<p>For remote access, Spring JMX module offers two <code>FactoryBean</code> implementations inside the
<code>org.springframework.jmx.support</code> package for creating both server- and client-side
connectors.</p>
</div>
<div class="sect3">
<h4 id="jmx-jsr160-server"><a class="anchor" href="#jmx-jsr160-server"></a>5.4.1. Server-side Connectors</h4>
<div class="paragraph">
<p>To have Spring JMX create, start, and expose a JSR-160 <code>JMXConnectorServer</code>, you can use the
following configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="serverConnector" class="org.springframework.jmx.support.ConnectorServerFactoryBean"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default, <code>ConnectorServerFactoryBean</code> creates a <code>JMXConnectorServer</code> bound to
<code>service:jmx:jmxmp://localhost:9875</code>. The <code>serverConnector</code> bean thus exposes the
local <code>MBeanServer</code> to clients through the JMXMP protocol on localhost, port 9875. Note
that the JMXMP protocol is marked as optional by the JSR 160 specification. Currently,
the main open-source JMX implementation, MX4J, and the one provided with the JDK
do not support JMXMP.</p>
</div>
<div class="paragraph">
<p>To specify another URL and register the <code>JMXConnectorServer</code> itself with the
<code>MBeanServer</code>, you can use the <code>serviceUrl</code> and <code>ObjectName</code> properties, respectively,
as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="serverConnector"
        class="org.springframework.jmx.support.ConnectorServerFactoryBean"&gt;
    &lt;property name="objectName" value="connector:name=rmi"/&gt;
    &lt;property name="serviceUrl"
            value="service:jmx:rmi://localhost/jndi/rmi://localhost:1099/myconnector"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the <code>ObjectName</code> property is set, Spring automatically registers your connector
with the <code>MBeanServer</code> under that <code>ObjectName</code>. The following example shows the full set of
parameters that you can pass to the <code>ConnectorServerFactoryBean</code> when creating a
<code>JMXConnector</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="serverConnector"
        class="org.springframework.jmx.support.ConnectorServerFactoryBean"&gt;
    &lt;property name="objectName" value="connector:name=iiop"/&gt;
    &lt;property name="serviceUrl"
        value="service:jmx:iiop://localhost/jndi/iiop://localhost:900/myconnector"/&gt;
    &lt;property name="threaded" value="true"/&gt;
    &lt;property name="daemon" value="true"/&gt;
    &lt;property name="environment"&gt;
        &lt;map&gt;
            &lt;entry key="someKey" value="someValue"/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that, when you use a RMI-based connector, you need the lookup service (<code>tnameserv</code> or
<code>rmiregistry</code>) to be started in order for the name registration to complete. If you
use Spring to export remote services for you through RMI, Spring has already
constructed an RMI registry. If not, you can easily start a registry by using the following
snippet of configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="registry" class="org.springframework.remoting.rmi.RmiRegistryFactoryBean"&gt;
    &lt;property name="port" value="1099"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jmx-jsr160-client"><a class="anchor" href="#jmx-jsr160-client"></a>5.4.2. Client-side Connectors</h4>
<div class="paragraph">
<p>To create an <code>MBeanServerConnection</code> to a remote JSR-160-enabled <code>MBeanServer</code>, you can use the
<code>MBeanServerConnectionFactoryBean</code>, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="clientConnector" class="org.springframework.jmx.support.MBeanServerConnectionFactoryBean"&gt;
    &lt;property name="serviceUrl" value="service:jmx:rmi://localhost/jndi/rmi://localhost:1099/jmxrmi"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jmx-jsr160-protocols"><a class="anchor" href="#jmx-jsr160-protocols"></a>5.4.3. JMX over Hessian or SOAP</h4>
<div class="paragraph">
<p>JSR-160 permits extensions to the way in which communication is done between the client
and the server. The examples shown in the preceding sections use the mandatory RMI-based implementation
required by the JSR-160 specification (IIOP and JRMP) and the (optional) JMXMP. By using
other providers or JMX implementations (such as <a href="http://mx4j.sourceforge.net">MX4J</a>) you
can take advantage of protocols such as SOAP or Hessian over simple HTTP or SSL and others,
as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="serverConnector" class="org.springframework.jmx.support.ConnectorServerFactoryBean"&gt;
    &lt;property name="objectName" value="connector:name=burlap"/&gt;
    &lt;property name="serviceUrl" value="service:jmx:burlap://localhost:9874"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, we used MX4J 3.0.0. See the official MX4J
documentation for more information.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jmx-proxy"><a class="anchor" href="#jmx-proxy"></a>5.5. Accessing MBeans through Proxies</h3>
<div class="paragraph">
<p>Spring JMX lets you create proxies that re-route calls to MBeans that are registered in a
local or remote <code>MBeanServer</code>. These proxies provide you with a standard Java interface,
through which you can interact with your MBeans. The following code shows how to configure a
proxy for an MBean running in a local <code>MBeanServer</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="proxy" class="org.springframework.jmx.access.MBeanProxyFactoryBean"&gt;
    &lt;property name="objectName" value="bean:name=testBean"/&gt;
    &lt;property name="proxyInterface" value="org.springframework.jmx.IJmxTestBean"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, you can see that a proxy is created for the MBean registered under the
<code>ObjectName</code> of <code>bean:name=testBean</code>. The set of interfaces that the proxy implements
is controlled by the <code>proxyInterfaces</code> property, and the rules for mapping methods and
properties on these interfaces to operations and attributes on the MBean are the same
rules used by the <code>InterfaceBasedMBeanInfoAssembler</code>.</p>
</div>
<div class="paragraph">
<p>The <code>MBeanProxyFactoryBean</code> can create a proxy to any MBean that is accessible through an
<code>MBeanServerConnection</code>. By default, the local <code>MBeanServer</code> is located and used, but
you can override this and provide an <code>MBeanServerConnection</code> that points to a remote
<code>MBeanServer</code> to cater for proxies that point to remote MBeans:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="clientConnector"
        class="org.springframework.jmx.support.MBeanServerConnectionFactoryBean"&gt;
    &lt;property name="serviceUrl" value="service:jmx:rmi://remotehost:9875"/&gt;
&lt;/bean&gt;

&lt;bean id="proxy" class="org.springframework.jmx.access.MBeanProxyFactoryBean"&gt;
    &lt;property name="objectName" value="bean:name=testBean"/&gt;
    &lt;property name="proxyInterface" value="org.springframework.jmx.IJmxTestBean"/&gt;
    &lt;property name="server" ref="clientConnector"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, we create an <code>MBeanServerConnection</code> that points to a remote machine
that uses the <code>MBeanServerConnectionFactoryBean</code>. This <code>MBeanServerConnection</code> is then
passed to the <code>MBeanProxyFactoryBean</code> through the <code>server</code> property. The proxy that is
created forwards all invocations to the <code>MBeanServer</code> through this
<code>MBeanServerConnection</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="jmx-notifications"><a class="anchor" href="#jmx-notifications"></a>5.6. Notifications</h3>
<div class="paragraph">
<p>Spring&#8217;s JMX offering includes comprehensive support for JMX notifications.</p>
</div>
<div class="sect3">
<h4 id="jmx-notifications-listeners"><a class="anchor" href="#jmx-notifications-listeners"></a>5.6.1. Registering Listeners for Notifications</h4>
<div class="paragraph">
<p>Spring&#8217;s JMX support makes it easy to register any number of
<code>NotificationListeners</code> with any number of MBeans (this includes MBeans exported by
Spring&#8217;s <code>MBeanExporter</code> and MBeans registered through some other mechanism). For
example, consider the scenario where one would like to be informed (through a
<code>Notification</code>) each and every time an attribute of a target MBean changes. The following
example writes notifications to the console:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package com.example;

import javax.management.AttributeChangeNotification;
import javax.management.Notification;
import javax.management.NotificationFilter;
import javax.management.NotificationListener;

public class ConsoleLoggingNotificationListener
        implements NotificationListener, NotificationFilter {

    public void handleNotification(Notification notification, Object handback) {
        System.out.println(notification);
        System.out.println(handback);
    }

    public boolean isNotificationEnabled(Notification notification) {
        return AttributeChangeNotification.class.isAssignableFrom(notification.getClass());
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example adds <code>ConsoleLoggingNotificationListener</code> (defined in the preceding
example) to <code>notificationListenerMappings</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;

    &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
        &lt;property name="beans"&gt;
            &lt;map&gt;
                &lt;entry key="bean:name=testBean1" value-ref="testBean"/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;property name="notificationListenerMappings"&gt;
            &lt;map&gt;
                &lt;entry key="bean:name=testBean1"&gt;
                    &lt;bean class="com.example.ConsoleLoggingNotificationListener"/&gt;
                &lt;/entry&gt;
            &lt;/map&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
        &lt;property name="name" value="TEST"/&gt;
        &lt;property name="age" value="100"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>With the preceding configuration in place, every time a JMX <code>Notification</code> is broadcast from
the target MBean (<code>bean:name=testBean1</code>), the <code>ConsoleLoggingNotificationListener</code> bean
that was registered as a listener through the <code>notificationListenerMappings</code> property is
notified. The <code>ConsoleLoggingNotificationListener</code> bean can then take whatever action
it deems appropriate in response to the <code>Notification</code>.</p>
</div>
<div class="paragraph">
<p>You can also use straight bean names as the link between exported beans and listeners,
as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;

    &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
        &lt;property name="beans"&gt;
            &lt;map&gt;
                &lt;entry key="bean:name=testBean1" value-ref="testBean"/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;property name="notificationListenerMappings"&gt;
            &lt;map&gt;
                &lt;entry key="<em>testBean</em>"&gt;
                    &lt;bean class="com.example.ConsoleLoggingNotificationListener"/&gt;
                &lt;/entry&gt;
            &lt;/map&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="<em>testBean</em>" class="org.springframework.jmx.JmxTestBean"&gt;
        &lt;property name="name" value="TEST"/&gt;
        &lt;property name="age" value="100"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to register a single <code>NotificationListener</code> instance for all of the beans
that the enclosing <code>MBeanExporter</code> exports, you can use the special wildcard (<code>*</code>)
as the key for an entry in the <code>notificationListenerMappings</code> property
map, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;property name="notificationListenerMappings"&gt;
    &lt;map&gt;
        &lt;entry key="*"&gt;
            &lt;bean class="com.example.ConsoleLoggingNotificationListener"/&gt;
        &lt;/entry&gt;
    &lt;/map&gt;
&lt;/property&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you need to do the inverse (that is, register a number of distinct listeners against
an MBean), you must instead use the <code>notificationListeners</code> list property (in
preference to the <code>notificationListenerMappings</code> property). This time, instead of
configuring a <code>NotificationListener</code> for a single MBean, we configure
<code>NotificationListenerBean</code> instances. A <code>NotificationListenerBean</code> encapsulates a
<code>NotificationListener</code> and the <code>ObjectName</code> (or <code>ObjectNames</code>) that it is to be
registered against in an <code>MBeanServer</code>. The <code>NotificationListenerBean</code> also encapsulates
a number of other properties, such as a <code>NotificationFilter</code> and an arbitrary handback
object that can be used in advanced JMX notification scenarios.</p>
</div>
<div class="paragraph">
<p>The configuration when using <code>NotificationListenerBean</code> instances is not wildly
different to what was presented previously, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;

    &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
        &lt;property name="beans"&gt;
            &lt;map&gt;
                &lt;entry key="bean:name=testBean1" value-ref="testBean"/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;property name="notificationListeners"&gt;
            &lt;list&gt;
                &lt;bean class="org.springframework.jmx.export.NotificationListenerBean"&gt;
                    &lt;constructor-arg&gt;
                        &lt;bean class="com.example.ConsoleLoggingNotificationListener"/&gt;
                    &lt;/constructor-arg&gt;
                    &lt;property name="mappedObjectNames"&gt;
                        &lt;list&gt;
                            &lt;value&gt;bean:name=testBean1&lt;/value&gt;
                        &lt;/list&gt;
                    &lt;/property&gt;
                &lt;/bean&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
        &lt;property name="name" value="TEST"/&gt;
        &lt;property name="age" value="100"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding example is equivalent to the first notification example. Assume, then, that
we want to be given a handback object every time a <code>Notification</code> is raised and that
we also want to filter out extraneous <code>Notifications</code> by supplying a
<code>NotificationFilter</code>. The following example accomplishes these goals:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;

    &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
        &lt;property name="beans"&gt;
            &lt;map&gt;
                &lt;entry key="bean:name=testBean1" value-ref="testBean1"/&gt;
                &lt;entry key="bean:name=testBean2" value-ref="testBean2"/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;property name="notificationListeners"&gt;
            &lt;list&gt;
                &lt;bean class="org.springframework.jmx.export.NotificationListenerBean"&gt;
                    &lt;constructor-arg ref="customerNotificationListener"/&gt;
                    &lt;property name="mappedObjectNames"&gt;
                        &lt;list&gt;
                            &lt;!-- handles notifications from two distinct MBeans --&gt;
                            &lt;value&gt;bean:name=testBean1&lt;/value&gt;
                            &lt;value&gt;bean:name=testBean2&lt;/value&gt;
                        &lt;/list&gt;
                    &lt;/property&gt;
                    &lt;property name="handback"&gt;
                        &lt;bean class="java.lang.String"&gt;
                            &lt;constructor-arg value="This could be anything..."/&gt;
                        &lt;/bean&gt;
                    &lt;/property&gt;
                    &lt;property name="notificationFilter" ref="customerNotificationListener"/&gt;
                &lt;/bean&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;!-- implements both the NotificationListener and NotificationFilter interfaces --&gt;
    &lt;bean id="customerNotificationListener" class="com.example.ConsoleLoggingNotificationListener"/&gt;

    &lt;bean id="testBean1" class="org.springframework.jmx.JmxTestBean"&gt;
        &lt;property name="name" value="TEST"/&gt;
        &lt;property name="age" value="100"/&gt;
    &lt;/bean&gt;

    &lt;bean id="testBean2" class="org.springframework.jmx.JmxTestBean"&gt;
        &lt;property name="name" value="ANOTHER TEST"/&gt;
        &lt;property name="age" value="200"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>(For a full discussion of what a handback object is and,
indeed, what a <code>NotificationFilter</code> is, see the section of the JMX
specification (1.2) entitled 'The JMX Notification Model'.)</p>
</div>
</div>
<div class="sect3">
<h4 id="jmx-notifications-publishing"><a class="anchor" href="#jmx-notifications-publishing"></a>5.6.2. Publishing Notifications</h4>
<div class="paragraph">
<p>Spring provides support not only for registering to receive <code>Notifications</code> but also
for publishing <code>Notifications</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This section is really only relevant to Spring-managed beans that have
been exposed as MBeans through an <code>MBeanExporter</code>. Any existing user-defined MBeans should
use the standard JMX APIs for notification publication.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The key interface in Spring&#8217;s JMX notification publication support is the
<code>NotificationPublisher</code> interface (defined in the
<code>org.springframework.jmx.export.notification</code> package). Any bean that is going to be
exported as an MBean through an <code>MBeanExporter</code> instance can implement the related
<code>NotificationPublisherAware</code> interface to gain access to a <code>NotificationPublisher</code>
instance. The <code>NotificationPublisherAware</code> interface supplies an instance of a
<code>NotificationPublisher</code> to the implementing bean through a simple setter method,
which the bean can then use to publish <code>Notifications</code>.</p>
</div>
<div class="paragraph">
<p>As stated in the javadoc of the
<a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/jmx/export/notification/NotificationPublisher.html"><code>NotificationPublisher</code></a>
interface, managed beans that publish events through the <code>NotificationPublisher</code>
mechanism are not responsible for the state management of notification listeners.
Spring&#8217;s JMX support takes care of handling all the JMX infrastructure issues.
All you need to do, as an application developer, is implement the
<code>NotificationPublisherAware</code> interface and start publishing events by using the
supplied <code>NotificationPublisher</code> instance. Note that the <code>NotificationPublisher</code>
is set after the managed bean has been registered with an <code>MBeanServer</code>.</p>
</div>
<div class="paragraph">
<p>Using a <code>NotificationPublisher</code> instance is quite straightforward. You create a JMX
<code>Notification</code> instance (or an instance of an appropriate <code>Notification</code> subclass),
populate the notification with the data pertinent to the event that is to be
published, and invoke the <code>sendNotification(Notification)</code> on the
<code>NotificationPublisher</code> instance, passing in the <code>Notification</code>.</p>
</div>
<div class="paragraph">
<p>In the following example, exported instances of the <code>JmxTestBean</code> publish a
<code>NotificationEvent</code> every time the <code>add(int, int)</code> operation is invoked:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package org.springframework.jmx;

import org.springframework.jmx.export.notification.NotificationPublisherAware;
import org.springframework.jmx.export.notification.NotificationPublisher;
import javax.management.Notification;

public class JmxTestBean implements IJmxTestBean, NotificationPublisherAware {

    private String name;
    private int age;
    private boolean isSuperman;
    private NotificationPublisher publisher;

    // other getters and setters omitted for clarity

    public int add(int x, int y) {
        int answer = x + y;
        this.publisher.sendNotification(new Notification("add", this, 0));
        return answer;
    }

    public void dontExposeMe() {
        throw new RuntimeException();
    }

    public void setNotificationPublisher(NotificationPublisher notificationPublisher) {
        this.publisher = notificationPublisher;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>NotificationPublisher</code> interface and the machinery to get it all working is one of
the nicer features of Spring&#8217;s JMX support. It does, however, come with the price tag of
coupling your classes to both Spring and JMX. As always, the advice here is to be
pragmatic. If you need the functionality offered by the <code>NotificationPublisher</code> and
you can accept the coupling to both Spring and JMX, then do so.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jmx-resources"><a class="anchor" href="#jmx-resources"></a>5.7. Further Resources</h3>
<div class="paragraph">
<p>This section contains links to further resources about JMX:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <a href="https://www.oracle.com/technetwork/java/javase/tech/javamanagement-140525.html">JMX
homepage</a> at Oracle.</p>
</li>
<li>
<p>The <a href="https://jcp.org/aboutJava/communityprocess/final/jsr003/index3.html">JMX
specification</a> (JSR-000003).</p>
</li>
<li>
<p>The <a href="https://jcp.org/aboutJava/communityprocess/final/jsr160/index.html">JMX Remote API
specification</a> (JSR-000160).</p>
</li>
<li>
<p>The <a href="http://mx4j.sourceforge.net/">MX4J homepage</a>. (MX4J is an open-source implementation of
various JMX specs.)</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mail"><a class="anchor" href="#mail"></a>6. Email</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section describes how to send email with the Spring Framework.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Library dependencies</div>
<div class="paragraph">
<p>The following JAR needs to be on the classpath of your application in order to use
the Spring Framework&#8217;s email library:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <a href="https://eclipse-ee4j.github.io/mail/">JavaMail / Jakarta Mail 1.6</a> library</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This library is freely available on the web&#8201;&#8212;&#8201;for example, in Maven Central as
<code>com.sun.mail:jakarta.mail</code>. Please make sure to use the latest 1.6.x version
rather than Jakarta Mail 2.0 (which comes with a different package namespace).</p>
</div>
</div>
</div>
<div class="paragraph">
<p>The Spring Framework provides a helpful utility library for sending email that shields
you from the specifics of the underlying mailing system and is responsible for
low-level resource handling on behalf of the client.</p>
</div>
<div class="paragraph">
<p>The <code>org.springframework.mail</code> package is the root level package for the Spring
Framework&#8217;s email support. The central interface for sending emails is the <code>MailSender</code>
interface. A simple value object that encapsulates the properties of a simple mail such
as <code>from</code> and <code>to</code> (plus many others) is the <code>SimpleMailMessage</code> class. This package
also contains a hierarchy of checked exceptions that provide a higher level of
abstraction over the lower level mail system exceptions, with the root exception being
<code>MailException</code>. See the <a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/mail/MailException.html">javadoc</a>
for more information on the rich mail exception hierarchy.</p>
</div>
<div class="paragraph">
<p>The <code>org.springframework.mail.javamail.JavaMailSender</code> interface adds specialized
JavaMail features, such as MIME message support to the <code>MailSender</code> interface
(from which it inherits). <code>JavaMailSender</code> also provides a callback interface called
<code>org.springframework.mail.javamail.MimeMessagePreparator</code> for preparing a <code>MimeMessage</code>.</p>
</div>
<div class="sect2">
<h3 id="mail-usage"><a class="anchor" href="#mail-usage"></a>6.1. Usage</h3>
<div class="paragraph">
<p>Assume that we have a business interface called <code>OrderManager</code>, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface OrderManager {

    void placeOrder(Order order);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Further assume that we have a requirement stating that an email message with an
order number needs to be generated and sent to a customer who placed the relevant order.</p>
</div>
<div class="sect3">
<h4 id="mail-usage-simple"><a class="anchor" href="#mail-usage-simple"></a>6.1.1. Basic <code>MailSender</code> and <code>SimpleMailMessage</code> Usage</h4>
<div class="paragraph">
<p>The following example shows how to use <code>MailSender</code> and <code>SimpleMailMessage</code> to send an
email when someone places an order:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import org.springframework.mail.MailException;
import org.springframework.mail.MailSender;
import org.springframework.mail.SimpleMailMessage;

public class SimpleOrderManager implements OrderManager {

    private MailSender mailSender;
    private SimpleMailMessage templateMessage;

    public void setMailSender(MailSender mailSender) {
        this.mailSender = mailSender;
    }

    public void setTemplateMessage(SimpleMailMessage templateMessage) {
        this.templateMessage = templateMessage;
    }

    public void placeOrder(Order order) {

        // Do the business calculations...

        // Call the collaborators to persist the order...

        // Create a thread safe "copy" of the template message and customize it
        SimpleMailMessage msg = new SimpleMailMessage(this.templateMessage);
        msg.setTo(order.getCustomer().getEmailAddress());
        msg.setText(
            "Dear " + order.getCustomer().getFirstName()
                + order.getCustomer().getLastName()
                + ", thank you for placing order. Your order number is "
                + order.getOrderNumber());
        try{
            this.mailSender.send(msg);
        }
        catch (MailException ex) {
            // simply log it and go on...
            System.err.println(ex.getMessage());
        }
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows the bean definitions for the preceding code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="mailSender" class="org.springframework.mail.javamail.JavaMailSenderImpl"&gt;
    &lt;property name="host" value="mail.mycompany.example"/&gt;
&lt;/bean&gt;

&lt;!-- this is a template message that we can pre-load with default state --&gt;
&lt;bean id="templateMessage" class="org.springframework.mail.SimpleMailMessage"&gt;
    &lt;property name="from" value="customerservice@mycompany.example"/&gt;
    &lt;property name="subject" value="Your order"/&gt;
&lt;/bean&gt;

&lt;bean id="orderManager" class="com.mycompany.businessapp.support.SimpleOrderManager"&gt;
    &lt;property name="mailSender" ref="mailSender"/&gt;
    &lt;property name="templateMessage" ref="templateMessage"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mail-usage-mime"><a class="anchor" href="#mail-usage-mime"></a>6.1.2. Using <code>JavaMailSender</code> and <code>MimeMessagePreparator</code></h4>
<div class="paragraph">
<p>This section describes another implementation of <code>OrderManager</code> that uses the <code>MimeMessagePreparator</code>
callback interface. In the following example, the <code>mailSender</code> property is of type
<code>JavaMailSender</code> so that we are able to use the JavaMail <code>MimeMessage</code> class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeMessage;

import javax.mail.internet.MimeMessage;
import org.springframework.mail.MailException;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessagePreparator;

public class SimpleOrderManager implements OrderManager {

    private JavaMailSender mailSender;

    public void setMailSender(JavaMailSender mailSender) {
        this.mailSender = mailSender;
    }

    public void placeOrder(final Order order) {
        // Do the business calculations...
        // Call the collaborators to persist the order...

        MimeMessagePreparator preparator = new MimeMessagePreparator() {
            public void prepare(MimeMessage mimeMessage) throws Exception {
                mimeMessage.setRecipient(Message.RecipientType.TO,
                        new InternetAddress(order.getCustomer().getEmailAddress()));
                mimeMessage.setFrom(new InternetAddress("mail@mycompany.example"));
                mimeMessage.setText("Dear " + order.getCustomer().getFirstName() + " " +
                        order.getCustomer().getLastName() + ", thanks for your order. " +
                        "Your order number is " + order.getOrderNumber() + ".");
            }
        };

        try {
            this.mailSender.send(preparator);
        }
        catch (MailException ex) {
            // simply log it and go on...
            System.err.println(ex.getMessage());
        }
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The mail code is a crosscutting concern and could well be a candidate for
refactoring into a <a href="core.html#aop">custom Spring AOP aspect</a>, which could then
be run at appropriate joinpoints on the <code>OrderManager</code> target.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The Spring Framework&#8217;s mail support ships with the standard JavaMail implementation.
See the relevant javadoc for more information.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mail-javamail-mime"><a class="anchor" href="#mail-javamail-mime"></a>6.2. Using the JavaMail <code>MimeMessageHelper</code></h3>
<div class="paragraph">
<p>A class that comes in pretty handy when dealing with JavaMail messages is
<code>org.springframework.mail.javamail.MimeMessageHelper</code>, which shields you from
having to use the verbose JavaMail API. Using the <code>MimeMessageHelper</code>, it is
pretty easy to create a <code>MimeMessage</code>, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// of course you would use DI in any real-world cases
JavaMailSenderImpl sender = new JavaMailSenderImpl();
sender.setHost("mail.host.com");

MimeMessage message = sender.createMimeMessage();
MimeMessageHelper helper = new MimeMessageHelper(message);
helper.setTo("test@host.com");
helper.setText("Thank you for ordering!");

sender.send(message);</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="mail-javamail-mime-attachments"><a class="anchor" href="#mail-javamail-mime-attachments"></a>6.2.1. Sending Attachments and Inline Resources</h4>
<div class="paragraph">
<p>Multipart email messages allow for both attachments and inline resources. Examples of
inline resources include an image or a stylesheet that you want to use in your message but
that you do not want displayed as an attachment.</p>
</div>
<div class="sect4">
<h5 id="mail-javamail-mime-attachments-attachment"><a class="anchor" href="#mail-javamail-mime-attachments-attachment"></a>Attachments</h5>
<div class="paragraph">
<p>The following example shows you how to use the <code>MimeMessageHelper</code> to send an email
with a single JPEG image attachment:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">JavaMailSenderImpl sender = new JavaMailSenderImpl();
sender.setHost("mail.host.com");

MimeMessage message = sender.createMimeMessage();

// use the true flag to indicate you need a multipart message
MimeMessageHelper helper = new MimeMessageHelper(message, true);
helper.setTo("test@host.com");

helper.setText("Check out this image!");

// let's attach the infamous windows Sample file (this time copied to c:/)
FileSystemResource file = new FileSystemResource(new File("c:/Sample.jpg"));
helper.addAttachment("CoolImage.jpg", file);

sender.send(message);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mail-javamail-mime-attachments-inline"><a class="anchor" href="#mail-javamail-mime-attachments-inline"></a>Inline Resources</h5>
<div class="paragraph">
<p>The following example shows you how to use the <code>MimeMessageHelper</code> to send an email
with an inline image:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">JavaMailSenderImpl sender = new JavaMailSenderImpl();
sender.setHost("mail.host.com");

MimeMessage message = sender.createMimeMessage();

// use the true flag to indicate you need a multipart message
MimeMessageHelper helper = new MimeMessageHelper(message, true);
helper.setTo("test@host.com");

// use the true flag to indicate the text included is HTML
helper.setText("&lt;html&gt;&lt;body&gt;&lt;img src='cid:identifier1234'&gt;&lt;/body&gt;&lt;/html&gt;", true);

// let's include the infamous windows Sample file (this time copied to c:/)
FileSystemResource res = new FileSystemResource(new File("c:/Sample.jpg"));
helper.addInline("identifier1234", res);

sender.send(message);</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Inline resources are added to the <code>MimeMessage</code> by using the specified <code>Content-ID</code>
(<code>identifier1234</code> in the above example). The order in which you add the text
and the resource are very important. Be sure to first add the text and then
the resources. If you are doing it the other way around, it does not work.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mail-templates"><a class="anchor" href="#mail-templates"></a>6.2.2. Creating Email Content by Using a Templating Library</h4>
<div class="paragraph">
<p>The code in the examples shown in the previous sections explicitly created the content of the email message,
by using methods calls such as <code>message.setText(..)</code>. This is fine for simple cases, and it
is okay in the context of the aforementioned examples, where the intent was to show you
the very basics of the API.</p>
</div>
<div class="paragraph">
<p>In your typical enterprise application, though, developers often do not create the content
of email messages by using the previously shown approach for a number of reasons:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Creating HTML-based email content in Java code is tedious and error prone.</p>
</li>
<li>
<p>There is no clear separation between display logic and business logic.</p>
</li>
<li>
<p>Changing the display structure of the email content requires writing Java code,
recompiling, redeploying, and so on.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Typically, the approach taken to address these issues is to use a template library (such
as FreeMarker) to define the display structure of email content. This leaves your code
tasked only with creating the data that is to be rendered in the email template and
sending the email. It is definitely a best practice when the content of your email messages
becomes even moderately complex, and, with the Spring Framework&#8217;s support classes for
FreeMarker, it becomes quite easy to do.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="scheduling"><a class="anchor" href="#scheduling"></a>7. Task Execution and Scheduling</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Spring Framework provides abstractions for the asynchronous execution and scheduling of
tasks with the <code>TaskExecutor</code> and <code>TaskScheduler</code> interfaces, respectively. Spring also
features implementations of those interfaces that support thread pools or delegation to
CommonJ within an application server environment. Ultimately, the use of these
implementations behind the common interfaces abstracts away the differences between Java
SE 5, Java SE 6, and Java EE environments.</p>
</div>
<div class="paragraph">
<p>Spring also features integration classes to support scheduling with the <code>Timer</code>
(part of the JDK since 1.3) and the Quartz Scheduler ( <a href="https://www.quartz-scheduler.org/" class="bare">https://www.quartz-scheduler.org/</a>).
You can set up both of those schedulers by using a <code>FactoryBean</code> with optional references to
<code>Timer</code> or <code>Trigger</code> instances, respectively. Furthermore, a convenience class for both
the Quartz Scheduler and the <code>Timer</code> is available that lets you invoke a method of
an existing target object (analogous to the normal <code>MethodInvokingFactoryBean</code>
operation).</p>
</div>
<div class="sect2">
<h3 id="scheduling-task-executor"><a class="anchor" href="#scheduling-task-executor"></a>7.1. The Spring <code>TaskExecutor</code> Abstraction</h3>
<div class="paragraph">
<p>Executors are the JDK name for the concept of thread pools. The &#8220;executor&#8221; naming is
due to the fact that there is no guarantee that the underlying implementation is
actually a pool. An executor may be single-threaded or even synchronous. Spring&#8217;s
abstraction hides implementation details between the Java SE and Java EE environments.</p>
</div>
<div class="paragraph">
<p>Spring&#8217;s <code>TaskExecutor</code> interface is identical to the <code>java.util.concurrent.Executor</code>
interface. In fact, originally, its primary reason for existence was to abstract away
the need for Java 5 when using thread pools. The interface has a single method
(<code>execute(Runnable task)</code>) that accepts a task for execution based on the semantics
and configuration of the thread pool.</p>
</div>
<div class="paragraph">
<p>The <code>TaskExecutor</code> was originally created to give other Spring components an abstraction
for thread pooling where needed. Components such as the <code>ApplicationEventMulticaster</code>,
JMS&#8217;s <code>AbstractMessageListenerContainer</code>, and Quartz integration all use the
<code>TaskExecutor</code> abstraction to pool threads. However, if your beans need thread pooling
behavior, you can also use this abstraction for your own needs.</p>
</div>
<div class="sect3">
<h4 id="scheduling-task-executor-types"><a class="anchor" href="#scheduling-task-executor-types"></a>7.1.1. <code>TaskExecutor</code> Types</h4>
<div class="paragraph">
<p>Spring includes a number of pre-built implementations of <code>TaskExecutor</code>.
In all likelihood, you should never need to implement your own.
The variants that Spring provides are as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>SyncTaskExecutor</code>:
This implementation does not run invocations asynchronously. Instead, each
invocation takes place in the calling thread. It is primarily used in situations
where multi-threading is not necessary, such as in simple test cases.</p>
</li>
<li>
<p><code>SimpleAsyncTaskExecutor</code>:
This implementation does not reuse any threads. Rather, it starts up a new thread
for each invocation. However, it does support a concurrency limit that blocks
any invocations that are over the limit until a slot has been freed up. If you
are looking for true pooling, see <code>ThreadPoolTaskExecutor</code>, later in this list.</p>
</li>
<li>
<p><code>ConcurrentTaskExecutor</code>:
This implementation is an adapter for a <code>java.util.concurrent.Executor</code> instance.
There is an alternative (<code>ThreadPoolTaskExecutor</code>) that exposes the <code>Executor</code>
configuration parameters as bean properties. There is rarely a need to use
<code>ConcurrentTaskExecutor</code> directly. However, if the <code>ThreadPoolTaskExecutor</code> is not
flexible enough for your needs, <code>ConcurrentTaskExecutor</code> is an alternative.</p>
</li>
<li>
<p><code>ThreadPoolTaskExecutor</code>:
This implementation is most commonly used. It exposes bean properties for
configuring a <code>java.util.concurrent.ThreadPoolExecutor</code> and wraps it in a <code>TaskExecutor</code>.
If you need to adapt to a different kind of <code>java.util.concurrent.Executor</code>, we
recommend that you use a <code>ConcurrentTaskExecutor</code> instead.</p>
</li>
<li>
<p><code>WorkManagerTaskExecutor</code>:
This implementation uses a CommonJ <code>WorkManager</code> as its backing service provider
and is the central convenience class for setting up CommonJ-based thread pool
integration on WebLogic or WebSphere within a Spring application context.</p>
</li>
<li>
<p><code>DefaultManagedTaskExecutor</code>:
This implementation uses a JNDI-obtained <code>ManagedExecutorService</code> in a JSR-236
compatible runtime environment (such as a Java EE 7+ application server),
replacing a CommonJ WorkManager for that purpose.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="scheduling-task-executor-usage"><a class="anchor" href="#scheduling-task-executor-usage"></a>7.1.2. Using a <code>TaskExecutor</code></h4>
<div class="paragraph">
<p>Spring&#8217;s <code>TaskExecutor</code> implementations are used as simple JavaBeans. In the following example,
we define a bean that uses the <code>ThreadPoolTaskExecutor</code> to asynchronously print
out a set of messages:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import org.springframework.core.task.TaskExecutor;

public class TaskExecutorExample {

    private class MessagePrinterTask implements Runnable {

        private String message;

        public MessagePrinterTask(String message) {
            this.message = message;
        }

        public void run() {
            System.out.println(message);
        }
    }

    private TaskExecutor taskExecutor;

    public TaskExecutorExample(TaskExecutor taskExecutor) {
        this.taskExecutor = taskExecutor;
    }

    public void printMessages() {
        for(int i = 0; i &lt; 25; i++) {
            taskExecutor.execute(new MessagePrinterTask("Message" + i));
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, rather than retrieving a thread from the pool and executing it yourself,
you add your <code>Runnable</code> to the queue. Then the <code>TaskExecutor</code> uses its internal rules to
decide when the task gets run.</p>
</div>
<div class="paragraph">
<p>To configure the rules that the <code>TaskExecutor</code> uses, we expose simple bean properties:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="taskExecutor" class="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"&gt;
    &lt;property name="corePoolSize" value="5"/&gt;
    &lt;property name="maxPoolSize" value="10"/&gt;
    &lt;property name="queueCapacity" value="25"/&gt;
&lt;/bean&gt;

&lt;bean id="taskExecutorExample" class="TaskExecutorExample"&gt;
    &lt;constructor-arg ref="taskExecutor"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="scheduling-task-scheduler"><a class="anchor" href="#scheduling-task-scheduler"></a>7.2. The Spring <code>TaskScheduler</code> Abstraction</h3>
<div class="paragraph">
<p>In addition to the <code>TaskExecutor</code> abstraction, Spring 3.0 introduced a <code>TaskScheduler</code>
with a variety of methods for scheduling tasks to run at some point in the future.
The following listing shows the <code>TaskScheduler</code> interface definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface TaskScheduler {

    ScheduledFuture schedule(Runnable task, Trigger trigger);

    ScheduledFuture schedule(Runnable task, Instant startTime);

    ScheduledFuture schedule(Runnable task, Date startTime);

    ScheduledFuture scheduleAtFixedRate(Runnable task, Instant startTime, Duration period);

    ScheduledFuture scheduleAtFixedRate(Runnable task, Date startTime, long period);

    ScheduledFuture scheduleAtFixedRate(Runnable task, Duration period);

    ScheduledFuture scheduleAtFixedRate(Runnable task, long period);

    ScheduledFuture scheduleWithFixedDelay(Runnable task, Instant startTime, Duration delay);

    ScheduledFuture scheduleWithFixedDelay(Runnable task, Date startTime, long delay);

    ScheduledFuture scheduleWithFixedDelay(Runnable task, Duration delay);

    ScheduledFuture scheduleWithFixedDelay(Runnable task, long delay);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The simplest method is the one named <code>schedule</code> that takes only a <code>Runnable</code> and a <code>Date</code>.
That causes the task to run once after the specified time. All of the other methods
are capable of scheduling tasks to run repeatedly. The fixed-rate and fixed-delay
methods are for simple, periodic execution, but the method that accepts a <code>Trigger</code> is
much more flexible.</p>
</div>
<div class="sect3">
<h4 id="scheduling-trigger-interface"><a class="anchor" href="#scheduling-trigger-interface"></a>7.2.1. <code>Trigger</code> Interface</h4>
<div class="paragraph">
<p>The <code>Trigger</code> interface is essentially inspired by JSR-236 which, as of Spring 3.0,
was not yet officially implemented. The basic idea of the <code>Trigger</code> is that execution
times may be determined based on past execution outcomes or even arbitrary conditions.
If these determinations do take into account the outcome of the preceding execution,
that information is available within a <code>TriggerContext</code>. The <code>Trigger</code> interface itself
is quite simple, as the following listing shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface Trigger {

    Date nextExecutionTime(TriggerContext triggerContext);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>TriggerContext</code> is the most important part. It encapsulates all of
the relevant data and is open for extension in the future, if necessary. The
<code>TriggerContext</code> is an interface (a <code>SimpleTriggerContext</code> implementation is used by
default). The following listing shows the available methods for <code>Trigger</code> implementations.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface TriggerContext {

    Date lastScheduledExecutionTime();

    Date lastActualExecutionTime();

    Date lastCompletionTime();
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="scheduling-trigger-implementations"><a class="anchor" href="#scheduling-trigger-implementations"></a>7.2.2. <code>Trigger</code> Implementations</h4>
<div class="paragraph">
<p>Spring provides two implementations of the <code>Trigger</code> interface. The most interesting one
is the <code>CronTrigger</code>. It enables the scheduling of tasks based on
<a href="#scheduling-cron-expression">cron expressions</a>.
For example, the following task is scheduled to run 15 minutes past each hour but only
during the 9-to-5 &#8220;business hours&#8221; on weekdays:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">scheduler.schedule(task, new CronTrigger("0 15 9-17 * * MON-FRI"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>The other implementation is a <code>PeriodicTrigger</code> that accepts a fixed
period, an optional initial delay value, and a boolean to indicate whether the period
should be interpreted as a fixed-rate or a fixed-delay. Since the <code>TaskScheduler</code>
interface already defines methods for scheduling tasks at a fixed rate or with a
fixed delay, those methods should be used directly whenever possible. The value of the
<code>PeriodicTrigger</code> implementation is that you can use it within components that rely on
the <code>Trigger</code> abstraction. For example, it may be convenient to allow periodic triggers,
cron-based triggers, and even custom trigger implementations to be used interchangeably.
Such a component could take advantage of dependency injection so that you can configure such <code>Triggers</code>
externally and, therefore, easily modify or extend them.</p>
</div>
</div>
<div class="sect3">
<h4 id="scheduling-task-scheduler-implementations"><a class="anchor" href="#scheduling-task-scheduler-implementations"></a>7.2.3. <code>TaskScheduler</code> implementations</h4>
<div class="paragraph">
<p>As with Spring&#8217;s <code>TaskExecutor</code> abstraction, the primary benefit of the <code>TaskScheduler</code>
arrangement is that an application&#8217;s scheduling needs are decoupled from the deployment
environment. This abstraction level is particularly relevant when deploying to an
application server environment where threads should not be created directly by the
application itself. For such scenarios, Spring provides a <code>TimerManagerTaskScheduler</code>
that delegates to a CommonJ <code>TimerManager</code> on WebLogic or WebSphere as well as a more recent
<code>DefaultManagedTaskScheduler</code> that delegates to a JSR-236 <code>ManagedScheduledExecutorService</code>
in a Java EE 7+ environment. Both are typically configured with a JNDI lookup.</p>
</div>
<div class="paragraph">
<p>Whenever external thread management is not a requirement, a simpler alternative is
a local <code>ScheduledExecutorService</code> setup within the application, which can be adapted
through Spring&#8217;s <code>ConcurrentTaskScheduler</code>. As a convenience, Spring also provides a
<code>ThreadPoolTaskScheduler</code>, which internally delegates to a <code>ScheduledExecutorService</code>
to provide common bean-style configuration along the lines of <code>ThreadPoolTaskExecutor</code>.
These variants work perfectly fine for locally embedded thread pool setups in lenient
application server environments, as well&#8201;&#8212;&#8201;in particular on Tomcat and Jetty.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="scheduling-annotation-support"><a class="anchor" href="#scheduling-annotation-support"></a>7.3. Annotation Support for Scheduling and Asynchronous Execution</h3>
<div class="paragraph">
<p>Spring provides annotation support for both task scheduling and asynchronous method
execution.</p>
</div>
<div class="sect3">
<h4 id="scheduling-enable-annotation-support"><a class="anchor" href="#scheduling-enable-annotation-support"></a>7.3.1. Enable Scheduling Annotations</h4>
<div class="paragraph">
<p>To enable support for <code>@Scheduled</code> and <code>@Async</code> annotations, you can add <code>@EnableScheduling</code> and
<code>@EnableAsync</code> to one of your <code>@Configuration</code> classes, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
@EnableAsync
@EnableScheduling
public class AppConfig {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can pick and choose the relevant annotations for your application. For example,
if you need only support for <code>@Scheduled</code>, you can omit <code>@EnableAsync</code>. For more
fine-grained control, you can additionally implement the <code>SchedulingConfigurer</code>
interface, the <code>AsyncConfigurer</code> interface, or both. See the
<a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/scheduling/annotation/SchedulingConfigurer.html"><code>SchedulingConfigurer</code></a>
and <a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/scheduling/annotation/AsyncConfigurer.html"><code>AsyncConfigurer</code></a>
javadoc for full details.</p>
</div>
<div class="paragraph">
<p>If you prefer XML configuration, you can use the <code>&lt;task:annotation-driven&gt;</code> element,
as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;task:annotation-driven executor="myExecutor" scheduler="myScheduler"/&gt;
&lt;task:executor id="myExecutor" pool-size="5"/&gt;
&lt;task:scheduler id="myScheduler" pool-size="10"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that, with the preceding XML, an executor reference is provided for handling those
tasks that correspond to methods with the <code>@Async</code> annotation, and the scheduler
reference is provided for managing those methods annotated with <code>@Scheduled</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The default advice mode for processing <code>@Async</code> annotations is <code>proxy</code> which allows
for interception of calls through the proxy only. Local calls within the same class
cannot get intercepted that way. For a more advanced mode of interception, consider
switching to <code>aspectj</code> mode in combination with compile-time or load-time weaving.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="scheduling-annotation-support-scheduled"><a class="anchor" href="#scheduling-annotation-support-scheduled"></a>7.3.2. The <code>@Scheduled</code> annotation</h4>
<div class="paragraph">
<p>You can add the <code>@Scheduled</code> annotation to a method, along with trigger metadata. For
example, the following method is invoked every five seconds with a fixed delay,
meaning that the period is measured from the completion time of each preceding
invocation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Scheduled(fixedDelay=5000)
public void doSomething() {
    // something that should run periodically
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you need a fixed-rate execution, you can change the property name specified within
the annotation. The following method is invoked every five seconds (measured between the
successive start times of each invocation):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Scheduled(fixedRate=5000)
public void doSomething() {
    // something that should run periodically
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For fixed-delay and fixed-rate tasks, you can specify an initial delay by indicating the
number of milliseconds to wait before the first execution of the method, as the following
<code>fixedRate</code> example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Scheduled(initialDelay=1000, fixedRate=5000)
public void doSomething() {
    // something that should run periodically
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If simple periodic scheduling is not expressive enough, you can provide a
<a href="#scheduling-cron-expression">cron expression</a>.
The following example runs only on weekdays:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Scheduled(cron="*/5 * * * * MON-FRI")
public void doSomething() {
    // something that should run on weekdays only
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can also use the <code>zone</code> attribute to specify the time zone in which the cron
expression is resolved.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Notice that the methods to be scheduled must have void returns and must not expect any
arguments. If the method needs to interact with other objects from the application
context, those would typically have been provided through dependency injection.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>As of Spring Framework 4.3, <code>@Scheduled</code> methods are supported on beans of any scope.</p>
</div>
<div class="paragraph">
<p>Make sure that you are not initializing multiple instances of the same <code>@Scheduled</code>
annotation class at runtime, unless you do want to schedule callbacks to each such
instance. Related to this, make sure that you do not use <code>@Configurable</code> on bean
classes that are annotated with <code>@Scheduled</code> and registered as regular Spring beans
with the container. Otherwise, you would get double initialization (once through the
container and once through the <code>@Configurable</code> aspect), with the consequence of each
<code>@Scheduled</code> method being invoked twice.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="scheduling-annotation-support-async"><a class="anchor" href="#scheduling-annotation-support-async"></a>7.3.3. The <code>@Async</code> annotation</h4>
<div class="paragraph">
<p>You can provide the <code>@Async</code> annotation on a method so that invocation of that method
occurs asynchronously. In other words, the caller returns immediately upon
invocation, while the actual execution of the method occurs in a task that has been
submitted to a Spring <code>TaskExecutor</code>. In the simplest case, you can apply the annotation
to a method that returns <code>void</code>, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Async
void doSomething() {
    // this will be run asynchronously
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Unlike the methods annotated with the <code>@Scheduled</code> annotation, these methods can expect
arguments, because they are invoked in the &#8220;normal&#8221; way by callers at runtime rather
than from a scheduled task being managed by the container. For example, the following code is
a legitimate application of the <code>@Async</code> annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Async
void doSomething(String s) {
    // this will be run asynchronously
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Even methods that return a value can be invoked asynchronously. However, such methods
are required to have a <code>Future</code>-typed return value. This still provides the benefit of
asynchronous execution so that the caller can perform other tasks prior to calling
<code>get()</code> on that <code>Future</code>. The following example shows how to use <code>@Async</code> on a method
that returns a value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Async
Future&lt;String&gt; returnSomething(int i) {
    // this will be run asynchronously
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>@Async</code> methods may not only declare a regular <code>java.util.concurrent.Future</code> return type
but also Spring&#8217;s <code>org.springframework.util.concurrent.ListenableFuture</code> or, as of Spring
4.2, JDK 8&#8217;s <code>java.util.concurrent.CompletableFuture</code>, for richer interaction with the
asynchronous task and for immediate composition with further processing steps.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can not use <code>@Async</code> in conjunction with lifecycle callbacks such as
<code>@PostConstruct</code>. To asynchronously initialize Spring beans, you currently have to use
a separate initializing Spring bean that then invokes the <code>@Async</code> annotated method on the
target, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class SampleBeanImpl implements SampleBean {

    @Async
    void doSomething() {
        // ...
    }

}

public class SampleBeanInitializer {

    private final SampleBean bean;

    public SampleBeanInitializer(SampleBean bean) {
        this.bean = bean;
    }

    @PostConstruct
    public void initialize() {
        bean.doSomething();
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
There is no direct XML equivalent for <code>@Async</code>, since such methods should be designed
for asynchronous execution in the first place, not externally re-declared to be asynchronous.
However, you can manually set up Spring&#8217;s <code>AsyncExecutionInterceptor</code> with Spring AOP,
in combination with a custom pointcut.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="scheduling-annotation-support-qualification"><a class="anchor" href="#scheduling-annotation-support-qualification"></a>7.3.4. Executor Qualification with <code>@Async</code></h4>
<div class="paragraph">
<p>By default, when specifying <code>@Async</code> on a method, the executor that is used is the
one <a href="#scheduling-enable-annotation-support">configured when enabling async support</a>,
i.e. the &#8220;annotation-driven&#8221; element if you are using XML or your <code>AsyncConfigurer</code>
implementation, if any. However, you can use the <code>value</code> attribute of the <code>@Async</code>
annotation when you need to indicate that an executor other than the default should be
used when executing a given method. The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Async("otherExecutor")
void doSomething(String s) {
    // this will be run asynchronously by "otherExecutor"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, <code>"otherExecutor"</code> can be the name of any <code>Executor</code> bean in the Spring
container, or it may be the name of a qualifier associated with any <code>Executor</code> (for example, as
specified with the <code>&lt;qualifier&gt;</code> element or Spring&#8217;s <code>@Qualifier</code> annotation).</p>
</div>
</div>
<div class="sect3">
<h4 id="scheduling-annotation-support-exception"><a class="anchor" href="#scheduling-annotation-support-exception"></a>7.3.5. Exception Management with <code>@Async</code></h4>
<div class="paragraph">
<p>When an <code>@Async</code> method has a <code>Future</code>-typed return value, it is easy to manage
an exception that was thrown during the method execution, as this exception is
thrown when calling <code>get</code> on the <code>Future</code> result. With a <code>void</code> return type,
however, the exception is uncaught and cannot be transmitted. You can provide an
<code>AsyncUncaughtExceptionHandler</code> to handle such exceptions. The following example shows
how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class MyAsyncUncaughtExceptionHandler implements AsyncUncaughtExceptionHandler {

    @Override
    public void handleUncaughtException(Throwable ex, Method method, Object... params) {
        // handle exception
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default, the exception is merely logged. You can define a custom <code>AsyncUncaughtExceptionHandler</code>
by using <code>AsyncConfigurer</code> or the <code>&lt;task:annotation-driven/&gt;</code> XML element.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="scheduling-task-namespace"><a class="anchor" href="#scheduling-task-namespace"></a>7.4. The <code>task</code> Namespace</h3>
<div class="paragraph">
<p>As of version 3.0, Spring includes an XML namespace for configuring <code>TaskExecutor</code> and
<code>TaskScheduler</code> instances. It also provides a convenient way to configure tasks to be
scheduled with a trigger.</p>
</div>
<div class="sect3">
<h4 id="scheduling-task-namespace-scheduler"><a class="anchor" href="#scheduling-task-namespace-scheduler"></a>7.4.1. The 'scheduler' Element</h4>
<div class="paragraph">
<p>The following element creates a <code>ThreadPoolTaskScheduler</code> instance with the
specified thread pool size:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;task:scheduler id="scheduler" pool-size="10"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The value provided for the <code>id</code> attribute is used as the prefix for thread names
within the pool. The <code>scheduler</code> element is relatively straightforward. If you do not
provide a <code>pool-size</code> attribute, the default thread pool has only a single thread.
There are no other configuration options for the scheduler.</p>
</div>
</div>
<div class="sect3">
<h4 id="scheduling-task-namespace-executor"><a class="anchor" href="#scheduling-task-namespace-executor"></a>7.4.2. The <code>executor</code> Element</h4>
<div class="paragraph">
<p>The following creates a <code>ThreadPoolTaskExecutor</code> instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;task:executor id="executor" pool-size="10"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>As with the scheduler shown in the <a href="#scheduling-task-namespace-scheduler">previous section</a>,
the value provided for the <code>id</code> attribute is used as the prefix for thread names within
the pool. As far as the pool size is concerned, the <code>executor</code> element supports more
configuration options than the <code>scheduler</code> element. For one thing, the thread pool for
a <code>ThreadPoolTaskExecutor</code> is itself more configurable. Rather than only a single size,
an executor&#8217;s thread pool can have different values for the core and the max size.
If you provide a single value, the executor has a fixed-size thread pool (the core and
max sizes are the same). However, the <code>executor</code> element&#8217;s <code>pool-size</code> attribute also
accepts a range in the form of <code>min-max</code>. The following example sets a minimum value of
<code>5</code> and a maximum value of <code>25</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;task:executor
        id="executorWithPoolSizeRange"
        pool-size="5-25"
        queue-capacity="100"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding configuration, a <code>queue-capacity</code> value has also been provided.
The configuration of the thread pool should also be considered in light of the
executor&#8217;s queue capacity. For the full description of the relationship between pool
size and queue capacity, see the documentation for
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadPoolExecutor.html"><code>ThreadPoolExecutor</code></a>.
The main idea is that, when a task is submitted, the executor first tries to use a
free thread if the number of active threads is currently less than the core size.
If the core size has been reached, the task is added to the queue, as long as its
capacity has not yet been reached. Only then, if the queue&#8217;s capacity has been
reached, does the executor create a new thread beyond the core size. If the max size
has also been reached, then the executor rejects the task.</p>
</div>
<div class="paragraph">
<p>By default, the queue is unbounded, but this is rarely the desired configuration,
because it can lead to <code>OutOfMemoryErrors</code> if enough tasks are added to that queue while
all pool threads are busy. Furthermore, if the queue is unbounded, the max size has
no effect at all. Since the executor always tries the queue before creating a new
thread beyond the core size, a queue must have a finite capacity for the thread pool to
grow beyond the core size (this is why a fixed-size pool is the only sensible case
when using an unbounded queue).</p>
</div>
<div class="paragraph">
<p>Consider the case, as mentioned above, when a task is rejected. By default, when a
task is rejected, a thread pool executor throws a <code>TaskRejectedException</code>. However,
the rejection policy is actually configurable. The exception is thrown when using
the default rejection policy, which is the <code>AbortPolicy</code> implementation.
For applications where some tasks can be skipped under heavy load, you can instead
configure either <code>DiscardPolicy</code> or <code>DiscardOldestPolicy</code>. Another option that works
well for applications that need to throttle the submitted tasks under heavy load is
the <code>CallerRunsPolicy</code>. Instead of throwing an exception or discarding tasks,
that policy forces the thread that is calling the submit method to run the task itself.
The idea is that such a caller is busy while running that task and not able to submit
other tasks immediately. Therefore, it provides a simple way to throttle the incoming
load while maintaining the limits of the thread pool and queue. Typically, this allows
the executor to &#8220;catch up&#8221; on the tasks it is handling and thereby frees up some
capacity on the queue, in the pool, or both. You can choose any of these options from an
enumeration of values available for the <code>rejection-policy</code> attribute on the <code>executor</code>
element.</p>
</div>
<div class="paragraph">
<p>The following example shows an <code>executor</code> element with a number of attributes to specify
various behaviors:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;task:executor
        id="executorWithCallerRunsPolicy"
        pool-size="5-25"
        queue-capacity="100"
        rejection-policy="CALLER_RUNS"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, the <code>keep-alive</code> setting determines the time limit (in seconds) for which threads
may remain idle before being stopped. If there are more than the core number of threads
currently in the pool, after waiting this amount of time without processing a task, excess
threads get stopped. A time value of zero causes excess threads to stop
immediately after executing a task without remaining follow-up work in the task queue.
The following example sets the <code>keep-alive</code> value to two minutes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;task:executor
        id="executorWithKeepAlive"
        pool-size="5-25"
        keep-alive="120"/&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="scheduling-task-namespace-scheduled-tasks"><a class="anchor" href="#scheduling-task-namespace-scheduled-tasks"></a>7.4.3. The 'scheduled-tasks' Element</h4>
<div class="paragraph">
<p>The most powerful feature of Spring&#8217;s task namespace is the support for configuring
tasks to be scheduled within a Spring Application Context. This follows an approach
similar to other &#8220;method-invokers&#8221; in Spring, such as that provided by the JMS namespace
for configuring message-driven POJOs. Basically, a <code>ref</code> attribute can point to any
Spring-managed object, and the <code>method</code> attribute provides the name of a method to be
invoked on that object. The following listing shows a simple example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;task:scheduled-tasks scheduler="myScheduler"&gt;
    &lt;task:scheduled ref="beanA" method="methodA" fixed-delay="5000"/&gt;
&lt;/task:scheduled-tasks&gt;

&lt;task:scheduler id="myScheduler" pool-size="10"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The scheduler is referenced by the outer element, and each individual
task includes the configuration of its trigger metadata. In the preceding example, that
metadata defines a periodic trigger with a fixed delay indicating the number of
milliseconds to wait after each task execution has completed. Another option is
<code>fixed-rate</code>, indicating how often the method should be run regardless of how long
any previous execution takes. Additionally, for both <code>fixed-delay</code> and <code>fixed-rate</code> tasks, you can specify an
'initial-delay' parameter, indicating the number of milliseconds to wait
before the first execution of the method. For more control, you can instead provide a <code>cron</code> attribute
to provide a <a href="#scheduling-cron-expression">cron expression</a>.
The following example shows these other options:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;task:scheduled-tasks scheduler="myScheduler"&gt;
    &lt;task:scheduled ref="beanA" method="methodA" fixed-delay="5000" initial-delay="1000"/&gt;
    &lt;task:scheduled ref="beanB" method="methodB" fixed-rate="5000"/&gt;
    &lt;task:scheduled ref="beanC" method="methodC" cron="*/5 * * * * MON-FRI"/&gt;
&lt;/task:scheduled-tasks&gt;

&lt;task:scheduler id="myScheduler" pool-size="10"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="scheduling-cron-expression"><a class="anchor" href="#scheduling-cron-expression"></a>7.5. Cron Expressions</h3>
<div class="paragraph">
<p>All Spring cron expressions have to conform to the same format, whether you are using them in
<a href="#scheduling-annotation-support-scheduled"><code>@Scheduled</code> annotations</a>,
<a href="#scheduling-task-namespace-scheduled-tasks"><code>task:scheduled-tasks</code> elements</a>,
or someplace else.
A well-formed cron expression, such as <code>* * * * * *</code>, consists of six space-separated time and date
fields, each with its own range of valid values:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>  second (0-59)
   minute (0 - 59)
    hour (0 - 23)
     day of the month (1 - 31)
      month (1 - 12) (or JAN-DEC)
       day of the week (0 - 7)
                (0 or 7 is Sunday, or MON-SUN)
      
 * * * * * *</pre>
</div>
</div>
<div class="paragraph">
<p>There are some rules that apply:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A field may be an asterisk (<code>*</code>), which always stands for &#8220;first-last&#8221;.
For the day-of-the-month or day-of-the-week fields, a question mark (<code>?</code>) may be used instead of an
asterisk.</p>
</li>
<li>
<p>Commas (<code>,</code>) are used to separate items of a list.</p>
</li>
<li>
<p>Two numbers separated with a hyphen (<code>-</code>) express a range of numbers.
The specified range is inclusive.</p>
</li>
<li>
<p>Following a range (or <code>*</code>) with <code>/</code> specifies the interval of the number&#8217;s value through the range.</p>
</li>
<li>
<p>English names can also be used for the day-of-month and day-of-week fields.
Use the first three letters of the particular day or month (case does not matter).</p>
</li>
<li>
<p>The day-of-month and day-of-week fields can contain a <code>L</code> character, which has a different meaning</p>
<div class="ulist">
<ul>
<li>
<p>In the day-of-month field, <code>L</code> stands for <em>the last day of the month</em>.
If followed by a negative offset (that is, <code>L-n</code>), it means <em><code>n</code>th-to-last day of the month</em>.</p>
</li>
<li>
<p>In the day-of-week field, <code>L</code> stands for <em>the last day of the week</em>.
If prefixed by a number or three-letter name (<code>dL</code> or <code>DDDL</code>), it means <em>the last day of week (<code>d</code>
or <code>DDD</code>) in the month</em>.</p>
</li>
</ul>
</div>
</li>
<li>
<p>The day-of-month field can be <code>nW</code>, which stands for <em>the nearest weekday to day of the month <code>n</code></em>.
If <code>n</code> falls on Saturday, this yields the Friday before it.
If <code>n</code> falls on Sunday, this yields the Monday after, which also happens if <code>n</code> is <code>1</code> and falls on
a Saturday (that is: <code>1W</code> stands for <em>the first weekday of the month</em>).</p>
</li>
<li>
<p>If the day-of-month field is <code>LW</code>, it means <em>the last weekday of the month</em>.</p>
</li>
<li>
<p>The day-of-week field can be <code>d#n</code> (or <code>DDD#n</code>), which stands for <em>the <code>n</code>th day of week <code>d</code>
(or <code>DDD</code>) in the month</em>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Here are some examples:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Cron Expression</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0 0 * * * *</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">top of every hour of every day</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>*/10 * * * * *</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">every ten seconds</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0 0 8-10 * * *</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8, 9 and 10 o&#8217;clock of every day</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0 0 6,19 * * *</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">6:00 AM and 7:00 PM every day</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0 0/30 8-10 * * *</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8:00, 8:30, 9:00, 9:30, 10:00 and 10:30 every day</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0 0 9-17 * * MON-FRI</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">on the hour nine-to-five weekdays</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0 0 0 25 DEC ?</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">every Christmas Day at midnight</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0 0 0 L * *</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">last day of the month at midnight</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0 0 0 L-3 * *</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">third-to-last day of the month at midnight</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0 0 0 * * 5L</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">last Friday of the month at midnight</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0 0 0 * * THUL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">last Thursday of the month at midnight</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0 0 0 1W * *</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">first weekday of the month at midnight</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0 0 0 LW * *</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">last weekday of the month at midnight</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0 0 0 ? * 5#2</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">the second Friday in the month at midnight</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0 0 0 ? * MON#1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">the first Monday in the month at midnight</p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="macros"><a class="anchor" href="#macros"></a>7.5.1. Macros</h4>
<div class="paragraph">
<p>Expressions such as <code>0 0 * * * *</code> are hard for humans to parse and are, therefore, hard to fix in case of bugs.
To improve readability, Spring supports the following macros, which represent commonly used sequences.
You can use these macros instead of the six-digit value, thus: <code>@Scheduled(cron = "@hourly")</code>.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Macro</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@yearly</code> (or <code>@annually</code>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">once a year (<code>0 0 0 1 1 *</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@monthly</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">once a month (<code>0 0 0 1 * *</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@weekly</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">once a week (<code>0 0 0 * * 0</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@daily</code> (or <code>@midnight</code>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">once a day (<code>0 0 0 * * *</code>), or</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@hourly</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">once an hour, (<code>0 0 * * * *</code>)</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="scheduling-quartz"><a class="anchor" href="#scheduling-quartz"></a>7.6. Using the Quartz Scheduler</h3>
<div class="paragraph">
<p>Quartz uses <code>Trigger</code>, <code>Job</code>, and <code>JobDetail</code> objects to realize scheduling of all kinds
of jobs. For the basic concepts behind Quartz, see
<a href="https://www.quartz-scheduler.org/" class="bare">https://www.quartz-scheduler.org/</a>. For convenience purposes, Spring offers a couple of
classes that simplify using Quartz within Spring-based applications.</p>
</div>
<div class="sect3">
<h4 id="scheduling-quartz-jobdetail"><a class="anchor" href="#scheduling-quartz-jobdetail"></a>7.6.1. Using the <code>JobDetailFactoryBean</code></h4>
<div class="paragraph">
<p>Quartz <code>JobDetail</code> objects contain all the information needed to run a job. Spring provides a
<code>JobDetailFactoryBean</code>, which provides bean-style properties for XML configuration purposes.
Consider the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean name="exampleJob" class="org.springframework.scheduling.quartz.JobDetailFactoryBean"&gt;
    &lt;property name="jobClass" value="example.ExampleJob"/&gt;
    &lt;property name="jobDataAsMap"&gt;
        &lt;map&gt;
            &lt;entry key="timeout" value="5"/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The job detail configuration has all the information it needs to run the job (<code>ExampleJob</code>).
The timeout is specified in the job data map. The job data map is available through the
<code>JobExecutionContext</code> (passed to you at execution time), but the <code>JobDetail</code> also gets
its properties from the job data mapped to properties of the job instance. So, in the following example,
the <code>ExampleJob</code> contains a bean property named <code>timeout</code>, and the <code>JobDetail</code>
has it applied automatically:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package example;

public class ExampleJob extends QuartzJobBean {

    private int timeout;

    /**
     * Setter called after the ExampleJob is instantiated
     * with the value from the JobDetailFactoryBean (5)
     */
    public void setTimeout(int timeout) {
        this.timeout = timeout;
    }

    protected void executeInternal(JobExecutionContext ctx) throws JobExecutionException {
        // do the actual work
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>All additional properties from the job data map are available to you as well.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
By using the <code>name</code> and <code>group</code> properties, you can modify the name and the group
of the job, respectively. By default, the name of the job matches the bean name
of the <code>JobDetailFactoryBean</code> (<code>exampleJob</code> in the preceding example above).
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="scheduling-quartz-method-invoking-job"><a class="anchor" href="#scheduling-quartz-method-invoking-job"></a>7.6.2. Using the <code>MethodInvokingJobDetailFactoryBean</code></h4>
<div class="paragraph">
<p>Often you merely need to invoke a method on a specific object. By using the
<code>MethodInvokingJobDetailFactoryBean</code>, you can do exactly this, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="jobDetail" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"&gt;
    &lt;property name="targetObject" ref="exampleBusinessObject"/&gt;
    &lt;property name="targetMethod" value="doIt"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding example results in the <code>doIt</code> method being called on the
<code>exampleBusinessObject</code> method, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class ExampleBusinessObject {

    // properties and collaborators

    public void doIt() {
        // do the actual work
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="exampleBusinessObject" class="examples.ExampleBusinessObject"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>By using the <code>MethodInvokingJobDetailFactoryBean</code>, you need not create one-line jobs
that merely invoke a method. You need only create the actual business object and
wire up the detail object.</p>
</div>
<div class="paragraph">
<p>By default, Quartz Jobs are stateless, resulting in the possibility of jobs interfering
with each other. If you specify two triggers for the same <code>JobDetail</code>, it is
possible that, before the first job has finished, the second one starts. If
<code>JobDetail</code> classes implement the <code>Stateful</code> interface, this does not happen. The second
job does not start before the first one has finished. To make jobs resulting from the
<code>MethodInvokingJobDetailFactoryBean</code> be non-concurrent, set the <code>concurrent</code> flag to
<code>false</code>, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="jobDetail" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"&gt;
    &lt;property name="targetObject" ref="exampleBusinessObject"/&gt;
    &lt;property name="targetMethod" value="doIt"/&gt;
    &lt;property name="concurrent" value="false"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
By default, jobs will run in a concurrent fashion.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="scheduling-quartz-cron"><a class="anchor" href="#scheduling-quartz-cron"></a>7.6.3. Wiring up Jobs by Using Triggers and <code>SchedulerFactoryBean</code></h4>
<div class="paragraph">
<p>We have created job details and jobs. We have also reviewed the convenience bean that lets
you invoke a method on a specific object. Of course, we still need to schedule the
jobs themselves. This is done by using triggers and a <code>SchedulerFactoryBean</code>. Several
triggers are available within Quartz, and Spring offers two Quartz <code>FactoryBean</code>
implementations with convenient defaults: <code>CronTriggerFactoryBean</code> and
<code>SimpleTriggerFactoryBean</code>.</p>
</div>
<div class="paragraph">
<p>Triggers need to be scheduled. Spring offers a <code>SchedulerFactoryBean</code> that exposes
triggers to be set as properties. <code>SchedulerFactoryBean</code> schedules the actual jobs with
those triggers.</p>
</div>
<div class="paragraph">
<p>The following listing uses both a <code>SimpleTriggerFactoryBean</code> and a <code>CronTriggerFactoryBean</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="simpleTrigger" class="org.springframework.scheduling.quartz.SimpleTriggerFactoryBean"&gt;
    &lt;!-- see the example of method invoking job above --&gt;
    &lt;property name="jobDetail" ref="jobDetail"/&gt;
    &lt;!-- 10 seconds --&gt;
    &lt;property name="startDelay" value="10000"/&gt;
    &lt;!-- repeat every 50 seconds --&gt;
    &lt;property name="repeatInterval" value="50000"/&gt;
&lt;/bean&gt;

&lt;bean id="cronTrigger" class="org.springframework.scheduling.quartz.CronTriggerFactoryBean"&gt;
    &lt;property name="jobDetail" ref="exampleJob"/&gt;
    &lt;!-- run every morning at 6 AM --&gt;
    &lt;property name="cronExpression" value="0 0 6 * * ?"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding example sets up two triggers, one running every 50 seconds with a starting delay of 10
seconds and one running every morning at 6 AM. To finalize everything, we need to set up the
<code>SchedulerFactoryBean</code>, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean class="org.springframework.scheduling.quartz.SchedulerFactoryBean"&gt;
    &lt;property name="triggers"&gt;
        &lt;list&gt;
            &lt;ref bean="cronTrigger"/&gt;
            &lt;ref bean="simpleTrigger"/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>More properties are available for the <code>SchedulerFactoryBean</code>, such as the calendars
used by the job details, properties to customize Quartz with, and others. See the
<a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/scheduling/quartz/SchedulerFactoryBean.html"><code>SchedulerFactoryBean</code></a>
javadoc for more information.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="cache"><a class="anchor" href="#cache"></a>8. Cache Abstraction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Since version 3.1, the Spring Framework provides support for transparently adding caching to
an existing Spring application. Similar to the <a href="data-access.html#transaction">transaction</a>
support, the caching abstraction allows consistent use of various caching solutions with
minimal impact on the code.</p>
</div>
<div class="paragraph">
<p>As from Spring 4.1, the cache abstraction has been significantly extended with the
support of <a href="#cache-jsr-107">JSR-107 annotations</a> and more customization options.</p>
</div>
<div class="sect2">
<h3 id="cache-strategies"><a class="anchor" href="#cache-strategies"></a>8.1. Understanding the Cache Abstraction</h3>
<div class="sidebarblock">
<div class="content">
<div class="title">Cache vs Buffer</div>
<div class="paragraph">
<p>The terms, &#8220;buffer&#8221; and &#8220;cache,&#8221; tend to be used interchangeably. Note, however,
that they represent different things. Traditionally, a buffer is used as an intermediate
temporary store for data between a fast and a slow entity. As one party would have to wait
for the other (which affects performance), the buffer alleviates this by allowing entire
blocks of data to move at once rather than in small chunks. The data is written and read
only once from the buffer. Furthermore, the buffers are visible to at least one party
that is aware of it.</p>
</div>
<div class="paragraph">
<p>A cache, on the other hand, is, by definition, hidden, and neither party is aware that
caching occurs. It also improves performance but does so by letting the same data be
read multiple times in a fast fashion.</p>
</div>
<div class="paragraph">
<p>You can find a further explanation of the differences between a buffer and a cache
<a href="https://en.wikipedia.org/wiki/Cache_(computing)#The_difference_between_buffer_and_cache">here</a>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>At its core, the cache abstraction applies caching to Java methods, thus reducing the
number of executions based on the information available in the cache. That is, each time
a targeted method is invoked, the abstraction applies a caching behavior that checks
whether the method has been already invoked for the given arguments. If it has been
invoked, the cached result is returned without having to invoke the actual method.
If the method has not been invoked, then it is invoked, and the result is cached and
returned to the user so that, the next time the method is invoked, the cached result is
returned. This way, expensive methods (whether CPU- or IO-bound) can be invoked only
once for a given set of parameters and the result reused without having to actually
invoke the method again. The caching logic is applied transparently without any
interference to the invoker.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
This approach works only for methods that are guaranteed to return the same
output (result) for a given input (or arguments) no matter how many times it is invoked.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The caching abstraction provides other cache-related operations, such as the ability
to update the content of the cache or to remove one or all entries. These are useful if
the cache deals with data that can change during the course of the application.</p>
</div>
<div class="paragraph">
<p>As with other services in the Spring Framework, the caching service is an abstraction
(not a cache implementation) and requires the use of actual storage to store the cache data&#8201;&#8212;&#8201;that is, the abstraction frees you from having to write the caching logic but does not
provide the actual data store. This abstraction is materialized by the
<code>org.springframework.cache.Cache</code> and <code>org.springframework.cache.CacheManager</code> interfaces.</p>
</div>
<div class="paragraph">
<p>Spring provides <a href="#cache-store-configuration">a few implementations</a> of that abstraction:
JDK <code>java.util.concurrent.ConcurrentMap</code> based caches, <a href="https://www.ehcache.org/">Ehcache 2.x</a>,
Gemfire cache, <a href="https://github.com/ben-manes/caffeine/wiki">Caffeine</a>, and JSR-107
compliant caches (such as Ehcache 3.x). See <a href="#cache-plug">Plugging-in Different Back-end Caches</a> for more information on
plugging in other cache stores and providers.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The caching abstraction has no special handling for multi-threaded and
multi-process environments, as such features are handled by the cache implementation. .
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you have a multi-process environment (that is, an application deployed on several nodes),
you need to configure your cache provider accordingly. Depending on your use cases, a copy
of the same data on several nodes can be enough. However, if you change the data during
the course of the application, you may need to enable other propagation mechanisms.</p>
</div>
<div class="paragraph">
<p>Caching a particular item is a direct equivalent of the typical get-if-not-found-then-
proceed-and-put-eventually code blocks found with programmatic cache interaction.
No locks are applied, and several threads may try to load the same item concurrently.
The same applies to eviction. If several threads are trying to update or evict data
concurrently, you may use stale data. Certain cache providers offer advanced features
in that area. See the documentation of your cache provider for more details.</p>
</div>
<div class="paragraph">
<p>To use the cache abstraction, you need to take care of two aspects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Caching declaration: Identify the methods that need to be cached and their policy.</p>
</li>
<li>
<p>Cache configuration: The backing cache where the data is stored and from which it is read.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="cache-annotations"><a class="anchor" href="#cache-annotations"></a>8.2. Declarative Annotation-based Caching</h3>
<div class="paragraph">
<p>For caching declaration, Spring&#8217;s caching abstraction provides a set of Java annotations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@Cacheable</code>: Triggers cache population.</p>
</li>
<li>
<p><code>@CacheEvict</code>: Triggers cache eviction.</p>
</li>
<li>
<p><code>@CachePut</code>: Updates the cache without interfering with the method execution.</p>
</li>
<li>
<p><code>@Caching</code>: Regroups multiple cache operations to be applied on a method.</p>
</li>
<li>
<p><code>@CacheConfig</code>: Shares some common cache-related settings at class-level.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="cache-annotations-cacheable"><a class="anchor" href="#cache-annotations-cacheable"></a>8.2.1. The <code>@Cacheable</code> Annotation</h4>
<div class="paragraph">
<p>As the name implies, you can use <code>@Cacheable</code> to demarcate methods that are cacheable&#8201;&#8212;&#8201;that is, methods for which the result is stored in the cache so that, on subsequent
invocations (with the same arguments), the value in the cache is returned without
having to actually invoke the method. In its simplest form, the annotation declaration
requires the name of the cache associated with the annotated method, as the following
example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Cacheable("books")
public Book findBook(ISBN isbn) {...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding snippet, the <code>findBook</code> method is associated with the cache named <code>books</code>.
Each time the method is called, the cache is checked to see whether the invocation has
already been run and does not have to be repeated. While in most cases, only one
cache is declared, the annotation lets multiple names be specified so that more than one
cache is being used. In this case, each of the caches is checked before invoking the
method&#8201;&#8212;&#8201;if at least one cache is hit, the associated value is returned.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
All the other caches that do not contain the value are also updated, even though
the cached method was not actually invoked.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example uses <code>@Cacheable</code> on the <code>findBook</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Cacheable({"books", "isbns"})
public Book findBook(ISBN isbn) {...}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="cache-annotations-cacheable-default-key"><a class="anchor" href="#cache-annotations-cacheable-default-key"></a>Default Key Generation</h5>
<div class="paragraph">
<p>Since caches are essentially key-value stores, each invocation of a cached method
needs to be translated into a suitable key for cache access. The caching abstraction
uses a simple <code>KeyGenerator</code> based on the following algorithm:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If no params are given, return <code>SimpleKey.EMPTY</code>.</p>
</li>
<li>
<p>If only one param is given, return that instance.</p>
</li>
<li>
<p>If more than one param is given, return a <code>SimpleKey</code> that contains all parameters.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This approach works well for most use-cases, as long as parameters have natural keys
and implement valid <code>hashCode()</code> and <code>equals()</code> methods. If that is not the case,
you need to change the strategy.</p>
</div>
<div class="paragraph">
<p>To provide a different default key generator, you need to implement the
<code>org.springframework.cache.interceptor.KeyGenerator</code> interface.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The default key generation strategy changed with the release of Spring 4.0. Earlier
versions of Spring used a key generation strategy that, for multiple key parameters,
considered only the <code>hashCode()</code> of parameters and not <code>equals()</code>. This could cause
unexpected key collisions (see <a href="https://jira.spring.io/browse/SPR-10237">SPR-10237</a>
for background). The new <code>SimpleKeyGenerator</code> uses a compound key for such scenarios.</p>
</div>
<div class="paragraph">
<p>If you want to keep using the previous key strategy, you can configure the deprecated
<code>org.springframework.cache.interceptor.DefaultKeyGenerator</code> class or create a custom
hash-based <code>KeyGenerator</code> implementation.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="cache-annotations-cacheable-key"><a class="anchor" href="#cache-annotations-cacheable-key"></a>Custom Key Generation Declaration</h5>
<div class="paragraph">
<p>Since caching is generic, the target methods are quite likely to have various signatures
that cannot be readily mapped on top of the cache structure. This tends to become obvious
when the target method has multiple arguments out of which only some are suitable for
caching (while the rest are used only by the method logic). Consider the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Cacheable("books")
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)</code></pre>
</div>
</div>
<div class="paragraph">
<p>At first glance, while the two <code>boolean</code> arguments influence the way the book is found,
they are no use for the cache. Furthermore, what if only one of the two is important
while the other is not?</p>
</div>
<div class="paragraph">
<p>For such cases, the <code>@Cacheable</code> annotation lets you specify how the key is generated
through its <code>key</code> attribute. You can use <a href="core.html#expressions">SpEL</a> to pick the
arguments of interest (or their nested properties), perform operations, or even
invoke arbitrary methods without having to write any code or implement any interface.
This is the recommended approach over the
<a href="#cache-annotations-cacheable-default-key">default generator</a>, since methods tend to be
quite different in signatures as the code base grows. While the default strategy might
work for some methods, it rarely works for all methods.</p>
</div>
<div class="paragraph">
<p>The following examples use various SpEL declarations (if you are not familiar with SpEL,
do yourself a favor and read <a href="core.html#expressions">Spring Expression Language</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Cacheable(cacheNames="books", key="#isbn")
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)

@Cacheable(cacheNames="books", key="#isbn.rawNumber")
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)

@Cacheable(cacheNames="books", key="T(someType).hash(#isbn)")
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding snippets show how easy it is to select a certain argument, one of its
properties, or even an arbitrary (static) method.</p>
</div>
<div class="paragraph">
<p>If the algorithm responsible for generating the key is too specific or if it needs
to be shared, you can define a custom <code>keyGenerator</code> on the operation. To do so,
specify the name of the <code>KeyGenerator</code> bean implementation to use, as the following
example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Cacheable(cacheNames="books", keyGenerator="myKeyGenerator")
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>key</code> and <code>keyGenerator</code> parameters are mutually exclusive and an operation
that specifies both results in an exception.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="cache-annotations-cacheable-default-cache-resolver"><a class="anchor" href="#cache-annotations-cacheable-default-cache-resolver"></a>Default Cache Resolution</h5>
<div class="paragraph">
<p>The caching abstraction uses a simple <code>CacheResolver</code> that
retrieves the caches defined at the operation level by using the configured
<code>CacheManager</code>.</p>
</div>
<div class="paragraph">
<p>To provide a different default cache resolver, you need to implement the
<code>org.springframework.cache.interceptor.CacheResolver</code> interface.</p>
</div>
</div>
<div class="sect4">
<h5 id="cache-annotations-cacheable-cache-resolver"><a class="anchor" href="#cache-annotations-cacheable-cache-resolver"></a>Custom Cache Resolution</h5>
<div class="paragraph">
<p>The default cache resolution fits well for applications that work with a
single <code>CacheManager</code> and have no complex cache resolution requirements.</p>
</div>
<div class="paragraph">
<p>For applications that work with several cache managers, you can set the
<code>cacheManager</code> to use for each operation, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Cacheable(cacheNames="books", cacheManager="anotherCacheManager") <i class="conum" data-value="1"></i><b>(1)</b>
public Book findBook(ISBN isbn) {...}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Specifying <code>anotherCacheManager</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can also replace the <code>CacheResolver</code> entirely in a fashion similar to that of
replacing <a href="#cache-annotations-cacheable-key">key generation</a>. The resolution is
requested for every cache operation, letting the implementation actually resolve
the caches to use based on runtime arguments. The following example shows how to
specify a <code>CacheResolver</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Cacheable(cacheResolver="runtimeCacheResolver") <i class="conum" data-value="1"></i><b>(1)</b>
public Book findBook(ISBN isbn) {...}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Specifying the <code>CacheResolver</code>.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Since Spring 4.1, the <code>value</code> attribute of the cache annotations are no longer
mandatory, since this particular information can be provided by the <code>CacheResolver</code>
regardless of the content of the annotation.</p>
</div>
<div class="paragraph">
<p>Similarly to <code>key</code> and <code>keyGenerator</code>, the <code>cacheManager</code> and <code>cacheResolver</code>
parameters are mutually exclusive, and an operation specifying both
results in an exception, as a custom <code>CacheManager</code> is ignored by the
<code>CacheResolver</code> implementation. This is probably not what you expect.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="cache-annotations-cacheable-synchronized"><a class="anchor" href="#cache-annotations-cacheable-synchronized"></a>Synchronized Caching</h5>
<div class="paragraph">
<p>In a multi-threaded environment, certain operations might be concurrently invoked for
the same argument (typically on startup). By default, the cache abstraction does not
lock anything, and the same value may be computed several times, defeating the purpose
of caching.</p>
</div>
<div class="paragraph">
<p>For those particular cases, you can use the <code>sync</code> attribute to instruct the underlying
cache provider to lock the cache entry while the value is being computed. As a result,
only one thread is busy computing the value, while the others are blocked until the entry
is updated in the cache. The following example shows how to use the <code>sync</code> attribute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Cacheable(cacheNames="foos", sync=true) <i class="conum" data-value="1"></i><b>(1)</b>
public Foo executeExpensiveOperation(String id) {...}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using the <code>sync</code> attribute.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This is an optional feature, and your favorite cache library may not support it.
All <code>CacheManager</code> implementations provided by the core framework support it. See the
documentation of your cache provider for more details.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="cache-annotations-cacheable-condition"><a class="anchor" href="#cache-annotations-cacheable-condition"></a>Conditional Caching</h5>
<div class="paragraph">
<p>Sometimes, a method might not be suitable for caching all the time (for example, it might
depend on the given arguments). The cache annotations support such use cases through the
<code>condition</code> parameter, which takes a <code>SpEL</code> expression that is evaluated to either <code>true</code>
or <code>false</code>. If <code>true</code>, the method is cached. If not, it behaves as if the method is not
cached (that is, the method is invoked every time no matter what values are in the cache
or what arguments are used). For example, the following method is cached only if the
argument <code>name</code> has a length shorter than 32:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Cacheable(cacheNames="book", condition="#name.length() &lt; 32") <i class="conum" data-value="1"></i><b>(1)</b>
public Book findBook(String name)</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Setting a condition on <code>@Cacheable</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In addition to the <code>condition</code> parameter, you can use the <code>unless</code> parameter to veto the
adding of a value to the cache. Unlike <code>condition</code>, <code>unless</code> expressions are evaluated
after the method has been invoked. To expand on the previous example, perhaps we only
want to cache paperback books, as the following example does:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Cacheable(cacheNames="book", condition="#name.length() &lt; 32", unless="#result.hardback") <i class="conum" data-value="1"></i><b>(1)</b>
public Book findBook(String name)</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using the <code>unless</code> attribute to block hardbacks.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The cache abstraction supports <code>java.util.Optional</code>, using its content as the cached value
only if it is present. <code>#result</code> always refers to the business entity and never a
supported wrapper, so the previous example can be rewritten as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Cacheable(cacheNames="book", condition="#name.length() &lt; 32", unless="#result?.hardback")
public Optional&lt;Book&gt; findBook(String name)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that <code>result</code> still refers to <code>Book</code> and not <code>Optional</code>. As it might be <code>null</code>, we
should use the safe navigation operator.</p>
</div>
</div>
<div class="sect4">
<h5 id="cache-spel-context"><a class="anchor" href="#cache-spel-context"></a>Available Caching SpEL Evaluation Context</h5>
<div class="paragraph">
<p>Each <code>SpEL</code> expression evaluates against a dedicated <a href="core.html#expressions-language-ref"><code>context</code></a>.
In addition to the built-in parameters, the framework provides dedicated caching-related
metadata, such as the argument names. The following table describes the items made
available to the context so that you can use them for key and conditional computations:</p>
</div>
<table id="cache-spel-context-tbl" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 9. Cache SpEL available metadata</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Location</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>methodName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Root object</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The name of the method being invoked</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#root.methodName</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>method</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Root object</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The method being invoked</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#root.method.name</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>target</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Root object</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The target object being invoked</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#root.target</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>targetClass</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Root object</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The class of the target being invoked</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#root.targetClass</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>args</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Root object</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The arguments (as array) used for invoking the target</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#root.args[0]</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>caches</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Root object</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Collection of caches against which the current method is run</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#root.caches[0].name</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Argument name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Evaluation context</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Name of any of the method arguments. If the names are not available
  (perhaps due to having no debug information), the argument names are also available under the <code>#a&lt;#arg&gt;</code>
  where <code>#arg</code> stands for the argument index (starting from <code>0</code>).</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#iban</code> or <code>#a0</code> (you can also use <code>#p0</code> or <code>#p&lt;#arg&gt;</code> notation as an alias).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>result</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Evaluation context</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The result of the method call (the value to be cached). Only available in <code>unless</code>
  expressions, <code>cache put</code> expressions (to compute the <code>key</code>), or <code>cache evict</code>
  expressions (when <code>beforeInvocation</code> is <code>false</code>). For supported wrappers (such as
  <code>Optional</code>), <code>#result</code> refers to the actual object, not the wrapper.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#result</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="cache-annotations-put"><a class="anchor" href="#cache-annotations-put"></a>8.2.2. The <code>@CachePut</code> Annotation</h4>
<div class="paragraph">
<p>When the cache needs to be updated without interfering with the method execution,
you can use the <code>@CachePut</code> annotation. That is, the method is always invoked and its
result is placed into the cache (according to the <code>@CachePut</code> options). It supports
the same options as <code>@Cacheable</code> and should be used for cache population rather than
method flow optimization. The following example uses the <code>@CachePut</code> annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@CachePut(cacheNames="book", key="#isbn")
public Book updateBook(ISBN isbn, BookDescriptor descriptor)</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Using <code>@CachePut</code> and <code>@Cacheable</code> annotations on the same method is generally
strongly discouraged because they have different behaviors. While the latter causes the
method invocation to be skipped by using the cache, the former forces the invocation in
order to run a cache update. This leads to unexpected behavior and, with the exception
of specific corner-cases (such as annotations having conditions that exclude them from each
other), such declarations should be avoided. Note also that such conditions should not rely
on the result object (that is, the <code>#result</code> variable), as these are validated up-front to
confirm the exclusion.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="cache-annotations-evict"><a class="anchor" href="#cache-annotations-evict"></a>8.2.3. The <code>@CacheEvict</code> annotation</h4>
<div class="paragraph">
<p>The cache abstraction allows not just population of a cache store but also eviction.
This process is useful for removing stale or unused data from the cache. As opposed to
<code>@Cacheable</code>, <code>@CacheEvict</code> demarcates methods that perform cache
eviction (that is, methods that act as triggers for removing data from the cache).
Similarly to its sibling, <code>@CacheEvict</code> requires specifying one or more caches
that are affected by the action, allows a custom cache and key resolution or a
condition to be specified, and features an extra parameter
(<code>allEntries</code>) that indicates whether a cache-wide eviction needs to be performed
rather than just an entry eviction (based on the key). The following example evicts
all entries from the <code>books</code> cache:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@CacheEvict(cacheNames="books", allEntries=true) <i class="conum" data-value="1"></i><b>(1)</b>
public void loadBooks(InputStream batch)</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using the <code>allEntries</code> attribute to evict all entries from the cache.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This option comes in handy when an entire cache region needs to be cleared out.
Rather than evicting each entry (which would take a long time, since it is inefficient),
all the entries are removed in one operation, as the preceding example shows.
Note that the framework ignores any key specified in this scenario as it does not apply
(the entire cache is evicted, not only one entry).</p>
</div>
<div class="paragraph">
<p>You can also indicate whether the eviction should occur after (the default) or before
the method is invoked by using the <code>beforeInvocation</code> attribute. The former provides the
same semantics as the rest of the annotations: Once the method completes successfully,
an action (in this case, eviction) on the cache is run. If the method does not
run (as it might be cached) or an exception is thrown, the eviction does not occur.
The latter (<code>beforeInvocation=true</code>) causes the eviction to always occur before the
method is invoked. This is useful in cases where the eviction does not need to be tied
to the method outcome.</p>
</div>
<div class="paragraph">
<p>Note that <code>void</code> methods can be used with <code>@CacheEvict</code> - as the methods act as a
trigger, the return values are ignored (as they do not interact with the cache). This is
not the case with <code>@Cacheable</code> which adds data to the cache or updates data in the cache
and, thus, requires a result.</p>
</div>
</div>
<div class="sect3">
<h4 id="cache-annotations-caching"><a class="anchor" href="#cache-annotations-caching"></a>8.2.4. The <code>@Caching</code> Annotation</h4>
<div class="paragraph">
<p>Sometimes, multiple annotations of the same type (such as <code>@CacheEvict</code> or
<code>@CachePut</code>) need to be specified&#8201;&#8212;&#8201;for example, because the condition or the key
expression is different between different caches. <code>@Caching</code> lets multiple nested
<code>@Cacheable</code>, <code>@CachePut</code>, and <code>@CacheEvict</code> annotations be used on the same method.
The following example uses two <code>@CacheEvict</code> annotations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Caching(evict = { @CacheEvict("primary"), @CacheEvict(cacheNames="secondary", key="#p0") })
public Book importBooks(String deposit, Date date)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="cache-annotations-config"><a class="anchor" href="#cache-annotations-config"></a>8.2.5. The <code>@CacheConfig</code> annotation</h4>
<div class="paragraph">
<p>So far, we have seen that caching operations offer many customization options and that
you can set these options for each operation. However, some of the customization options
can be tedious to configure if they apply to all operations of the class. For
instance, specifying the name of the cache to use for every cache operation of the
class can be replaced by a single class-level definition. This is where <code>@CacheConfig</code>
comes into play. The following examples uses <code>@CacheConfig</code> to set the name of the cache:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@CacheConfig("books") <i class="conum" data-value="1"></i><b>(1)</b>
public class BookRepositoryImpl implements BookRepository {

    @Cacheable
    public Book findBook(ISBN isbn) {...}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using <code>@CacheConfig</code> to set the name of the cache.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>@CacheConfig</code> is a class-level annotation that allows sharing the cache names,
the custom <code>KeyGenerator</code>, the custom <code>CacheManager</code>, and the custom <code>CacheResolver</code>.
Placing this annotation on the class does not turn on any caching operation.</p>
</div>
<div class="paragraph">
<p>An operation-level customization always overrides a customization set on <code>@CacheConfig</code>.
Therefore, this gives three levels of customizations for each cache operation:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Globally configured, available for <code>CacheManager</code>, <code>KeyGenerator</code>.</p>
</li>
<li>
<p>At the class level, using <code>@CacheConfig</code>.</p>
</li>
<li>
<p>At the operation level.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="cache-annotation-enable"><a class="anchor" href="#cache-annotation-enable"></a>8.2.6. Enabling Caching Annotations</h4>
<div class="paragraph">
<p>It is important to note that even though declaring the cache annotations does not
automatically trigger their actions - like many things in Spring, the feature has to be
declaratively enabled (which means if you ever suspect caching is to blame, you can
disable it by removing only one configuration line rather than all the annotations in
your code).</p>
</div>
<div class="paragraph">
<p>To enable caching annotations add the annotation <code>@EnableCaching</code> to one of your
<code>@Configuration</code> classes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
@EnableCaching
public class AppConfig {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, for XML configuration you can use the <code>cache:annotation-driven</code> element:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:cache="http://www.springframework.org/schema/cache"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/cache https://www.springframework.org/schema/cache/spring-cache.xsd"&gt;

        &lt;cache:annotation-driven/&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Both the <code>cache:annotation-driven</code> element and the <code>@EnableCaching</code> annotation let you
specify various options that influence the way the caching behavior is added to the
application through AOP. The configuration is intentionally similar with that of
<a href="data-access.html#tx-annotation-driven-settings"><code>@Transactional</code></a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The default advice mode for processing caching annotations is <code>proxy</code>, which allows
for interception of calls through the proxy only. Local calls within the same class
cannot get intercepted that way. For a more advanced mode of interception, consider
switching to <code>aspectj</code> mode in combination with compile-time or load-time weaving.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For more detail about advanced customizations (using Java configuration) that are
required to implement <code>CachingConfigurer</code>, see the
<a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/cache/annotation/CachingConfigurer.html">javadoc</a>.
</td>
</tr>
</table>
</div>
<table id="cache-annotation-driven-settings" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 10. Cache annotation settings</caption>
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 50.0002%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">XML Attribute</th>
<th class="tableblock halign-left valign-top">Annotation Attribute</th>
<th class="tableblock halign-left valign-top">Default</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cache-manager</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N/A (see the <a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/cache/annotation/CachingConfigurer.html"><code>CachingConfigurer</code></a> javadoc)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cacheManager</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The name of the cache manager to use. A default <code>CacheResolver</code> is initialized behind
  the scenes with this cache manager (or <code>cacheManager</code> if not set). For more
  fine-grained management of the cache resolution, consider setting the 'cache-resolver'
  attribute.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cache-resolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N/A (see the <a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/cache/annotation/CachingConfigurer.html"><code>CachingConfigurer</code></a> javadoc)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A <code>SimpleCacheResolver</code> using the configured <code>cacheManager</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The bean name of the CacheResolver that is to be used to resolve the backing caches.
  This attribute is not required and needs to be specified only as an alternative to
  the 'cache-manager' attribute.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>key-generator</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N/A (see the <a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/cache/annotation/CachingConfigurer.html"><code>CachingConfigurer</code></a> javadoc)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SimpleKeyGenerator</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Name of the custom key generator to use.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>error-handler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N/A (see the <a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/cache/annotation/CachingConfigurer.html"><code>CachingConfigurer</code></a> javadoc)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SimpleCacheErrorHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The name of the custom cache error handler to use. By default, any exception thrown during
  a cache related operation is thrown back at the client.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mode</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mode</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>proxy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The default mode (<code>proxy</code>) processes annotated beans to be proxied by using Spring&#8217;s AOP
  framework (following proxy semantics, as discussed earlier, applying to method calls
  coming in through the proxy only). The alternative mode (<code>aspectj</code>) instead weaves the
  affected classes with Spring&#8217;s AspectJ caching aspect, modifying the target class byte
  code to apply to any kind of method call. AspectJ weaving requires <code>spring-aspects.jar</code>
  in the classpath as well as load-time weaving (or compile-time weaving) enabled. (See
  <a href="core.html#aop-aj-ltw-spring">Spring configuration</a> for details on how to set up
  load-time weaving.)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>proxy-target-class</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>proxyTargetClass</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Applies to proxy mode only. Controls what type of caching proxies are created for
  classes annotated with the <code>@Cacheable</code> or <code>@CacheEvict</code> annotations. If the
  <code>proxy-target-class</code> attribute is set to <code>true</code>, class-based proxies are created.
  If <code>proxy-target-class</code> is <code>false</code> or if the attribute is omitted, standard JDK
  interface-based proxies are created. (See <a href="core.html#aop-proxying">Proxying Mechanisms</a>
  for a detailed examination of the different proxy types.)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>order</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>order</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ordered.LOWEST_PRECEDENCE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Defines the order of the cache advice that is applied to beans annotated with
  <code>@Cacheable</code> or <code>@CacheEvict</code>. (For more information about the rules related to
  ordering AOP advice, see <a href="core.html#aop-ataspectj-advice-ordering">Advice Ordering</a>.)
  No specified ordering means that the AOP subsystem determines the order of the advice.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>&lt;cache:annotation-driven/&gt;</code> looks for <code>@Cacheable/@CachePut/@CacheEvict/@Caching</code>
only on beans in the same application context in which it is defined. This means that,
if you put <code>&lt;cache:annotation-driven/&gt;</code> in a <code>WebApplicationContext</code> for a
<code>DispatcherServlet</code>, it checks for beans only in your controllers, not your services.
See <a href="web.html#mvc-servlet">the MVC section</a> for more information.
</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Method visibility and cache annotations</div>
<div class="paragraph">
<p>When you use proxies, you should apply the cache annotations only to methods with
public visibility. If you do annotate protected, private, or package-visible methods
with these annotations, no error is raised, but the annotated method does not exhibit
the configured caching settings. Consider using AspectJ (see the rest of this section)
if you need to annotate non-public methods, as it changes the bytecode itself.</p>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Spring recommends that you only annotate concrete classes (and methods of concrete
classes) with the <code>@Cache*</code> annotation, as opposed to annotating interfaces.
You certainly can place the <code>@Cache*</code> annotation on an interface (or an interface
method), but this works only as you would expect it to if you use interface-based proxies.
The fact that Java annotations are not inherited from interfaces means that, if you use
class-based proxies (<code>proxy-target-class="true"</code>) or the weaving-based aspect
(<code>mode="aspectj"</code>), the caching settings are not recognized by the proxying and weaving
infrastructure, and the object is not wrapped in a caching proxy.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In proxy mode (the default), only external method calls coming in through the
proxy are intercepted. This means that self-invocation (in effect, a method within the
target object that calls another method of the target object) does not lead to actual
caching at runtime even if the invoked method is marked with <code>@Cacheable</code>. Consider
using the <code>aspectj</code> mode in this case. Also, the proxy must be fully initialized to
provide the expected behavior, so you should not rely on this feature in your
initialization code (that is, <code>@PostConstruct</code>).
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="cache-annotation-stereotype"><a class="anchor" href="#cache-annotation-stereotype"></a>8.2.7. Using Custom Annotations</h4>
<div class="sidebarblock">
<div class="content">
<div class="title">Custom annotation and AspectJ</div>
<div class="paragraph">
<p>This feature works only with the proxy-based approach but can be enabled
with a bit of extra effort by using AspectJ.</p>
</div>
<div class="paragraph">
<p>The <code>spring-aspects</code> module defines an aspect for the standard annotations only.
If you have defined your own annotations, you also need to define an aspect for
those. Check <code>AnnotationCacheAspect</code> for an example.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>The caching abstraction lets you use your own annotations to identify what method
triggers cache population or eviction. This is quite handy as a template mechanism,
as it eliminates the need to duplicate cache annotation declarations, which is
especially useful if the key or condition are specified or if the foreign imports
(<code>org.springframework</code>) are not allowed in your code base. Similarly to the rest
of the <a href="core.html#beans-stereotype-annotations">stereotype</a> annotations, you can
use <code>@Cacheable</code>, <code>@CachePut</code>, <code>@CacheEvict</code>, and <code>@CacheConfig</code> as
<a href="core.html#beans-meta-annotations">meta-annotations</a> (that is, annotations that
can annotate other annotations). In the following example, we replace a common
<code>@Cacheable</code> declaration with our own custom annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD})
@Cacheable(cacheNames="books", key="#isbn")
public @interface SlowService {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, we have defined our own <code>SlowService</code> annotation,
which itself is annotated with <code>@Cacheable</code>. Now we can replace the following code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Cacheable(cacheNames="books", key="#isbn")
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows the custom annotation with which we can replace the
preceding code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SlowService
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Even though <code>@SlowService</code> is not a Spring annotation, the container automatically picks
up its declaration at runtime and understands its meaning. Note that, as mentioned
<a href="#cache-annotation-enable">earlier</a>, annotation-driven behavior needs to be enabled.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cache-jsr-107"><a class="anchor" href="#cache-jsr-107"></a>8.3. JCache (JSR-107) Annotations</h3>
<div class="paragraph">
<p>Since version 4.1, Spring&#8217;s caching abstraction fully supports the JCache standard
annotations: <code>@CacheResult</code>, <code>@CachePut</code>, <code>@CacheRemove</code>, and <code>@CacheRemoveAll</code>
as well as the <code>@CacheDefaults</code>, <code>@CacheKey</code>, and <code>@CacheValue</code> companions.
You can use these annotations even without migrating your cache store to JSR-107.
The internal implementation uses Spring&#8217;s caching abstraction and provides default
<code>CacheResolver</code> and <code>KeyGenerator</code> implementations that are compliant with the
specification. In other words, if you are already using Spring&#8217;s caching abstraction,
you can switch to these standard annotations without changing your cache storage
(or configuration, for that matter).</p>
</div>
<div class="sect3">
<h4 id="cache-jsr-107-summary"><a class="anchor" href="#cache-jsr-107-summary"></a>8.3.1. Feature Summary</h4>
<div class="paragraph">
<p>For those who are familiar with Spring&#8217;s caching annotations, the following table
describes the main differences between the Spring annotations and the JSR-107
counterpart:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 11. Spring vs. JSR-107 caching annotations</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 60%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Spring</th>
<th class="tableblock halign-left valign-top">JSR-107</th>
<th class="tableblock halign-left valign-top">Remark</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@Cacheable</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@CacheResult</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fairly similar. <code>@CacheResult</code> can cache specific exceptions and force the
  execution of the method regardless of the content of the cache.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@CachePut</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@CachePut</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">While Spring updates the cache with the result of the method invocation, JCache
  requires that it be passed it as an argument that is annotated with <code>@CacheValue</code>.
  Due to this difference, JCache allows updating the cache before or after the
  actual method invocation.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@CacheEvict</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@CacheRemove</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fairly similar. <code>@CacheRemove</code> supports conditional eviction when the
  method invocation results in an exception.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@CacheEvict(allEntries=true)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@CacheRemoveAll</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See <code>@CacheRemove</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@CacheConfig</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@CacheDefaults</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Lets you configure the same concepts, in a similar fashion.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>JCache has the notion of <code>javax.cache.annotation.CacheResolver</code>, which is identical
to the Spring&#8217;s <code>CacheResolver</code> interface, except that JCache supports only a single
cache. By default, a simple implementation retrieves the cache to use based on the
name declared on the annotation. It should be noted that, if no cache name is
specified on the annotation, a default is automatically generated. See the javadoc
of <code>@CacheResult#cacheName()</code> for more information.</p>
</div>
<div class="paragraph">
<p><code>CacheResolver</code> instances are retrieved by a <code>CacheResolverFactory</code>. It is possible
to customize the factory for each cache operation, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@CacheResult(cacheNames="books", cacheResolverFactory=MyCacheResolverFactory.class) <i class="conum" data-value="1"></i><b>(1)</b>
public Book findBook(ISBN isbn)</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Customizing the factory for this operation.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For all referenced classes, Spring tries to locate a bean with the given type.
If more than one match exists, a new instance is created and can use the regular
bean lifecycle callbacks, such as dependency injection.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Keys are generated by a <code>javax.cache.annotation.CacheKeyGenerator</code> that serves the
same purpose as Spring&#8217;s <code>KeyGenerator</code>. By default, all method arguments are taken
into account, unless at least one parameter is annotated with <code>@CacheKey</code>. This is
similar to Spring&#8217;s <a href="#cache-annotations-cacheable-key">custom key generation
declaration</a>. For instance, the following are identical operations, one using
Spring&#8217;s abstraction and the other using JCache:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Cacheable(cacheNames="books", key="#isbn")
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)

@CacheResult(cacheName="books")
public Book findBook(@CacheKey ISBN isbn, boolean checkWarehouse, boolean includeUsed)</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also specify the <code>CacheKeyResolver</code> on the operation, similar to how you can
specify the <code>CacheResolverFactory</code>.</p>
</div>
<div class="paragraph">
<p>JCache can manage exceptions thrown by annotated methods. This can prevent an update of
the cache, but it can also cache the exception as an indicator of the failure instead of
calling the method again. Assume that <code>InvalidIsbnNotFoundException</code> is thrown if the
structure of the ISBN is invalid. This is a permanent failure (no book could ever be
retrieved with such a parameter). The following caches the exception so that further
calls with the same, invalid, ISBN throw the cached exception directly instead of
invoking the method again:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@CacheResult(cacheName="books", exceptionCacheName="failures"
            cachedExceptions = InvalidIsbnNotFoundException.class)
public Book findBook(ISBN isbn)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="enabling-jsr-107-support"><a class="anchor" href="#enabling-jsr-107-support"></a>8.3.2. Enabling JSR-107 Support</h4>
<div class="paragraph">
<p>You need do nothing specific to enable the JSR-107 support alongside Spring&#8217;s
declarative annotation support. Both <code>@EnableCaching</code> and the
<code>cache:annotation-driven</code> element automatically enable the JCache support
if both the JSR-107 API and the <code>spring-context-support</code> module are present
in the classpath.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Depending on your use case, the choice is basically yours. You can even
mix and match services by using the JSR-107 API on some and using Spring&#8217;s own
annotations on others. However, if these services impact the same caches,
you should use a consistent and identical key generation implementation.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cache-declarative-xml"><a class="anchor" href="#cache-declarative-xml"></a>8.4. Declarative XML-based Caching</h3>
<div class="paragraph">
<p>If annotations are not an option (perhaps due to having no access to the sources
or no external code), you can use XML for declarative caching. So, instead of
annotating the methods for caching, you can specify the target method and the
caching directives externally (similar to the declarative transaction management
<a href="data-access.html#transaction-declarative-first-example">advice</a>). The example
from the previous section can be translated into the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;!-- the service we want to make cacheable --&gt;
&lt;bean id="bookService" class="x.y.service.DefaultBookService"/&gt;

&lt;!-- cache definitions --&gt;
&lt;cache:advice id="cacheAdvice" cache-manager="cacheManager"&gt;
    &lt;cache:caching cache="books"&gt;
        &lt;cache:cacheable method="findBook" key="#isbn"/&gt;
        &lt;cache:cache-evict method="loadBooks" all-entries="true"/&gt;
    &lt;/cache:caching&gt;
&lt;/cache:advice&gt;

&lt;!-- apply the cacheable behavior to all BookService interfaces --&gt;
&lt;aop:config&gt;
    &lt;aop:advisor advice-ref="cacheAdvice" pointcut="execution(* x.y.BookService.*(..))"/&gt;
&lt;/aop:config&gt;

&lt;!-- cache manager definition omitted --&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding configuration, the <code>bookService</code> is made cacheable. The caching semantics
to apply are encapsulated in the <code>cache:advice</code> definition, which causes the <code>findBooks</code>
method to be used for putting data into the cache and the <code>loadBooks</code> method for evicting
data. Both definitions work against the <code>books</code> cache.</p>
</div>
<div class="paragraph">
<p>The <code>aop:config</code> definition applies the cache advice to the appropriate points in the
program by using the AspectJ pointcut expression (more information is available in
<a href="core.html#aop">Aspect Oriented Programming with Spring</a>). In the preceding example,
all methods from the <code>BookService</code> are considered and the cache advice is applied to them.</p>
</div>
<div class="paragraph">
<p>The declarative XML caching supports all of the annotation-based model, so moving between
the two should be fairly easy. Furthermore, both can be used inside the same application.
The XML-based approach does not touch the target code. However, it is inherently more
verbose. When dealing with classes that have overloaded methods that are targeted for
caching, identifying the proper methods does take an extra effort, since the <code>method</code>
argument is not a good discriminator. In these cases, you can use the AspectJ pointcut
to cherry pick the target methods and apply the appropriate caching functionality.
However, through XML, it is easier to apply package or group or interface-wide caching
(again, due to the AspectJ pointcut) and to create template-like definitions (as we did
in the preceding example by defining the target cache through the <code>cache:definitions</code>
<code>cache</code> attribute).</p>
</div>
</div>
<div class="sect2">
<h3 id="cache-store-configuration"><a class="anchor" href="#cache-store-configuration"></a>8.5. Configuring the Cache Storage</h3>
<div class="paragraph">
<p>The cache abstraction provides several storage integration options. To use them, you need
to declare an appropriate <code>CacheManager</code> (an entity that controls and manages <code>Cache</code>
instances and that can be used to retrieve these for storage).</p>
</div>
<div class="sect3">
<h4 id="cache-store-configuration-jdk"><a class="anchor" href="#cache-store-configuration-jdk"></a>8.5.1. JDK <code>ConcurrentMap</code>-based Cache</h4>
<div class="paragraph">
<p>The JDK-based <code>Cache</code> implementation resides under
<code>org.springframework.cache.concurrent</code> package. It lets you use <code>ConcurrentHashMap</code>
as a backing <code>Cache</code> store. The following example shows how to configure two caches:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;!-- simple cache manager --&gt;
&lt;bean id="cacheManager" class="org.springframework.cache.support.SimpleCacheManager"&gt;
    &lt;property name="caches"&gt;
        &lt;set&gt;
            &lt;bean class="org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean" p:name="default"/&gt;
            &lt;bean class="org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean" p:name="books"/&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding snippet uses the <code>SimpleCacheManager</code> to create a <code>CacheManager</code> for the
two nested <code>ConcurrentMapCache</code> instances named <code>default</code> and <code>books</code>. Note that the
names are configured directly for each cache.</p>
</div>
<div class="paragraph">
<p>As the cache is created by the application, it is bound to its lifecycle, making it
suitable for basic use cases, tests, or simple applications. The cache scales well
and is very fast, but it does not provide any management, persistence capabilities,
or eviction contracts.</p>
</div>
</div>
<div class="sect3">
<h4 id="cache-store-configuration-ehcache"><a class="anchor" href="#cache-store-configuration-ehcache"></a>8.5.2. Ehcache-based Cache</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Ehcache 3.x is fully JSR-107 compliant and no dedicated support is required for it.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The Ehcache 2.x implementation is located in the <code>org.springframework.cache.ehcache</code>
package. Again, to use it, you need to declare the appropriate <code>CacheManager</code>.
The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="cacheManager"
        class="org.springframework.cache.ehcache.EhCacheCacheManager" p:cache-manager-ref="ehcache"/&gt;

&lt;!-- EhCache library setup --&gt;
&lt;bean id="ehcache"
        class="org.springframework.cache.ehcache.EhCacheManagerFactoryBean" p:config-location="ehcache.xml"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This setup bootstraps the ehcache library inside the Spring IoC (through the <code>ehcache</code>
bean), which is then wired into the dedicated <code>CacheManager</code> implementation. Note that
the entire Ehcache-specific configuration is read from <code>ehcache.xml</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="cache-store-configuration-caffeine"><a class="anchor" href="#cache-store-configuration-caffeine"></a>8.5.3. Caffeine Cache</h4>
<div class="paragraph">
<p>Caffeine is a Java 8 rewrite of Guava&#8217;s cache, and its implementation is located in the
<code>org.springframework.cache.caffeine</code> package and provides access to several features
of Caffeine.</p>
</div>
<div class="paragraph">
<p>The following example configures a <code>CacheManager</code> that creates the cache on demand:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="cacheManager"
        class="org.springframework.cache.caffeine.CaffeineCacheManager"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also provide the caches to use explicitly. In that case, only those
are made available by the manager. The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="cacheManager" class="org.springframework.cache.caffeine.CaffeineCacheManager"&gt;
    &lt;property name="caches"&gt;
        &lt;set&gt;
            &lt;value&gt;default&lt;/value&gt;
            &lt;value&gt;books&lt;/value&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Caffeine <code>CacheManager</code> also supports custom <code>Caffeine</code> and <code>CacheLoader</code>.
See the <a href="https://github.com/ben-manes/caffeine/wiki">Caffeine documentation</a>
for more information about those.</p>
</div>
</div>
<div class="sect3">
<h4 id="cache-store-configuration-gemfire"><a class="anchor" href="#cache-store-configuration-gemfire"></a>8.5.4. GemFire-based Cache</h4>
<div class="paragraph">
<p>GemFire is a memory-oriented, disk-backed, elastically scalable, continuously available,
active (with built-in pattern-based subscription notifications), globally replicated
database and provides fully-featured edge caching. For further information on how to
use GemFire as a <code>CacheManager</code> (and more), see the
<a href="https://docs.spring.io/spring-gemfire/docs/current/reference/html/">Spring Data GemFire reference documentation</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="cache-store-configuration-jsr107"><a class="anchor" href="#cache-store-configuration-jsr107"></a>8.5.5. JSR-107 Cache</h4>
<div class="paragraph">
<p>Spring&#8217;s caching abstraction can also use JSR-107-compliant caches. The JCache
implementation is located in the <code>org.springframework.cache.jcache</code> package.</p>
</div>
<div class="paragraph">
<p>Again, to use it, you need to declare the appropriate <code>CacheManager</code>.
The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="cacheManager"
        class="org.springframework.cache.jcache.JCacheCacheManager"
        p:cache-manager-ref="jCacheManager"/&gt;

&lt;!-- JSR-107 cache manager setup  --&gt;
&lt;bean id="jCacheManager" .../&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="cache-store-configuration-noop"><a class="anchor" href="#cache-store-configuration-noop"></a>8.5.6. Dealing with Caches without a Backing Store</h4>
<div class="paragraph">
<p>Sometimes, when switching environments or doing testing, you might have cache
declarations without having an actual backing cache configured. As this is an invalid
configuration, an exception is thrown at runtime, since the caching infrastructure
is unable to find a suitable store. In situations like this, rather than removing the
cache declarations (which can prove tedious), you can wire in a simple dummy cache that
performs no caching&#8201;&#8212;&#8201;that is, it forces the cached methods to be invoked every time.
The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="cacheManager" class="org.springframework.cache.support.CompositeCacheManager"&gt;
    &lt;property name="cacheManagers"&gt;
        &lt;list&gt;
            &lt;ref bean="jdkCache"/&gt;
            &lt;ref bean="gemfireCache"/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="fallbackToNoOpCache" value="true"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>CompositeCacheManager</code> in the preceding chains multiple <code>CacheManager</code> instances and,
through the <code>fallbackToNoOpCache</code> flag, adds a no-op cache for all the definitions not
handled by the configured cache managers. That is, every cache definition not found in
either <code>jdkCache</code> or <code>gemfireCache</code> (configured earlier in the example) is handled by
the no-op cache, which does not store any information, causing the target method to be
invoked every time.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cache-plug"><a class="anchor" href="#cache-plug"></a>8.6. Plugging-in Different Back-end Caches</h3>
<div class="paragraph">
<p>Clearly, there are plenty of caching products out there that you can use as a backing
store. To plug them in, you need to provide a <code>CacheManager</code> and a <code>Cache</code> implementation,
since, unfortunately, there is no available standard that we can use instead.
This may sound harder than it is, since, in practice, the classes tend to be simple
<a href="https://en.wikipedia.org/wiki/Adapter_pattern">adapters</a> that map the caching abstraction
framework on top of the storage API, as the <code>ehcache</code> classes do. Most <code>CacheManager</code>
classes can use the classes in the <code>org.springframework.cache.support</code> package
(such as <code>AbstractCacheManager</code> which takes care of the boiler-plate code,
leaving only the actual mapping to be completed). We hope that, in time, the libraries
that provide integration with Spring can fill in this small configuration gap.</p>
</div>
</div>
<div class="sect2">
<h3 id="cache-specific-config"><a class="anchor" href="#cache-specific-config"></a>8.7. How can I Set the TTL/TTI/Eviction policy/XXX feature?</h3>
<div class="paragraph">
<p>Directly through your cache provider. The cache abstraction is an abstraction,
not a cache implementation. The solution you use might support various data
policies and different topologies that other solutions do not support (for example,
the JDK <code>ConcurrentHashMap</code>&#8201;&#8212;&#8201;exposing that in the cache abstraction would be useless
because there would no backing support). Such functionality should be controlled
directly through the backing cache (when configuring it) or through its native API.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="appendix"><a class="anchor" href="#appendix"></a>9. Appendix</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="xsd-schemas"><a class="anchor" href="#xsd-schemas"></a>9.1. XML Schemas</h3>
<div class="paragraph">
<p>This part of the appendix lists XML schemas related to integration technologies.</p>
</div>
<div class="sect3">
<h4 id="xsd-schemas-jee"><a class="anchor" href="#xsd-schemas-jee"></a>9.1.1. The <code>jee</code> Schema</h4>
<div class="paragraph">
<p>The <code>jee</code> elements deal with issues related to Java EE (Java Enterprise Edition) configuration,
such as looking up a JNDI object and defining EJB references.</p>
</div>
<div class="paragraph">
<p>To use the elements in the <code>jee</code> schema, you need to have the following preamble at the top
of your Spring XML configuration file. The text in the following snippet references the
correct schema so that the elements in the <code>jee</code> namespace are available to you:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:jee="http://www.springframework.org/schema/jee"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/jee https://www.springframework.org/schema/jee/spring-jee.xsd"&gt;

    &lt;!-- bean definitions here --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-jee-jndi-lookup"><a class="anchor" href="#xsd-schemas-jee-jndi-lookup"></a>&lt;jee:jndi-lookup/&gt; (simple)</h5>
<div class="paragraph">
<p>The following example shows how to use JNDI to look up a data source without the <code>jee</code> schema:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
    &lt;property name="jndiName" value="jdbc/MyDataSource"/&gt;
&lt;/bean&gt;
&lt;bean id="userDao" class="com.foo.JdbcUserDao"&gt;
    &lt;!-- Spring will do the cast automatically (as usual) --&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to use JNDI to look up a data source with the <code>jee</code>
schema:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;jee:jndi-lookup id="dataSource" jndi-name="jdbc/MyDataSource"/&gt;

&lt;bean id="userDao" class="com.foo.JdbcUserDao"&gt;
    &lt;!-- Spring will do the cast automatically (as usual) --&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-jee-jndi-lookup-environment-single"><a class="anchor" href="#xsd-schemas-jee-jndi-lookup-environment-single"></a><code>&lt;jee:jndi-lookup/&gt;</code> (with Single JNDI Environment Setting)</h5>
<div class="paragraph">
<p>The following example shows how to use JNDI to look up an environment variable without
<code>jee</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="simple" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
    &lt;property name="jndiName" value="jdbc/MyDataSource"/&gt;
    &lt;property name="jndiEnvironment"&gt;
        &lt;props&gt;
            &lt;prop key="ping"&gt;pong&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to use JNDI to look up an environment variable with <code>jee</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;jee:jndi-lookup id="simple" jndi-name="jdbc/MyDataSource"&gt;
    &lt;jee:environment&gt;ping=pong&lt;/jee:environment&gt;
&lt;/jee:jndi-lookup&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-jee-jndi-lookup-evironment-multiple"><a class="anchor" href="#xsd-schemas-jee-jndi-lookup-evironment-multiple"></a><code>&lt;jee:jndi-lookup/&gt;</code> (with Multiple JNDI Environment Settings)</h5>
<div class="paragraph">
<p>The following example shows how to use JNDI to look up multiple environment variables
without <code>jee</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="simple" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
    &lt;property name="jndiName" value="jdbc/MyDataSource"/&gt;
    &lt;property name="jndiEnvironment"&gt;
        &lt;props&gt;
            &lt;prop key="sing"&gt;song&lt;/prop&gt;
            &lt;prop key="ping"&gt;pong&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to use JNDI to look up multiple environment variables with
<code>jee</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;jee:jndi-lookup id="simple" jndi-name="jdbc/MyDataSource"&gt;
    &lt;!-- newline-separated, key-value pairs for the environment (standard Properties format) --&gt;
    &lt;jee:environment&gt;
        sing=song
        ping=pong
    &lt;/jee:environment&gt;
&lt;/jee:jndi-lookup&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-jee-jndi-lookup-complex"><a class="anchor" href="#xsd-schemas-jee-jndi-lookup-complex"></a><code>&lt;jee:jndi-lookup/&gt;</code> (Complex)</h5>
<div class="paragraph">
<p>The following example shows how to use JNDI to look up a data source and a number of
different properties without <code>jee</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="simple" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
    &lt;property name="jndiName" value="jdbc/MyDataSource"/&gt;
    &lt;property name="cache" value="true"/&gt;
    &lt;property name="resourceRef" value="true"/&gt;
    &lt;property name="lookupOnStartup" value="false"/&gt;
    &lt;property name="expectedType" value="com.myapp.DefaultThing"/&gt;
    &lt;property name="proxyInterface" value="com.myapp.Thing"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to use JNDI to look up a data source and a number of
different properties with <code>jee</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;jee:jndi-lookup id="simple"
        jndi-name="jdbc/MyDataSource"
        cache="true"
        resource-ref="true"
        lookup-on-startup="false"
        expected-type="com.myapp.DefaultThing"
        proxy-interface="com.myapp.Thing"/&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-jee-local-slsb"><a class="anchor" href="#xsd-schemas-jee-local-slsb"></a><code>&lt;jee:local-slsb/&gt;</code> (Simple)</h5>
<div class="paragraph">
<p>The <code>&lt;jee:local-slsb/&gt;</code> element configures a reference to a local EJB Stateless Session Bean.</p>
</div>
<div class="paragraph">
<p>The following example shows how to configures a reference to a local EJB Stateless Session Bean
without <code>jee</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="simple"
        class="org.springframework.ejb.access.LocalStatelessSessionProxyFactoryBean"&gt;
    &lt;property name="jndiName" value="ejb/RentalServiceBean"/&gt;
    &lt;property name="businessInterface" value="com.foo.service.RentalService"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to configures a reference to a local EJB Stateless Session Bean
with <code>jee</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;jee:local-slsb id="simpleSlsb" jndi-name="ejb/RentalServiceBean"
        business-interface="com.foo.service.RentalService"/&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-jee-local-slsb-complex"><a class="anchor" href="#xsd-schemas-jee-local-slsb-complex"></a><code>&lt;jee:local-slsb/&gt;</code> (Complex)</h5>
<div class="paragraph">
<p>The <code>&lt;jee:local-slsb/&gt;</code> element configures a reference to a local EJB Stateless Session Bean.</p>
</div>
<div class="paragraph">
<p>The following example shows how to configures a reference to a local EJB Stateless Session Bean
and a number of properties without <code>jee</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="complexLocalEjb"
        class="org.springframework.ejb.access.LocalStatelessSessionProxyFactoryBean"&gt;
    &lt;property name="jndiName" value="ejb/RentalServiceBean"/&gt;
    &lt;property name="businessInterface" value="com.example.service.RentalService"/&gt;
    &lt;property name="cacheHome" value="true"/&gt;
    &lt;property name="lookupHomeOnStartup" value="true"/&gt;
    &lt;property name="resourceRef" value="true"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to configures a reference to a local EJB Stateless Session Bean
and a number of properties with <code>jee</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;jee:local-slsb id="complexLocalEjb"
        jndi-name="ejb/RentalServiceBean"
        business-interface="com.foo.service.RentalService"
        cache-home="true"
        lookup-home-on-startup="true"
        resource-ref="true"&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-jee-remote-slsb"><a class="anchor" href="#xsd-schemas-jee-remote-slsb"></a>&lt;jee:remote-slsb/&gt;</h5>
<div class="paragraph">
<p>The <code>&lt;jee:remote-slsb/&gt;</code> element configures a reference to a <code>remote</code> EJB Stateless Session Bean.</p>
</div>
<div class="paragraph">
<p>The following example shows how to configures a reference to a remote EJB Stateless Session Bean
without <code>jee</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="complexRemoteEjb"
        class="org.springframework.ejb.access.SimpleRemoteStatelessSessionProxyFactoryBean"&gt;
    &lt;property name="jndiName" value="ejb/MyRemoteBean"/&gt;
    &lt;property name="businessInterface" value="com.foo.service.RentalService"/&gt;
    &lt;property name="cacheHome" value="true"/&gt;
    &lt;property name="lookupHomeOnStartup" value="true"/&gt;
    &lt;property name="resourceRef" value="true"/&gt;
    &lt;property name="homeInterface" value="com.foo.service.RentalService"/&gt;
    &lt;property name="refreshHomeOnConnectFailure" value="true"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to configures a reference to a remote EJB Stateless Session Bean
with <code>jee</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;jee:remote-slsb id="complexRemoteEjb"
        jndi-name="ejb/MyRemoteBean"
        business-interface="com.foo.service.RentalService"
        cache-home="true"
        lookup-home-on-startup="true"
        resource-ref="true"
        home-interface="com.foo.service.RentalService"
        refresh-home-on-connect-failure="true"&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="xsd-schemas-jms"><a class="anchor" href="#xsd-schemas-jms"></a>9.1.2. The <code>jms</code> Schema</h4>
<div class="paragraph">
<p>The <code>jms</code> elements deal with configuring JMS-related beans, such as Spring&#8217;s
<a href="#jms-mdp">Message Listener Containers</a>. These elements are detailed in the
section of the <a href="#jms">JMS chapter</a> entitled <a href="#jms-namespace">JMS Namespace Support</a>. See that chapter for full details on this support
and the <code>jms</code> elements themselves.</p>
</div>
<div class="paragraph">
<p>In the interest of completeness, to use the elements in the <code>jms</code> schema, you need to have
the following preamble at the top of your Spring XML configuration file. The text in the
following snippet references the correct schema so that the elements in the <code>jms</code> namespace
are available to you:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:jms="http://www.springframework.org/schema/jms"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/jms https://www.springframework.org/schema/jms/spring-jms.xsd"&gt;

    &lt;!-- bean definitions here --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="xsd-schemas-context-mbe"><a class="anchor" href="#xsd-schemas-context-mbe"></a>9.1.3. Using <code>&lt;context:mbean-export/&gt;</code></h4>
<div class="paragraph">
<p>This element is detailed in
<a href="#jmx-context-mbeanexport">Configuring Annotation-based MBean Export</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="xsd-schemas-cache"><a class="anchor" href="#xsd-schemas-cache"></a>9.1.4. The <code>cache</code> Schema</h4>
<div class="paragraph">
<p>You can use the <code>cache</code> elements to enable support for Spring&#8217;s <code>@CacheEvict</code>, <code>@CachePut</code>,
and <code>@Caching</code> annotations. It it also supports declarative XML-based caching. See
<a href="#cache-annotation-enable">Enabling Caching Annotations</a> and
<a href="#cache-declarative-xml">Declarative XML-based Caching</a> for details.</p>
</div>
<div class="paragraph">
<p>To use the elements in the <code>cache</code> schema, you need to have the following preamble at the
top of your Spring XML configuration file. The text in the following snippet references
the correct schema so that the elements in the <code>cache</code> namespace are available to you:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:cache="http://www.springframework.org/schema/cache"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/cache https://www.springframework.org/schema/cache/spring-cache.xsd"&gt;

    &lt;!-- bean definitions here --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 5.3.9<br>
Last updated 2021-07-14 06:36:18 UTC
</div>
</div>
<link rel="stylesheet" href="js/highlight/styles/googlecode.min.css">
<script src="js/highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
<script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="js/toc.js"></script>
</body>
</html>